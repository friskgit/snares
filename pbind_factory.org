#+OPTIONS:   num:nil toc:nil

* tangle sclang
** sclang template
   :PROPERTIES:
   :header-args: :results value code :exports code :noweb yes 
   :END:
   By providing a boiler plate in sclang that fetches data through noweb references a complete Pbind can be constructed. This particular instance fetches a ~\dur~ key word with a ~Pseq()~ data list.
  #+begin_src sclang :tangle pbind.sc 
    Pbind(\instrument, \snare,
	<<repeat_list_full()>>
    ).play
  #+end_src

  #+RESULTS:
  #+BEGIN_SRC sclang
  Pbind(\instrument, \snare,
      \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)
  ).play
  #+END_SRC

** scheme boiler plate
   :PROPERTIES:
   :header-args: :results output raw :exports code :noweb yes :wrap "SRC sclang :tangle sclang_output.txt" 
   :END:
   This is similar to the [[*sclang template][sclang template]] example above, but uses scheme. For some reason it does not appear to be possible to tangle the result of this evaluation, but it works fine with writing it to file on C-c C-c. It applies the various outputs of ~make_pseq()~ and the like as variables. Removing the :file directive makes it output a ready a execute sclang results block.
*** plain
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :var inst="\\snare" :var dur=repeat_list_full() :tangle no
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ").play")
   #+end_src

*** noweb version
    This version of the [[*plain][plain]] example above inserts the code of the ~repeat_list_full~ function definition ([[*repeat list code][repeat list code]]). The Scheme code can be tangled, in this case to 'tangleme.scm'. The result can be saved to file by adding a :file header and specify the name of the file. Finally, the result block (sclang code) can be tangled, but the result block is not generated when the :file directive is present, which writes to sclang_output.txt. Note that this file name is set in the header-args for [[*scheme boiler plate][scheme boiler plate]] and all the code in all results block will appended to the same file.

    In summary:
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\snare" :tangle generic_pbind.scm :noweb yes

     ;; Include repeat_list
     <<repeat_list>>

     ;; Pbind definition to output with instrument
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)

     ;; Repeat the three statements below this for more parameters
     ;; Add a parameter to the EventList
     (format #t "~a, " "\\dur")
     (format #t "~a([" "Pseq")
     ;; Add data to it
     (pseries (apply append (repeat 4 '(1 0.5 0.25))) 0)

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   Pbind(\instrument, \snare,\dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 ], inf)).play
   #+END_SRC

*** pbind for isnare_def
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :tangle vars.scm :var inst="\\isnare" :var dur = repeat_list_full(source_list=(list 0.5 0.4 0.3 0.2)) freq = format_list(elements = list_multiplier_sin(mult=300), param = "\\osc1", function="Prand") noise = format_list(elements = list_multiplier_sin(mult=0.01, add=0), param = "\\noise", function="Prand") freq = format_list(elements = list_multiplier_sin(mult=20, add=2), param = "\\freq", function="Pseq")
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ", ")
     (display freq)
     (display ", ")
     (display noise)
     (display ", ")
     (display freq)
     (display ").play")
   #+end_src

*** noweb isnare2
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\isnare2" :tangle isnare2_pbind.scm :noweb yes

     ;; Include repeat_list
     <<repeat_list_alt>>
     <<isnare2_pbind_list>>
     ;; Pbind definition to output with instrument
     (display "Pbind(\\instrument, ")
     (format #t "~a,~&" inst)

     (print-list 0 (map 
		    (lambda (x) 
		      (format #f "\\~a, ~a" (car x) (cdr x))) attributes))

     ;; Repeat the four statements below this for more parameters
     ;; Add a parameter to the EventList
     (format #t "~a, " "\\dur")
     (format #t "~a([" "Pseq") 
     ;; Add data to it
     (pseries (apply append (repeat 4 '(1 0.5 0.25))) 0)
     (format #t "], ~a" "inf") 

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   Pbind(\instrument, \isnare2,
   \group, ~group,
   \addAction, 1,
   \position, 0,
   \inBus1, ~saw_control_bus_1.index,
   \inBus2, ~saw_control_bus_2.index,
   \inBus3, ~saw_control_bus_3.index,
   \dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], inf).play
   #+END_SRC

*** pbind attribute list
   :PROPERTIES:
   :header-args: :results output
   :END:
   #+name: isnare2_pbind_list
   #+begin_src scheme
     (define (print-list i lst)
       (when (< i (length lst))
	 (format #t "~a,~&" (list-ref lst i))
	 (print-list (1+ i) lst)))

     (define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "inBus1" "~saw_control_bus_1.index")
			      (cons "inBus2" "~saw_control_bus_2.index")
			      (cons "inBus3" "~saw_control_bus_3.index")))

   #+end_src

   #+RESULTS: isnare2_pbind_list
   : \group, ~group,
   : \addAction, 1,
   : \position, 0,
   : \inBus1, ~saw_control_bus_1.index,
   : \inBus2, ~saw_control_bus_2.index,
   : \inBus3, ~saw_control_bus_3.index,

*** testing
   :PROPERTIES:
   :header-args: :results value code
   :END:

   #+begin_src scheme
     (define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "disperse" 1)))
     (map 
      (lambda (x) 
	(format #f "\\~a, ~a," (car x) (cdr x))) attributes)
   #+end_src

** helper functions
*** make p-arrays
**** repeat list code 
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
     #+end_src


**** repeat list code alt
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_alt
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
     #+end_src

**** repeat list full
     This functions returns a full EventList string.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_full
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
     (define (pseries lst i)
       (let ((max (length lst)))
	 (when (< i max)
	   (if (= i (- max 1))
	       (format #t "~a ], inf)" (list-ref lst i))
	       (format #t "~a, " (list-ref lst i)))
	   (pseries lst (1+ i)))))

     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (format #t "~a, " param)
     (format #t "~a([" function)
     (pseries (apply append (repeat reps source_list)) 0)
   #+end_src

   #+RESULTS: repeat_list_full
   : \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)

   #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur" :noweb-ref testing
     (define (pseries lst i)
       (let ((max (length lst)))
	 (when (< i max)
	   (if (= i (- max 1))
	       (format #t "~a ], inf)" (list-ref lst i))
	       (format #t "~a, " (list-ref lst i)))
	   (pseries lst (1+ i)))))

     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (format #t "~a, " param)
     (format #t "~a([" function)
     (pseries (apply append (repeat reps source_list)) 0)
   #+end_src

**** make p-function
    These function all output a variety of P-functions that takes an array as first argument. The exact function to use is specified in the variable 'function'.
    
   Basic function to create a Prand with a list of numbers from 'start' to 'end'. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function.
   Variables:
   - start:
   - end:
   - function: the Supercollider function to apply ("Pseq")
   - param: the parameter to address ("\dur")
   #+name: make_incr_pfunction
   #+begin_src scheme :results output :var start=0 end=20 function="Prand" param="\\dur"
     (define (lp i max)
       (when (< i max)
	 (if (= i (- max 1))
	     (format #t "~a ], inf)" i)
	     (format #t "~a, " i))
	 (lp (+ 1 i) max)))
     (format #t "~a, " param)
     (format #t "~a([" function)
     (lp start end)
   #+end_src

   Similar call to [[*make_pfunction][make_incr_pfunction]] but creating a Pseq instead.
   #+call: make_incr_pfunction(start=5, end=13, function="Pseq")


**** relying on other calls
   Basic function to create a P-type function with a list of numbers supplied as the argument ~elements~. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function. This calles ~repeat_list()~ for the list.
   Variables:
   - function: the Supercollider function to apply ("Pseq")
   - param: the parameter to address ("\dur")
  #+name: format_list
  #+begin_src scheme :results output :noweb yes :var elements = repeat_list() function="Pseq" param="\\dur"
    (define (pseries lst i)
      (let ((max (length lst)))
	(when (< i max)
	  (if (= i (- max 1))
	      (format #t "~a ], inf)" (list-ref lst i))
	      (format #t "~a, " (list-ref lst i)))
	  (pseries lst (1+ i)))))
     (format #t "~a, " param)
     (format #t "~a([" function)
    (pseries elements 0)
  #+end_src

#+call: format_list(elements = list_multiplier_sin(mult=2, add=0))

*** make lists
**** multiply
     Multiply each item in the list with ~mult~
     #+name: list_multiplier
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=0.01
       (map (lambda (x) (* x 0.1)) lst)
     #+end_src

**** multiply->sin
     #+name: list_multiplier_sin
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=200 add=100
       (map (lambda (x) (+ add (* mult (sin x))))
	    (map (lambda (x) (* x 0.1)) lst))
     #+end_src

**** sin function
     Run each item of the list through a sin function.
     #+name: list_sin
     #+begin_src scheme :var lst=incrementing_list[:var lgth=40]() add=2 mult=0.2
       (map (lambda (x) (* (+ (sin x) add) mult)) lst)
     #+end_src

   #+call: list_sin[:var lgth=4]()

**** incrementing
     #+name: incrementing_list
     #+begin_src scheme :var lgth=20
       (define incrementing-list
	 (lambda (n x)
	   (if (= n lgth)
	       x
	       (incrementing-list (+ n 1) (append x (list n))))))
       (incrementing-list 0 '())
     #+end_src

**** proof
     Make a simple call to the function above (noweb in scheme does not appear to be working).
     #+begin_src scheme :noweb yes :results value code :var t=make_incr_pfunction()
       t
     #+end_src

**** list creation
    #+name: my_source
    #+begin_src scheme :var repeats=10 exp=2 base=2
      (append (append (make-list repeats (expt base exp)) (make-list repeats (expt (+ base 1) exp))) (make-list repeats (expt (+ base 2)  exp)))
    #+end_src
**** simple repeat list
   Take a ilst ~lst~ and repeat each item ~n~ times.
   Variables:
   - source_list: the source for the list manipulation.
   - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
   #+name: simple_repeat_list
   #+begin_src scheme :results value :var source_list=(list 1 0.5 0.25 0.125) reps=2
     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (apply append (repeat reps source_list))
   #+end_src
