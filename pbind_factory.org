#+OPTIONS:   num:nil toc:nil

* tangle sclang
** sclang template
   :PROPERTIES:
   :header-args: :results value code :exports code :noweb yes 
   :END:
   By providing a boiler plate in sclang that fetches data through noweb references a complete Pbind can be constructed. This particular instance fetches a ~\dur~ key word with a ~Pseq()~ data list.
  #+begin_src sclang :tangle pbind.sc 
    Pbind(\instrument, \snare,
	<<repeat_list_full()>>
    ).play
  #+end_src

  #+RESULTS:
  #+BEGIN_SRC sclang
  Pbind(\instrument, \snare,
      \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)
  ).play
  #+END_SRC

** scheme boiler plate
   :PROPERTIES:
   :header-args: :results output raw :exports code :noweb yes :wrap "SRC sclang :tangle sclang_output.txt" 
   :END:
   This is similar to the [[*sclang template][sclang template]] example above, but uses scheme. For some reason it does not appear to be possible to tangle the result of this evaluation, but it works fine with writing it to file on C-c C-c. It applies the various outputs of ~make_pseq()~ and the like as variables. Removing the :file directive makes it output a ready a execute sclang results block.
*** plain
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :var inst="\\snare" :var dur=repeat_list_full() :tangle no
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ").play")
   #+end_src

*** noweb version
    This version of the [[*plain][plain]] example above inserts the code of the ~repeat_list_full~ function definition ([[*repeat list code][repeat list code]]). The Scheme code can be tangled, in this case to 'tangleme.scm'. The result can be saved to file by adding a :file header and specify the name of the file. Finally, the result block (sclang code) can be tangled, but the result block is not generated when the :file directive is present, which writes to sclang_output.txt. Note that this file name is set in the header-args for [[*scheme boiler plate][scheme boiler plate]] and all the code in all results block will appended to the same file.

    In summary:
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\snare" :tangle generic_pbind.scm :noweb yes

     ;; Include repeat_list
     <<repeat_list>>

     ;; Pbind definition to output with instrument
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)

     ;; Repeat the three statements below this for more parameters
     ;; Add a parameter to the EventList
     (format #t "~a, " "\\dur")
     (format #t "~a([" "Pseq")
     ;; Add data to it
     (pseries (apply append (repeat 4 '(1 0.5 0.25))) 0)

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   Pbind(\instrument, \snare,\dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 ], inf)).play
   #+END_SRC

*** pbind for isnare_def
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :tangle vars.scm :var inst="\\isnare" :var dur = repeat_list_full(source_list=(list 0.5 0.4 0.3 0.2)) freq = format_list(elements = list_multiplier_sin(mult=300), param = "\\osc1", function="Prand") noise = format_list(elements = list_multiplier_sin(mult=0.01, add=0), param = "\\noise", function="Prand") freq = format_list(elements = list_multiplier_sin(mult=20, add=2), param = "\\freq", function="Pseq")
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ", ")
     (display freq)
     (display ", ")
     (display noise)
     (display ", ")
     (display freq)
     (display ").play")
   #+end_src

*** noweb isnare2
    This creates a Pbind with the attributes defined in ~isnare2_pbind_list~ ([[*pbind attribute list][pbind attribute list]]).
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\isnare2" :tangle isnare2_pbind.scm :noweb yes
     ;; Include repeat_list
     <<repeat_list_alt>>
     <<isnare2_pbind_list>>
     ;; Instantiate the group and the control instruments
     (display "~group = Group.new; ~freq_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_1.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~freq_ctrl2 = Synth(\\control_saw2, [\\bus, ~saw_control_bus_2.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~impulse_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_3.index, \\freq, 0.5, \\mult, 1, \\add, 1], ~group, \\addToHead);")
     (display "Pbind(\\instrument, ")
     (format #t "~a,~&" inst)

     (print-list 0 (map 
		    (lambda (x) 
		      (format #f "\\~a, ~a" (car x) (cdr x))) attributes))

     ;; Repeat the four statements below this for more parameters
     ;; Add a parameter to the EventList

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   ~group = Group.new; ~freq_ctrl = Synth(\control_saw2, [\bus, ~saw_control_bus_1.index, \freq, 1, \mult, 1, \add, 1], ~group, \addToHead); ~freq_ctrl2 = Synth(\control_saw2, [\bus, ~saw_control_bus_2.index, \freq, 1, \mult, 1, \add, 1], ~group, \addToHead); ~impulse_ctrl = Synth(\control_saw2, [\bus, ~saw_control_bus_3.index, \freq, 0.5, \mult, 1, \add, 1], ~group, \addToHead);Pbind(\instrument, \isnare2,
   \group, ~group,
   \addAction, 1,
   \position, 0,
   \disperse, 0,
   \noise, 0,
   \freq, 1,
   \dur, 1,
   \inBus1, ~saw_control_bus_1.index,
   \inBus2, ~saw_control_bus_2.index,
   \inBus3, ~saw_control_bus_3.index,
   ).play
   #+END_SRC

**** Call preset in snares.org
     #+name: preset_1
     #+call: snares.org:isnare_preset_1()

*** pbind attribute list
   :PROPERTIES:
   :header-args: :results output
   :END:
   #+name: isnare2_pbind_list
   #+begin_src scheme
     (define (print-list i lst)
       (when (< i (length lst))
	 (format #t "~a,~&" (list-ref lst i))
	 (print-list (1+ i) lst)))

     (define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "disperse" 0)
			      (cons "noise" 0)
			      (cons "freq" 1)
			      (cons "dur" 1)
			      (cons "inBus1" "~saw_control_bus_1.index")
			      (cons "inBus2" "~saw_control_bus_2.index")
			      (cons "inBus3" "~saw_control_bus_3.index")))

   #+end_src

** helper functions
*** pbind filter attributes
   :PROPERTIES:
   :header-args: :results value
   :END:

**** attribute/value factory
     Call this to create a list of pairs (lists) with attribute name, and value for a give SynthDef. This uses two helper function below that generate the attributes and the values.

     In the version below it outputs a list of pairs, useful for the ~isnare2_pbind_list~ above.
    #+begin_src scheme :noweb yes :var attrs=attribute_list() val=value_list()
      (define valuelist
	(lambda (lstatt lstval newlst)
	  (cond ((= 0 (length lstatt)) newlst)
		((= 0 (length lstval)) newlst)
		((valuelist
		  (cdr lstatt)
		  (cdr lstval)
		  (append newlst (list (list (car lstatt) (car lstval)))))))))

 (valuelist attrs val (list))
    #+end_src

    #+RESULTS:
    | b1  |  0 |
    | b2  |  1 |
    | b3  |  2 |
    | b4  |  3 |
    | b5  |  4 |
    | b6  |  5 |
    | b7  |  6 |
    | b8  |  7 |
    | b9  |  8 |
    | b10 |  9 |
    | b11 | 10 |
    | b12 | 11 |
    | b13 | 12 |
    | b14 | 13 |
    | b15 | 14 |
    | b16 | 15 |

      (map (lambda (x) (cons (car x) (cadr x))) (valuelist attrs val (list)))
    #+RESULTS:

    Generat the attribute list: b0 -> blgth
    #+name: attribute_list
    #+begin_src scheme :var lgth=16
    (define attrlist
       (lambda (n x)
	 (if (= n lgth)
	     x
	     (attrlist (+ n 1) (append x (list (format #f "b~d" (1+ n))))))))
     (attrlist 0 (list))
    #+end_src

    #+RESULTS: attribute_list
    | b1 | b2 | b3 | b4 | b5 | b6 | b7 | b8 | b9 | b10 | b11 | b12 | b13 | b14 | b15 | b16 |

    Generate a list of increasing values, 0-lgth
    #+name: value_list
    #+begin_src scheme :var lgth=16
    (define valuelist
       (lambda (n x)
	 (if (= n lgth)
	     x
	     (valuelist (+ n 1) (append x (list (format #f "~d" n)))))))
     (valuelist 0 (list))
    #+end_src

    #+RESULTS: value_list
    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |

    #+begin_src scheme :results value
      (map
       (lambda (x) (cons (car x) (cadr x))) (list (list 1 2) (list 3 4)))
    #+end_src

    #+RESULTS:
    : ((1 . 2) (3 . 4))

    #+begin_src scheme :results value
(map (lambda (x) (list x)) (list (list 1 2 3 4) (list 5 6 7 8)))
    #+end_src
    #+RESULTS:
    | (1 2 3 4) |
    | (5 6 7 8) |

    #+begin_src scheme :results value
(define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "disperse" 0)
			      (cons "noise" 0)
			      (cons "freq" 1)
			      (cons "dur" 1)
			      (cons "inBus1" "~saw_control_bus_1.index")
			      (cons "inBus2" "~saw_control_bus_2.index")
			      (cons "inBus3" "~saw_control_bus_3.index")))

(car (append "Hej" (cons "hoal" "ert")))
    #+end_src
    #+RESULTS:

   #+begin_src scheme :results output
     (define (print-list i lst)
       (when (< i (length lst))
	 (format #t "~a,~&" (list-ref lst i))
	 (print-list (1+ i) lst)))

     (define attributes (list (list "group" "~group")
			      (list "addAction" 1)
			      (list "position" 0)
			      (list "disperse" 0)
			      (list "noise" 0)
			      (list "freq" 1)
			      (list "dur" 1)
			      (list "inBus1" "~saw_control_bus_1.index")
			      (list "inBus2" "~saw_control_bus_2.index")
			      (list "inBus3" "~saw_control_bus_3.index")))

     (print-list 0 (map 
		    (lambda (x) 
		      (format #f "\\~a, ~a" (car x) (cadr x))) (append attributes (cons 1 2))))
   #+end_src

   #+RESULTS:
   : ERROR: In procedure scm-error:
   : In procedure map: Not a list: (("group" "~group") ("addAction" 1) ("position" 0) ("disperse" 0) ("noise" 0) ("freq" 1) ("dur" 1) ("inBus1" "~saw_control_bus_1.index") ("inBus2" "~saw_control_bus_2.index") ("inBus3" "~saw_control_bus_3.index") 1 . 2)
   : 
   : Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
   : scheme@(guile-user) [1]> 

    #+begin_src scheme :results value 
(fold cons '() '(1 2 3 4))
    #+end_src

    #+RESULTS:
    : <unnamed port>:5:0: In procedure module-lookup: Unbound variable: fold
    : 
    : Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
    : scheme@(guile-user) [1]> 

*** make p-arrays
**** repeat list code 
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
     #+end_src

**** repeat list code alt
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_alt
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
     #+end_src

**** repeat list full
     This functions returns a full EventList string.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_full
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
     (define (pseries lst i)
       (let ((max (length lst)))
	 (when (< i max)
	   (if (= i (- max 1))
	       (format #t "~a ], inf)" (list-ref lst i))
	       (format #t "~a, " (list-ref lst i)))
	   (pseries lst (1+ i)))))

     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (format #t "~a, " param)
     (format #t "~a([" function)
     (pseries (apply append (repeat reps source_list)) 0)
   #+end_src

   #+RESULTS: repeat_list_full
   : \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)

   #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur" :noweb-ref testing
     (define (pseries lst i)
       (let ((max (length lst)))
	 (when (< i max)
	   (if (= i (- max 1))
	       (format #t "~a ], inf)" (list-ref lst i))
	       (format #t "~a, " (list-ref lst i)))
	   (pseries lst (1+ i)))))

     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (format #t "~a, " param)
     (format #t "~a([" function)
     (pseries (apply append (repeat reps source_list)) 0)
   #+end_src

**** make p-function
    These function all output a variety of P-functions that takes an array as first argument. The exact function to use is specified in the variable 'function'.
    
   Basic function to create a Prand with a list of numbers from 'start' to 'end'. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function.
   Variables:
   - start:
   - end:
   - function: the Supercollider function to apply ("Pseq")
   - param: the parameter to address ("\dur")
   #+name: make_incr_pfunction
   #+begin_src scheme :results output :var start=0 end=20 function="Prand" param="\\dur"
     (define (lp i max)
       (when (< i max)
	 (if (= i (- max 1))
	     (format #t "~a ], inf)" i)
	     (format #t "~a, " i))
	 (lp (+ 1 i) max)))
     (format #t "~a, " param)
     (format #t "~a([" function)
     (lp start end)
   #+end_src

   Similar call to [[*make_pfunction][make_incr_pfunction]] but creating a Pseq instead.
   #+call: make_incr_pfunction(start=5, end=13, function="Pseq")

**** relying on other calls
   Basic function to create a P-type function with a list of numbers supplied as the argument ~elements~. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function. This calles ~repeat_list()~ for the list.
   Variables:
   - function: the Supercollider function to apply ("Pseq")
   - param: the parameter to address ("\dur")
  #+name: format_list
  #+begin_src scheme :results output :noweb yes :var elements = repeat_list() function="Pseq" param="\\dur"
    (define (pseries lst i)
      (let ((max (length lst)))
	(when (< i max)
	  (if (= i (- max 1))
	      (format #t "~a ], inf)" (list-ref lst i))
	      (format #t "~a, " (list-ref lst i)))
	  (pseries lst (1+ i)))))
     (format #t "~a, " param)
     (format #t "~a([" function)
    (pseries elements 0)
  #+end_src

#+call: format_list(elements = list_multiplier_sin(mult=2, add=0))

*** make lists
**** multiply
     Multiply each item in the list with ~mult~
     #+name: list_multiplier
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=0.01
       (map (lambda (x) (* x 0.1)) lst)
     #+end_src

**** multiply->sin
     #+name: list_multiplier_sin
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=200 add=100
       (map (lambda (x) (+ add (* mult (sin x))))
	    (map (lambda (x) (* x 0.1)) lst))
     #+end_src

**** sin function
     Run each item of the list through a sin function.
     #+name: list_sin
     #+begin_src scheme :var lst=incrementing_list[:var lgth=40]() add=2 mult=0.2
       (map (lambda (x) (* (+ (sin x) add) mult)) lst)
     #+end_src

   #+call: list_sin[:var lgth=4]()

**** incrementing
     #+name: incrementing_list
     #+begin_src scheme :var lgth=20
       (define incrementing-list
	 (lambda (n x)
	   (if (= n lgth)
	       x
	       (incrementing-list (+ n 1) (append x (list n))))))
       (incrementing-list 0 '())
     #+end_src

**** proof
     Make a simple call to the function above (noweb in scheme does not appear to be working).
     #+begin_src scheme :noweb yes :results value code :var t=make_incr_pfunction()
       t
     #+end_src

**** list creation
    #+name: my_source
    #+begin_src scheme :var repeats=10 exp=2 base=2
      (append (append (make-list repeats (expt base exp)) (make-list repeats (expt (+ base 1) exp))) (make-list repeats (expt (+ base 2)  exp)))
    #+end_src
**** simple repeat list
   Take a ilst ~lst~ and repeat each item ~n~ times.
   Variables:
   - source_list: the source for the list manipulation.
   - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
   #+name: simple_repeat_list
   #+begin_src scheme :results value :var source_list=(list 1 0.5 0.25 0.125) reps=2
     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (apply append (repeat reps source_list))
   #+end_src
