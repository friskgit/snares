#+OPTIONS:   num:nil toc:nil

* tangle sclang
** sclang template
   :PROPERTIES:
   :header-args: :results value code :exports code :noweb yes 
   :END:
   By providing a boiler plate in sclang that fetches data through noweb references a complete Pbind can be constructed. This particular instance fetches a ~\dur~ key word with a ~Pseq()~ data list.
  #+begin_src sclang :tangle pbind.sc 
    Pbind(\instrument, \snare,
	<<repeat_list_full()>>
    ).play
  #+end_src

  #+RESULTS:
  #+BEGIN_SRC sclang
  Pbind(\instrument, \snare,
      \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)
  ).play
  #+END_SRC

** scheme boiler plate
   :PROPERTIES:
   :header-args: :results output raw :exports code :noweb yes :wrap "SRC sclang :tangle sclang_output.txt" 
   :END:
   This is similar to the [[*sclang template][sclang template]] example above, but uses scheme. For some reason it does not appear to be possible to tangle the result of this evaluation, but it works fine with writing it to file on C-c C-c. It applies the various outputs of ~make_pseq()~ and the like as variables. Removing the :file directive makes it output a ready a execute sclang results block.
*** plain
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :var inst="\\snare" :var dur=repeat_list_full() :tangle no
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ").play")
   #+end_src

*** noweb version 
    This version of the [[*plain][plain]] example above inserts the code of the ~repeat_list_full~ function definition ([[*repeat list code][repeat list code]]). The Scheme code can be tangled, in this case to 'tangleme.scm'. The result can be saved to file by adding a :file header and specify the name of the file. Finally, the result block (sclang code) can be tangled, but the result block is not generated when the :file directive is present, which writes to sclang_output.txt. Note that this file name is set in the header-args for [[*scheme boiler plate][scheme boiler plate]] and all the code in all results block will appended to the same file.

    In summary:
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\snare" :tangle generic_pbind.scm :noweb yes

     ;; Include repeat_list
     <<repeat_list>>

     ;; Pbind definition to output with instrument
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)

     ;; Repeat the three statements below this for more parameters
     ;; Add a parameter to the EventList
     (format #t "~a, " "\\dur")
     (format #t "~a([" "Pseq")
     ;; Add data to it
     (pseries (apply append (repeat 4 '(1 0.5 0.25))) 0)

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   Pbind(\instrument, \snare,\dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 ], inf)).play
   #+END_SRC

*** pbind for isnare_def
    This version includes data using :vars. This is more clumsy in terms of execution than using noweb.

    Variables:
    - inst: the SC instrument to send the stream to
    - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :tangle vars.scm :var inst="\\isnare" :var dur = repeat_list_full(source_list=(list 0.5 0.4 0.3 0.2)) freq = format_list(elements = list_multiplier_sin(mult=300), param = "\\osc1", function="Prand") noise = format_list(elements = list_multiplier_sin(mult=0.01, add=0), param = "\\noise", function="Prand") freq = format_list(elements = list_multiplier_sin(mult=20, add=2), param = "\\freq", function="Pseq")
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ", ")
     (display freq)
     (display ", ")
     (display noise)
     (display ", ")
     (display freq)
     (display ").play")
   #+end_src

*** noweb isnare2
    This creates a Pbind with the attributes defined in ~isnare2_pbind_list~ ([[*pbind attribute list][pbind attribute list]]).
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\isnare2" :tangle isnare2_pbind.scm :noweb yes
     ;; Include repeat_list
     <<repeat_list_alt>>
     <<isnare2_pbind_list>>
     ;; Instantiate the group and the control instruments
     (display "~group = Group.new; ~freq_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_1.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~freq_ctrl2 = Synth(\\control_saw2, [\\bus, ~saw_control_bus_2.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~impulse_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_3.index, \\freq, 0.5, \\mult, 1, \\add, 1], ~group, \\addToHead);")
     (display "Pbind(\\instrument, ")
     (format #t "~a,~&" inst)

     (print-list 0 (map 
		    (lambda (x) 
		      (format #f "\\~a, ~a" (car x) (cdr x))) attributes))

     ;; Repeat the four statements below this for more parameters
     ;; Add a parameter to the EventList

     ;; Close the Pbind
     (display ").play")
   #+end_src

**** Call preset in snares.org
     #+name: preset_1
     #+call: snares.org:isnare_preset_1()

*** pbind attribute list
   :PROPERTIES:
   :header-args: :results output
   :END:
   #+name: isnare2_pbind_list
   #+begin_src scheme
     (define (print-list i lst)
       (when (< i (length lst))
	 (format #t "~a,~&" (list-ref lst i))
	 (print-list (1+ i) lst)))

     (define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "disperse" 0)
			      (cons "noise" 0)
			      (cons "freq" 1)
			      (cons "dur" 1)
			      (cons "inBus1" "~saw_control_bus_1.index")
			      (cons "inBus2" "~saw_control_bus_2.index")
			      (cons "inBus3" "~saw_control_bus_3.index")))

   #+end_src

   #+RESULTS: isnare2_pbind_list

** helper functions
*** pbind filter attributes
   :PROPERTIES:
   :header-args: :results value
   :END:
**** attribute/value factory
***** main pbind function
      See last line (call to print-list function) for a method for adding parameter/value pairs to the ~attributes~ list through the variable params as a list of lists: ~(list (list "new1" 1) (list "new2" 2))~, but also, as below, by calling the function filter_attributes.

      The values for the method are:
      - seq-array
      - seq-array-reciprocal 
      - seq-array-exponential
      - seq-array-log
      - seq-array-sin
      - seq-array-cos

      Functions:
      - print-list: format the Pbind
      - attributes: the default list of attributes
      - make-filter-attributes /length arrays-size method shifted/: genrate the key/value pair list to be appended to ~attributes~

	  Functions included from ~filter_attributes~:
	- attributes-array

	  Function included from [[*attribute list][attribute list]]:
	  - attrlist

	  Variables: 
	  - params: a call to filter_attributes (see [[*filter attributes][filter attributes]]) that provides a list of Pseq arrays.
	    #+begin_src scheme :results output raw :exports code :noweb yes :wrap "SRC sclang :tangle sclang_output.txt :results none"
	      <<filter_attributes>>
	      <<shift_list>>

	      (define l 16) ;; length of array
	      (define a 10) ;; number of items in the Pseq
	      (define m 1) ;; method for generating 'a'
	      (define s 1) ;; whether or not 'a' should be shifted
	      (define p "Pseq") ;; function for the array (Pseq, Pshuf, Prand, Pxrand, Place)

	      (define make-filter-attributes
		(lambda (lgth array-size method shifted)
		  (attributes-array (attrlist 0 lgth (list))
				    (make-pbind-array-list 0 lgth
							   (make-shift-list lgth
									    (map
									     (lambda (x) (* -80 x))
									     (select-seq-array 
									      0 array-size (list) method))
									    shifted) '() p) (list))))

	      (define (print-list i lst)
		(when (< i (length lst))
		  (format #t "~a,~&" (list-ref lst i))
		  (print-list (1+ i) lst)))

	      (define attributes (list (list "group" "~group")
				       (list "addAction" 1)
				       (list "position" 0)
				       (list "disperse" 0)
				       (list "noise" 0)
				       (list "freq" 1)
				       (list "dur" 1)
				       (list "inBus1" "~saw_control_bus_1.index")
				       (list "inBus2" "~saw_control_bus_2.index")
				       (list "inBus3" "~saw_control_bus_3.index")))

	      (define filter-mod-attributes (list (list "instrument" "\\isnare_filter_mod")
						  (list "dur" 0.05)
						  (list "freq" 1)
						  (list "freq_mod" 0)
						  (list "del_mod" 0)))
	      (format #t "~a(" "Pbind")
	      (print-list 0 (map 
			     (lambda (x) 
			       (format #f "\\~a, ~a" (car x) (cadr x)))
			     (append filter-mod-attributes
				     (make-filter-attributes l a m s))))
	      (format #t ")~a" ".play;")

	    #+end_src

	    #+RESULTS:
	    #+BEGIN_SRC sclang :tangle sclang_output.txt :results none
	    Pbind(\instrument, \isnare_filter_mod,
	    \dur, 0.05,
	    \freq, 1,
	    \freq_mod, 0,
	    \del_mod, 0,
	    \b1, Pseq([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
	    \b2, Pseq([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
	    \b3, Pseq([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
	    \b4, Pseq([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
	    \b5, Pseq([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
	    \b6, Pseq([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
	    \b7, Pseq([-11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, ], inf),
	    \b8, Pseq([-10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, ], inf),
	    \b9, Pseq([-8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, ], inf),
	    \b10, Pseq([-8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, ], inf),
	    \b11, Pseq([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
	    \b12, Pseq([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
	    \b13, Pseq([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
	    \b14, Pseq([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
	    \b15, Pseq([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
	    \b16, Pseq([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
	    ).play;
	    #+END_SRC

	  Example use of the attribute list function:

	  | b1 | b2 | b3 | b4 |
	  #+begin_src scheme :noweb yes
	    <<filter_attributes>>
	    (attrlist 0 4 '())
	  #+end_src

	  #+RESULTS:
	  | b1 | b2 | b3 | b4 |

	  Example to generate a list of Psequences:

	  | Pseq([0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, ], inf) | Pseq([0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 0.0, ], inf) |
	  #+begin_src scheme :noweb yes :results value
	    <<filter_attributes>>
	    <<shift_list>>
	    (make-pbind-array-list 0 4 (make-shift-list 4 (select-seq-array 0 9 (list) 0) 1) '())
	  #+end_src

	  Example of use of the simpler call to make-pbind-array to generate a list of Psequences:

	  | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) |
	  #+begin_src scheme :noweb yes :results value
	    <<filter_attributes>>
	    <<shift_list>>
	    (make-pbind-array 0 4 4 '())
	  #+end_src

***** filter attributes
      Call this to create a list of pairs (lists) with attribute name, and value for a give SynthDef. This uses two helper function below that generate the attributes and the values. In the version below it outputs a list of pairs, useful for the ~isnare2_pbind_list~ above.

      The code from ~attribute_list~ (see [[*attribute list][attribute list]]) is included and called in the last row (attr_
      The code from ~value_sequence~ is included and called by ~repeats 0 3 5 (list)~ (see [[*value sequence][value sequence]]).

      To use this include <<filter_attributes>> and call:
      
      ~(attributes-array (attrlist 0 length (list)) (repeats 0 items length (list)) (list))~

      The two variables ~length~ and ~items~ need to be set. See [[*filter attributes example][filter attributes example]] for a working example.
      #+name: filter_attributes
      #+begin_src scheme :noweb yes :var lgth=10 items=3
	<<attribute_list>>
	<<value_sequence>>
	<<single_value_list>>

	(define attributes-array
	  (lambda (lstatt lstval newlst)
	    (cond ((= 0 (length lstatt)) newlst)
		  ((= 0 (length lstval)) newlst)
		  ((attributes-array
		    (cdr lstatt)
		    (cdr lstval)
		    (append newlst (list (list (car lstatt) (car lstval)))))))))
      #+end_src

      #+RESULTS: filter_attributes

****** filter attributes examples
       Example using sequenced_array and shift_list to generate the input to make-pbind-array-list.

       Included functions: 
       - attributes-array /attr-list pseq-list new-list/
       - attrlist /index rows result/
       - make-pbind-array-list /index rows list-of-pseq/
       - make-shift-list /size sequence result . flag/: set the flag to 1 for a non-shifted list.
       - seq-array-sin /index size result/: choose the type of parameter list.

       Function:
       - make-filter-attributes /length array-size list-method shifted/: utility method to create an array of filter settings.
       #+begin_src scheme :noweb yes
	 <<shift_list>>
	 <<filter_attributes>>

	 (define make-filter-attributes
	   (lambda (lgth array-size method shifted)
	     (attributes-array (attrlist 0 lgth (list))
			       (make-pbind-array-list 0 4 (make-shift-list 4 (map (lambda (x) (* -80 x)) (select-seq-array 0 20 (list) method)) shifted) '())
			       (list))))
	 (make-filter-attributes 4 4 1 1)
       #+end_src

       #+RESULTS:
       | b1 | Pseq([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -7.272727272727273, -6.666666666666666, -6.153846153846154, -5.7142857142857135, -5.333333333333333, -5.0, -4.705882352941177, -4.444444444444445, -4.2105263157894735, -4.0, ], inf) |
       | b2 | Pseq([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -7.272727272727273, -6.666666666666666, -6.153846153846154, -5.7142857142857135, -5.333333333333333, -5.0, -4.705882352941177, -4.444444444444445, -4.2105263157894735, -4.0, -80.0, ], inf) |
       | b3 | Pseq([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -7.272727272727273, -6.666666666666666, -6.153846153846154, -5.7142857142857135, -5.333333333333333, -5.0, -4.705882352941177, -4.444444444444445, -4.2105263157894735, -4.0, -80.0, -40.0, ], inf) |
       | b4 | Pseq([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -7.272727272727273, -6.666666666666666, -6.153846153846154, -5.7142857142857135, -5.333333333333333, -5.0, -4.705882352941177, -4.444444444444445, -4.2105263157894735, -4.0, -80.0, -40.0, -26.666666666666664, ], inf) |

       #+begin_src scheme :noweb yes
<<sequenced_array>>
(map (lambda (x) (* -80 x)) (select-seq-array 0 9 (list) 0))
       #+end_src

       #+RESULTS:
       | -0.0 | -10.0 | -20.0 | -30.0 | -40.0 | -50.0 | -60.0 | -70.0 | -80.0 |

       Example using sequenced_array and shift_list to generate the input to make-pbind-array-list. Same as above but with arguemnts.

       Functions: 
       - attributes-array /attr-list pseq-list new-list/
       - attrlist /index rows result/
       - make-pbind-array-list /index rows list-of-pseq/
       - make-shift-list /size sequence result . flag/: set the flag to 1 for a non-shifted list.
       - seq-array-sin /index size result/: choose the type of parameter list.
       #+begin_src scheme :noweb yes
	 <<filter_attributes>>
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 ;; create the array of pbind data
	 (define pseq (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array-sin 0 9 (list))) '()))
	 ;; create a table of parameter/value pairs.
	 (attributes-array (attrlist 0 4 (list)) pseq (list))
       #+end_src

       #+RESULTS:
       | b1 | Pseq([0.0, 0.3420201433684985, 0.6427876097563697, 0.8660254038528064, 0.9848077530438666, 0.9848077529726349, 0.8660254036477031, 0.6427876094421329, 0.3420201429830303, ], inf) |
       | b2 | Pseq([0.0, 0.3420201433684985, 0.6427876097563697, 0.8660254038528064, 0.9848077530438666, 0.9848077529726349, 0.8660254036477031, 0.6427876094421329, 0.3420201429830303, ], inf) |
       | b3 | Pseq([0.0, 0.3420201433684985, 0.6427876097563697, 0.8660254038528064, 0.9848077530438666, 0.9848077529726349, 0.8660254036477031, 0.6427876094421329, 0.3420201429830303, ], inf) |
       | b4 | Pseq([0.0, 0.3420201433684985, 0.6427876097563697, 0.8660254038528064, 0.9848077530438666, 0.9848077529726349, 0.8660254036477031, 0.6427876094421329, 0.3420201429830303, ], inf) |

***** attribute list
     Generate the attribute list: b0 -> blgth
     Call this function with ~(attrlist startindx length list-to-append-to)~.
     #+name: attribute_list
     #+begin_src scheme :var lgth=10
     (define attrlist
	(lambda (i n x)
	  (if (= i n)
	      x
	      (attrlist (+ i 1) n (append x (list (format #f "b~d" (1+ i))))))))
     #+end_src

     #+begin_src scheme :noweb yes :results value
       <<attribute_list>>
(attrlist 0 4 (list))
     #+end_src

     #+RESULTS:
     | b1 | b2 | b3 | b4 |

***** single values for attribute lists
      Generate a list of increasing values, 0-lgth
      Call this function with (valuelist startndx length list-to-append-to) which generates a list of pairs (as strings): | 0, 0 | 1, 1 | 2, 2 | 3, 3 | 4, 4 | 5, 5 | 6, 6 | 7, 7 | 8, 8 | 9, 9 |
      #+name: single_value_list
      #+begin_src scheme :var lgth=10
      (define valuelist
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (valuelist (+ i 1) n (append x (list (format #f "~d, ~d" i i)))))))
      #+end_src

      Example call
      #+begin_src scheme :noweb yes
	<<single_value_list>>
	(valuelist 0 10 '())
      #+end_src

***** value sequence
     The following function creates a sequence of Psecs with lgth number of items in the array. 

     Call with ~(make-pbind-array startndx lgth data list-to-append-to)~

     Parameters for repeats:
     - n: start index
     - lgth: the number of Pseqs
     - data: an array of sequences to be entered as the parameter value
     - x: the list to contain the result

     #+name: value_sequence
     #+begin_src scheme :noweb yes :results output
       <<sequenced_array>>

       (define make-pbind-array-list
	 (lambda (n lgth data x . func)
	   (let ((mode (if (pair? func) (car func) "Pseq")))
	     (cond ((= n lgth) x)
		   ((= n (length data)) x)
		   ((make-pbind-array-list (+ n 1) lgth data
					   (append x (list
						      (format #f "~a([~{~a, ~}], inf)"
							      mode (list-ref data n)))) mode))))))

       (define make-pbind-array
	 (lambda (n lgth items x . pmode)
	   (let ((mode (if (pair? pmode) (car pmode) "Pseq")))
	     (if (= n lgth)
		 x
		 (make-pbind-array (+ n 1) lgth items
				   (append x (list
					      (format #f "~a([~{~a, ~}], ~a)"
						      mode (seq-array 0 items '()) "inf"))) mode)))))
     #+end_src

     Example call for ~make-pbind-array~ generating 4 Pseq, each with a list of two members formatted as a Pbind routine. An optional fifth argument can be supplied with another Pattern sequence: ~(make-pbind-array 0 4 2 '() "Prand")~
     #+name: o_value_sequence
     #+begin_src scheme :noweb yes :results value
       <<value_sequence>>
       (make-pbind-array 0 4 4 '())
     #+end_src

     #+RESULTS:
     | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) | Pseq([0.0, 0.3333333333333333, 0.6666666666666666, 1.0, ], inf) |

     Example call for ~make-pbind-array-list~ generating 4 Pseq, each with a list taken from the members of the third argument. The fourt argument is the empty list in which the results are inserted. An optional fifth argument can be supplied with another Pattern sequence: ~(make-pbind-array-list 0 4 '('() '()) '() "Prand")~
     #+begin_src scheme :noweb yes
       <<value_sequence>>
       (make-pbind-array-list 0 4 (list (make-list 4 1) (make-list 4 0.5) (make-list 4 0.25) (make-list 4 0.125)) '())
     #+end_src

     #+RESULTS:
     | Pseq([1, 1, 1, 1, ], inf) | Pseq([0.5, 0.5, 0.5, 0.5, ], inf) | Pseq([0.25, 0.25, 0.25, 0.25, ], inf) | Pseq([0.125, 0.125, 0.125, 0.125, ], inf) |

     #+begin_src scheme :noweb yes
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array 0 3 (list))) '())
     #+end_src

     #+RESULTS:
     | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.5, 1.0, 0.0, ], inf) | Pseq([1.0, 0.0, 0.5, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) |

     #+begin_src scheme :noweb yes
       <<value_sequence>>
       <<sequenced_array>>
       (make-pbind-array-list 0 4 (make-list 4 (seq-array 0 3 (list))) '())
     #+end_src

     #+RESULTS:
     | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) |

***** list creation functions
     Use ~select-seq-array~ as a utility function to be able to select function programmatically. All seg-array-* are normalized.
     #+name: sequenced_array
     #+begin_src scheme
       (define pi 3.141592654)

       (define seq-array
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array (+ i 1) n
			  (append x (list (/ i (- n 1.0))))))))

       (define seq-array-reciprocal
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-reciprocal (+ i 1) n
				     (append x (list
						(/ 1 (+ 1.0 i))))))))

       (define seq-array-exponential
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-exponential (+ i 1) n
				      (append x (list
						 (/ (expt 2 i) (expt 2 (- n 1.0)))))))))

       (define seq-array-log
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-log (+ i 1) n
			      (append x (list (/ (log (+ i 1)) (log n))))))))

       (define seq-array-sin
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-sin (+ i 1) n
			      (append x (list (sin (* (/ i n) pi))))))))

       (define seq-array-cos
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-cos (+ i 1) n
			      (append x (list (cos (* (/ i n) (/ pi 2)))))))))

       (define select-seq-array
	 (lambda (i n x j)
	   (cond ((= j 0) (seq-array i n x))
		 ((= j 1) (seq-array-reciprocal i n x))
		 ((= j 2) (seq-array-exponential i n x))
		 ((= j 3) (seq-array-log i n x))
		 ((= j 4) (seq-array-sin i n x))
		 ((= j 5) (seq-array-cos i n x)))))
       (select-seq-array 0 9 '() 0)
     #+end_src

     #+RESULTS: sequenced_array
     | 0.625 | 0.75 | 0.875 | 1.0 |

    value_sequence example call for the ~seq-array~ function, creating a list of sequence arrays:
     #+begin_src scheme :noweb yes
       <<sequenced_array>>
       (seq-array 0 3 (list))
     #+end_src

     #+RESULTS:
     | 0.0 | 0.5 | 1.0 |

****** shift list
       Shift items in a list and resturn a list of lists, all items shifted by one.

       Functions:
       - duplicate-shift /rows list newlist/: take a list a duplicated it while shifting it one step to the right.
       - make-shift-list /rows list . flag/: utility function that calls duplicate-list. If ~flag~ is supplied with a value of 1 a non-shifted list is generated.
       #+name: shift_list
       #+begin_src scheme
	 (define duplicate-shift
	   (lambda (n lst newlst)
	     (cond ((= 0 n) newlst)
		   ((duplicate-shift (- n 1) 
				     (append (cdr lst) (list (car lst)))
				     (append newlst (list (append (cdr lst) (list (car lst))))))))))

	 (define make-shift-list
	   (lambda (rows lst . flag)
	     (let ((flag (if (pair? flag) (car flag) 0)))
	       (cond ((= flag 1) (duplicate-shift rows lst (list lst)))
		     ((= flag 0) (make-list rows lst))))))
       #+end_src

       Example use of [[*shift list][shift list]] using [[*value sequence][value sequence]]. The latter creates an array of numbers that is duplicated and shifted to the right
       #+begin_src scheme :noweb yes
	 <<sequenced_array>>
	 <<shift_list>>
	 (make-shift-list 5 (seq-array 0 3 (list)) 0)
       #+end_src

       #+RESULTS:
       | 0.0 | 0.5 | 1.0 |
       | 0.0 | 0.5 | 1.0 |
       | 0.0 | 0.5 | 1.0 |
       | 0.0 | 0.5 | 1.0 |
       | 0.0 | 0.5 | 1.0 |

       Example use of shift list and sine mapping, not relying on ~value_sequence~.
       #+begin_src scheme :noweb yes
	 (define lst (iota 5))
	 <<shift_list>>
	 (duplicate-shift 3 (map (lambda (x) (sin (* 0.1 x))) lst) (list (list)))
       #+end_src



****** unused
	 #+begin_src scheme
	   <<shift_list>>

	   (define seq-array
	     (lambda (i n x)
	       (if (= i n)
		   x
		   (seq-array (+ i 1) n
			      (append x (list
					 (/ 1 (+ 1.0 i))))))))

	   (define shifted-seq (duplicate-shift 10 (seq-array 0 10 (list)) (list (seq-array 0 10 (list)))))

	   (define repeats
	     (lambda (n lgth items x)
	       (if (= n items)
		   x
		   (repeats (+ n 1) lgth items
			    (append x (list
				       (format #f "Pseq([~{~a, ~}], inf)"
					       (list-ref shifted-seq n))))))))
	 #+end_src

	 Generate a list of increasing values, 0-lgth
	 #+name: value_list
	 #+begin_src scheme :var lgth=10
	 (define valuelist
	    (lambda (i n x)
	      (if (= i n)
		  x
		  (valuelist (+ i 1) n (append x (list (format #f "Pseq([~d], inf)" (+ i 1))))))))
	  (valuelist 0 lgth (list))
	 #+end_src

	 #+RESULTS: value_list
	 | Pseq([1], inf) | Pseq([2], inf) | Pseq([3], inf) | Pseq([4], inf) | Pseq([5], inf) | Pseq([6], inf) | Pseq([7], inf) | Pseq([8], inf) | Pseq([9], inf) | Pseq([10], inf) |

*** make p-arrays
**** repeat list for rhythmic patterns
     These are the definitions for a list creation call which will return a repeat list based on the input in ~source_list~. To be used for the \dur parameter in a Pbind. This functions returns a full EventList string.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
      Call:
     ~(pseries (apply append (repeat reps source_list)) 0)~ 
     #+name: repeat_list
     #+begin_src scheme :results output :var s=(list 0.5 0.25) r=1 f="Pseq" p="\\dur"
       (define source_list s)
       (define reps r)
       (define function f)
       (define param "\\dur")

       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (format #t "~a, ~a([" param function)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

       (pseries (apply append (repeat reps source_list)) 0)
     #+end_src

     #+RESULTS: repeat_list
     : \dur, Pseq([0.5, 0.5, 0.25, 0.25, 0.25, 0.25 ], inf)

#+call: repeat_list(r=1)

#+RESULTS:
: \dur, Pseq([0.5, 0.5, 0.25, 0.25, 0.25, 0.25 ], inf)

**** repeat list full
     This functions returns a full EventList string.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_full
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

       (format #t "~a, " param)
       (format #t "~a([" function)
       (pseries (apply append (repeat reps source_list)) 0)
     #+end_src
**** make p-function series
     These function all output a variety of P-functions that takes an array as first argument. The exact function to use is specified in the variable 'function'.
    
     Basic function to create a Prand with a list of numbers from 'start' to 'end'. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function.
     Variables:
     - start:
     - end:
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     - multi: the multipler for the output 
     #+name: make_incr_pfunction
     #+begin_src scheme :results output :var start=0 end=20 function="Prand" param="\\dur" multi=1
       (define (lp i max multiplier)
	 (when (< i max)
	   (let ((m (* (/ i max) multiplier)))
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" m)
		 (format #t "~a, " (* (/ i 20.0) m))))
	   (lp (+ 1 i) max multiplier)))

       ;; output
       (format #t "~a, " param)
       (format #t "~a([" function)
       (lp start end multi)
     #+end_src

     #+RESULTS: make_incr_pfunction
     : \dur, Prand([0.0, 0.005000000000000001, 0.020000000000000004, 0.045, 0.08000000000000002, 0.125, 0.18, 0.24499999999999997, 0.32000000000000006, 0.405, 0.5, 0.6050000000000001, 0.72, 0.8450000000000001, 0.9799999999999999, 1.125, 1.2800000000000002, 1.4449999999999998, 1.62, 19/10 ], inf)

     Similar call to [[*make_pfunction][make_incr_pfunction]] but creating a Pseq instead.
     #+call: make_incr_pfunction(start=5, end=13, function="Pseq")

     #+RESULTS:
     : \dur, Pseq([0.09615384615384616, 0.13846153846153847, 0.18846153846153843, 0.24615384615384617, 0.31153846153846154, 0.38461538461538464, 0.4653846153846154, 12/13 ], inf)

**** inject list
     Basic function to create a P-type function with a list of numbers supplied as the argument ~elements~. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function. This calles ~repeat
     Variables:
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: format_list
     #+begin_src scheme :results output :noweb yes :var elements=(list 0.5 0.5 0.4 0.4) function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))
       (format #t "~a, " param)
       (format #t "~a([" function)
       (pseries elements 0)
     #+end_src

     #+RESULTS: format_list
     : \dur, Pseq([0.5, 0.5, 0.4, 0.4 ], inf)

**** inject list, format\_list\_bare
     Basic function to create a P-type function with a list of numbers intended for inclusion via noweb, similar to [[*inject list][the one above]]. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function. This calles ~repeat~. This is intended for use with the \dur parameter.

     Variables:
     - f(unction): the Supercollider function to apply ("Pseq")
     - p(aram): the parameter to address ("\dur")

     Call:
       ~(apply append (repeat 4 (select-seq-array 2 9 '() 0)))~
     #+name: format_list_bare
     #+begin_src scheme :results output :noweb yes
       (define f "Pseq")
       (define p "\\dur")

       (format #t "~a(" "Pbind")
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))
       (format #t "~a, " p)
       (format #t "~a([" f)
     #+end_src

     #+RESULTS: format_list_bare
     : Pbind(\dur, Pseq([Pbind(
     
     Example call for format_list_bare:
     #+begin_src scheme :noweb yes :results output
       <<format_list_bare>> 
       <<select_repeat_list>>
       (pseries (apply append (repeat 8 (select-seq-array 4 18 '() 0))) 0)
       (format #t "~a" ".play")
     #+end_src

     #+RESULTS:
     : Pbind(\dur, Pseq([0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf).play

     #+call: format_list(elements=list_multiplier_sin(mult=2, add=0))

*** make lists
**** multiply
     Multiply each item in the list with ~mult~
     #+name: list_multiplier
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=0.01
       (map (lambda (x) (* x 0.1)) lst)
     #+end_src

     #+RESULTS: list_multiplier
     | 0.0 | 0.1 | 0.2 | 0.30000000000000004 | 0.4 | 0.5 | 0.6000000000000001 | 0.7000000000000001 | 0.8 | 0.9 | 1.0 | 1.1 | 1.2000000000000002 | 1.3 | 1.4000000000000001 | 1.5 | 1.6 | 1.7000000000000002 | 1.8 | 1.9000000000000001 | 2.0 | 2.1 | 2.2 | 2.3000000000000003 | 2.4000000000000004 | 2.5 | 2.6 | 2.7 | 2.8000000000000003 | 2.9000000000000004 | 3.0 |

**** multiply->sin
     #+name: list_multiplier_sin
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=200 add=100
       (map (lambda (x) (+ add (* mult (sin x))))
	    (map (lambda (x) (* x 0.1)) lst))
     #+end_src

**** sin function
     Run each item of the list through a sin function.
     #+name: list_sin
     #+begin_src scheme :var lst=incrementing_list[:var lgth=4]() add=2 mult=0.2
       (map (lambda (x) (* (+ (sin x) add) mult)) lst)
     #+end_src

     #+RESULTS: list_sin
     | 0.4 | 0.5682941969615793 | 0.5818594853651364 | 0.4282240016119735 |

   #+call: list_sin[:var lgth=4]()

**** incrementing
     #+name: incrementing_list
     #+begin_src scheme :var lgth=20
       (define incrementing-list
	 (lambda (n x)
	   (if (= n lgth)
	       x
	       (incrementing-list (+ n 1) (append x (list n))))))
       (incrementing-list 0 '())
     #+end_src

**** proof
     Make a simple call to the function above (noweb in scheme does not appear to be working).
     #+begin_src scheme :noweb yes :results value code :var t=make_incr_pfunction()
       t
     #+end_src

     #+RESULTS:
     #+BEGIN_SRC scheme
     \dur, Prand([0.0, 0.0025000000000000005, 0.010000000000000002, 0.0225, 0.04000000000000001, 0.0625, 0.09, 0.12249999999999998, 0.16000000000000003, 0.2025, 0.25, 0.30250000000000005, 0.36, 0.42250000000000004, 0.48999999999999994, 0.5625, 0.6400000000000001, 0.7224999999999999, 0.81, 19/20 ], inf)
     #+END_SRC

**** list creation
    #+name: my_source
    #+begin_src scheme :var repeats=10 exp=2 base=2
      (append (append (make-list repeats (expt base exp)) (make-list repeats (expt (+ base 1) exp))) (make-list repeats (expt (+ base 2)  exp)))
    #+end_src

    #+RESULTS: my_source
    | 4 | 4 | 4 | 4 | 4 | 4 | 4 | 4 | 4 | 4 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 16 | 16 | 16 | 16 | 16 | 16 | 16 | 16 | 16 | 16 |

**** simple repeat list
   Take a list ~lst~ and repeat each item ~n~ times.
   Variables:
   - source_list: the source for the list manipulation.
   - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
   #+name: simple_repeat_list
   #+begin_src scheme :results value :var source_list=(list 1 0.125 0.25 0.375) reps=2
     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (apply append (repeat reps source_list))
   #+end_src

   #+RESULTS: simple_repeat_list

   Use the output from one of the ~select-seq-array~ and repeat each item by the reciprocal of x multiplied by ~n~.
Call: ~(apply append (repeat 4 (select-seq-array 5 20 '() 0)))~
   #+name: select_repeat_list
   #+begin_src scheme :noweb yes
     <<sequenced_array>>
     (define (repeat n lst)
       (map (lambda (x) 
	      (if (= x 0)
		  (set! x 1))
	      (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
   #+end_src

   Example call for select_repeat_list.
   #+begin_src scheme :noweb yes
     <<select_repeat_list>>
     (apply append (repeat 4 (select-seq-array 2 9 '() 0)))
   #+end_src

   #+RESULTS:
   | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.25 | 0.375 | 0.375 | 0.375 | 0.375 | 0.375 | 0.375 | 0.375 | 0.375 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.625 | 0.625 | 0.625 | 0.625 | 0.75 | 0.75 | 0.75 | 0.75 | 0.875 | 0.875 | 0.875 | 0.875 | 1.0 | 1.0 | 1.0 | 1.0 |
