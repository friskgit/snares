#+OPTIONS:   num:nil toc:nil

* tangle sclang
** sclang template
   :PROPERTIES:
   :header-args: :results value code :exports code :noweb yes 
   :END:
   By providing a boiler plate in sclang that fetches data through noweb references a complete Pbind can be constructed. This particular instance fetches a ~\dur~ key word with a ~Pseq()~ data list.
  #+begin_src sclang :tangle pbind.sc 
    Pbind(\instrument, \snare,
	<<repeat_list_full()>>
    ).play
  #+end_src

  #+RESULTS:
  #+BEGIN_SRC sclang
  Pbind(\instrument, \snare,
      \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)
  ).play
  #+END_SRC

** scheme boiler plate
   :PROPERTIES:
   :header-args: :results output raw :exports code :noweb yes :wrap "SRC sclang :tangle sclang_output.txt" 
   :END:
   This is similar to the [[*sclang template][sclang template]] example above, but uses scheme. For some reason it does not appear to be possible to tangle the result of this evaluation, but it works fine with writing it to file on C-c C-c. It applies the various outputs of ~make_pseq()~ and the like as variables. Removing the :file directive makes it output a ready a execute sclang results block.
*** plain
   Variables:
   - inst: the SC instrument to send the stream to
   - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :var inst="\\snare" :var dur=repeat_list_full() :tangle no
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ").play")
   #+end_src

*** noweb version 
    This version of the [[*plain][plain]] example above inserts the code of the ~repeat_list_full~ function definition ([[*repeat list code][repeat list code]]). The Scheme code can be tangled, in this case to 'tangleme.scm'. The result can be saved to file by adding a :file header and specify the name of the file. Finally, the result block (sclang code) can be tangled, but the result block is not generated when the :file directive is present, which writes to sclang_output.txt. Note that this file name is set in the header-args for [[*scheme boiler plate][scheme boiler plate]] and all the code in all results block will appended to the same file.

    In summary:
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\snare" :tangle generic_pbind.scm :noweb yes

     ;; Include repeat_list
     <<repeat_list>>

     ;; Pbind definition to output with instrument
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)

     ;; Repeat the three statements below this for more parameters
     ;; Add a parameter to the EventList
     (format #t "~a, " "\\dur")
     (format #t "~a([" "Pseq")
     ;; Add data to it
     (pseries (apply append (repeat 4 '(1 0.5 0.25))) 0)

     ;; Close the Pbind
     (display ").play")
   #+end_src

   #+RESULTS:
   #+BEGIN_SRC sclang :tangle sclang_output.txt
   Pbind(\instrument, \snare,\dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 ], inf)).play
   #+END_SRC

*** pbind for isnare_def
    This version includes data using :vars. This is more clumsy in terms of execution than using noweb.

    Variables:
    - inst: the SC instrument to send the stream to
    - dur: the parameter to generate data for, in this case it defaults to make_pseq
   #+begin_src scheme :tangle vars.scm :var inst="\\isnare" :var dur = repeat_list_full(source_list=(list 0.5 0.4 0.3 0.2)) freq = format_list(elements = list_multiplier_sin(mult=300), param = "\\osc1", function="Prand") noise = format_list(elements = list_multiplier_sin(mult=0.01, add=0), param = "\\noise", function="Prand") freq = format_list(elements = list_multiplier_sin(mult=20, add=2), param = "\\freq", function="Pseq")
     (use-modules (ice-9 format))
     (display "Pbind(\\instrument, ")
     (format #t "~a," inst)
     (display dur)
     (display ", ")
     (display freq)
     (display ", ")
     (display noise)
     (display ", ")
     (display freq)
     (display ").play")
   #+end_src

*** noweb isnare2
    This creates a Pbind with the attributes defined in ~isnare2_pbind_list~ ([[*pbind attribute list][pbind attribute list]]).
    - C-c C-c on a code block generates a Pbind
    - C-c C-v t tangles all of the generated files to sclang_output.sc

   Variables:
   - inst: the SC instrument to send the stream to
   #+begin_src scheme :var inst="\\isnare2" :tangle isnare2_pbind.scm :noweb yes
     ;; Include repeat_list
     <<repeat_list_alt>>
     <<isnare2_pbind_list>>
     ;; Instantiate the group and the control instruments
     (display "~group = Group.new; ~freq_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_1.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~freq_ctrl2 = Synth(\\control_saw2, [\\bus, ~saw_control_bus_2.index, \\freq, 1, \\mult, 1, \\add, 1], ~group, \\addToHead); ~impulse_ctrl = Synth(\\control_saw2, [\\bus, ~saw_control_bus_3.index, \\freq, 0.5, \\mult, 1, \\add, 1], ~group, \\addToHead);")
     (display "Pbind(\\instrument, ")
     (format #t "~a,~&" inst)

     (print-list 0 (map 
		    (lambda (x) 
		      (format #f "\\~a, ~a" (car x) (cdr x))) attributes))

     ;; Repeat the four statements below this for more parameters
     ;; Add a parameter to the EventList

     ;; Close the Pbind
     (display ").play")
   #+end_src

**** Call preset in snares.org
     #+name: preset_1
     #+call: snares.org:isnare_preset_1()

*** pbind attribute list
   :PROPERTIES:
   :header-args: :results output
   :END:
   #+name: isnare2_pbind_list
   #+begin_src scheme
     (define (print-list i lst)
       (when (< i (length lst))
	 (format #t "~a,~&" (list-ref lst i))
	 (print-list (1+ i) lst)))

     (define attributes (list (cons "group" "~group")
			      (cons "addAction" 1)
			      (cons "position" 0)
			      (cons "disperse" 0)
			      (cons "noise" 0)
			      (cons "freq" 1)
			      (cons "dur" 1)
			      (cons "inBus1" "~saw_control_bus_1.index")
			      (cons "inBus2" "~saw_control_bus_2.index")
			      (cons "inBus3" "~saw_control_bus_3.index")))

   #+end_src

   #+RESULTS: isnare2_pbind_list

** helper functions
*** pbind filter attributes
   :PROPERTIES:
   :header-args: :results value
   :END:
**** attribute/value factory
***** main pbind function
      See last line (call to print-list function) for a method for adding parameter/value pairs to the ~attributes~ list through the variable params as a list of lists: ~(list (list "new1" 1) (list "new2" 2))~, but also, as below, by calling the function filter_attributes.

      Functions:
      - print-list: format the Pbind
      - attributes: the default list of attributes

      Functions included from ~filter_attributes~:
      - attributes-array

      Function included from [[*attribute list][attribute list]]:
      - attrlist

      Function included from [[*value sequence][value sequence]]:
      - repeats

      Variables: 
      - params: a call to filter_attributes (see [[*filter attributes][filter attributes]]) that provides a list of Pseq arrays.

      Removed:
      - params=filter_attributes(items=6)

	(print-list 0 (map 
	(lambda (x) 
	(format #f "\\~a, ~a" (car x) (cadr x))) (append attributes params)))

	#+begin_src scheme :results output :noweb yes :var lgth=10 items=20
	  <<filter_attributes>>

	  (define params (attributes-array (attrlist 0 lgth (list)) (repeats 0 items lgth (list)) (list)))

	  (define (print-list i lst)
	    (when (< i (length lst))
	      (format #t "~a,~&" (list-ref lst i))
	      (print-list (1+ i) lst)))

	  (define attributes (list (list "group" "~group")
				   (list "addAction" 1)
				   (list "position" 0)
				   (list "disperse" 0)
				   (list "noise" 0)
				   (list "freq" 1)
				   (list "dur" 1)
				   (list "inBus1" "~saw_control_bus_1.index")
				   (list "inBus2" "~saw_control_bus_2.index")
				   (list "inBus3" "~saw_control_bus_3.index")))

	  (print-list 0 (map 
			 (lambda (x) 
			   (format #f "\\~a, ~a" (car x) (cadr x))) (append attributes params)))

	#+end_src

	#+begin_src scheme :var params=filter_attributes(items=8)
	  params
	#+end_src

      #+begin_src scheme :noweb yes
	  <<filter_attributes>>
(repeats 0 2 2 (list))
      #+end_src

      #+RESULTS:
      | Pseq([1.0, 0.5, 0.3333333333333333, 0.25, 0.2, 0.16666666666666666, 0.14285714285714285, 0.125, 0.1111111111111111, 0.1, ], inf) | Pseq([0.5, 0.3333333333333333, 0.25, 0.2, 0.16666666666666666, 0.14285714285714285, 0.125, 0.1111111111111111, 0.1, 1.0, ], inf) |

***** filter attributes
      Call this to create a list of pairs (lists) with attribute name, and value for a give SynthDef. This uses two helper function below that generate the attributes and the values. In the version below it outputs a list of pairs, useful for the ~isnare2_pbind_list~ above.

      The code from ~attribute_list~ (see [[*attribute list][attribute list]]) is included and called in the last row (attr_
      The code from ~value_sequence~ is included and called by ~repeats 0 3 5 (list)~ (see [[*value sequence][value sequence]]).

      To use this include <<filter_attributes>> and call:
      
      ~(attributes-array (attrlist 0 length (list)) (repeats 0 items length (list)) (list))~

      The two variables ~length~ and ~items~ need to be set. See [[*filter attributes example][filter attributes example]] for a working example.
      #+name: filter_attributes
      #+begin_src scheme :noweb yes :var lgth=10 items=3
	<<attribute_list>>
	<<value_sequence>>
	<<single_value_list>>

	(define attributes-array
	  (lambda (lstatt lstval newlst)
	    (cond ((= 0 (length lstatt)) newlst)
		  ((= 0 (length lstval)) newlst)
		  ((attributes-array
		    (cdr lstatt)
		    (cdr lstval)
		    (append newlst (list (list (car lstatt) (car lstval)))))))))
      #+end_src

****** filter attributes example
       Simple example with a specified list.
       #+begin_src scheme :noweb yes
	 <<filter_attributes>>
	 (attributes-array (attrlist 0 4 (list)) (repeats 0 3 4 (list)) (list))
       #+end_src

       #+RESULTS:
       
       Example using sequenced_array and shift_list to generate the input to make-pbind-array-list.
       #+begin_src scheme :noweb yes
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array-sin 0 9 (list))) '())
       #+end_src

       Example using sequenced_array and shift_list to generate the input to make-pbind-array-list.
       #+begin_src scheme :noweb yes
	 <<filter_attributes>>
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 ;; create the array of pbind data
	 (define pseq (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array-sin 0 9 (list))) '()))
	 ;; create a table of parameter/value pairs.
	 (attributes-array (attrlist 0 5 (list)) pseq (list))
       #+end_src

       Same as above without saving the list in a variable.
       #+begin_src scheme :noweb yes
	 <<filter_attributes>>
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 ;; create the array of pbind data
	 (define pseq (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array-sin 0 9 (list))) '()))
	 ;; create a table of parameter/value pairs.
	 (attributes-array 
	  (attrlist 0 5 (list))
	  (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array-sin 0 9 (list))) '())
	  (list))
       #+end_src

***** attribute list
     Generate the attribute list: b0 -> blgth
     Call this function with ~(attrlist startindx length list-to-append-to)~.
     #+name: attribute_list
     #+begin_src scheme :var lgth=10
     (define attrlist
	(lambda (i n x)
	  (if (= i n)
	      x
	      (attrlist (+ i 1) n (append x (list (format #f "b~d" (1+ i))))))))
     #+end_src

     #+begin_src scheme :noweb yes :results value
       <<attribute_list>>
(attrlist 0 4 (list))
     #+end_src

     #+RESULTS:
     | b1 | b2 | b3 | b4 |

***** single values for attribute lists
      Generate a list of increasing values, 0-lgth
      Call this function with (valuelist startndx length list-to-append-to)
      #+name: single_value_list
      #+begin_src scheme :var lgth=10
      (define valuelist
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (valuelist (+ i 1) n (append x (list (format #f "~d, ~d" i i)))))))
      #+end_src

      #+RESULTS: single_value_list

***** value sequence
     The following function creates a sequence of Psecs with lgth number of items in the array. 

     Call with ~(repeats startndx items lines list-to-append-to)~

     Parameters seq-array
     - i: current index
     - n: length or list
     - x: the list to contain the result

     Parameters for repeats:
     - n: start index
     - lgth: the number of Pseqs
     - data: an array of sequences to be entered as the parameter value
     - x: the list to contain the result

 ;; make individual calls for seq-array for each item in the list, generating equal set of parameters
     #+name: value_sequence
     #+begin_src scheme :noweb yes :results output
	      <<sequenced_array>>

	      (define make-pbind-array-list
		(lambda (n lgth data x . pmode)
		  (let ((mode (if (pair? pmode) (car pmode) "Pseq")))
		  (cond ((= n lgth) x)
			((= n (length data)) x)
			((make-pbind-array-list (+ n 1) lgth data
						(append x (list
							   (format #f "~a([~{~a, ~}], inf)"
								   mode (list-ref data n)))) mode))))))

	      (define make-pbind-array
		(lambda (n lgth items x . pmode)
		  (let ((mode (if (pair? pmode) (car pmode) "Pseq")))
		    (if (= n lgth)
			x
			(make-pbind-array (+ n 1) lgth items
					  (append x (list
						     (format #f "~a([~{~a, ~}], ~a)"
							     mode (seq-array 0 items '()) "inf"))) mode)))))
     #+end_src

     Example call for ~make-pbind-array~ generating 4 Pseq, each with a list of two members formatted as a Pbind routine. An optional fifth argument can be supplied with another Pattern sequence: ~(make-pbind-array 0 4 2 '() "Prand")~
     #+begin_src scheme :noweb yes
       <<value_sequence>>
       (make-pbind-array 0 4 2 '())
     #+end_src

     Example call for ~make-pbind-array-list~ generating 4 Pseq, each with a list taken from the members of the third argument. The fourt argument is the empty list in which the results are inserted. An optional fifth argument can be supplied with another Pattern sequence: ~(make-pbind-array-list 0 4 '('() '()) '() "Prand")~
     #+begin_src scheme :noweb yes
       <<value_sequence>>
       (make-pbind-array-list 0 4 (list (list 1 2 3) (list 4 4 4) (list 5 5 5) (list 6 6 6)) '())
     #+end_src

     #+RESULTS:
     | Pseq([1, 2, 3, ], inf) | Pseq([4, 4, 4, ], inf) | Pseq([5, 5, 5, ], inf) | Pseq([6, 6, 6, ], inf) |

     #+begin_src scheme :noweb yes
	 <<sequenced_array>>
	 <<shift_list>>
	 <<value_sequence>>
	 (make-pbind-array-list 0 4 (make-shift-list 4 (seq-array 0 3 (list))) '())
     #+end_src

     #+RESULTS:
     | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.5, 1.0, 0.0, ], inf) | Pseq([1.0, 0.0, 0.5, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) |

     #+begin_src scheme :noweb yes
       <<value_sequence>>
       <<sequenced_array>>
       (make-pbind-array-list 0 4 (make-list 4 (seq-array 0 3 (list))) '())
     #+end_src

     #+RESULTS:
     | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) | Pseq([0.0, 0.5, 1.0, ], inf) |

     #+name: sequenced_array
     #+begin_src scheme
       (define pi 3.141592654)

       (define seq-array
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array (+ i 1) n
			  (append x (list (/ i (- n 1.0))))))))

       (define seq-array-reciprocal
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-reciprocal (+ i 1) n
				     (append x (list
						(/ 1 (+ 1.0 i))))))))

       (define seq-array-exponential
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-exponential (+ i 1) n
				      (append x (list
						 (/ (expt 2 i) (expt 2 (- n 1.0)))))))))

       (define seq-array-log
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-log (+ i 1) n
			      (append x (list (/ (log (+ i 1)) (log n))))))))

       (define seq-array-sin
	 (lambda (i n x)
	   (if (= i n)
	       x
	       (seq-array-sin (+ i 1) n
			      (append x (list (sin (* (/ i n) pi))))))))

     #+end_src

    value_sequence example call for the ~seq-array~ function, creating a list of sequence arrays:
     #+begin_src scheme :noweb yes
       <<sequenced_array>>
       (seq-array 0 3 (list))
     #+end_src

****** shift list
       Shift items in a list and resturn a list of lists, all items shifted by one.

       Functions:
       - duplicate-shift /rows list newlist/: take a list a duplicated it while shifting it one step to the right.
       - make-shift-list /rows list/: utility function that calls duplicate-list.
       #+name: shift_list
       #+begin_src scheme
	 (define duplicate-shift
	   (lambda (n lst newlst)
	     (cond ((= 0 n) newlst)
		   ((duplicate-shift (- n 1) 
				     (append (cdr lst) (list (car lst)))
				     (append newlst (list (append (cdr lst) (list (car lst))))))))))

	 (define make-shift-list
	   (lambda (rows lst)
	     (duplicate-shift rows lst (list lst))))

	 (define make-noshift-list
	   (lambda (rows lst)
	     (make-list rows lst)))
       #+end_src

       Example use of [[*shift list][shift list]] using [[*value sequence][value sequence]]. The latter creates an array of numbers that is duplicated and shifted to the right
       #+begin_src scheme :noweb yes
	 <<sequenced_array>>
	 <<shift_list>>
	 (make-shift-list 5 (seq-array 0 3 (list)))
       #+end_src

       #+RESULTS:
       | 0.0 | 0.5 | 1.0 |
       | 0.5 | 1.0 | 0.0 |
       | 1.0 | 0.0 | 0.5 |
       | 0.0 | 0.5 | 1.0 |
       | 0.5 | 1.0 | 0.0 |
       | 1.0 | 0.0 | 0.5 |

       Example use of shift list and sine mapping, not relying on ~value_sequence~.
       #+begin_src scheme :noweb yes
	 (define lst (iota 5))
	 <<shift_list>>
	 (duplicate-shift 3 (map (lambda (x) (sin (* 0.1 x))) lst) (list (list)))
       #+end_src



****** unused
	 #+begin_src scheme
	   <<shift_list>>

	   (define seq-array
	     (lambda (i n x)
	       (if (= i n)
		   x
		   (seq-array (+ i 1) n
			      (append x (list
					 (/ 1 (+ 1.0 i))))))))

	   (define shifted-seq (duplicate-shift 10 (seq-array 0 10 (list)) (list (seq-array 0 10 (list)))))

	   (define repeats
	     (lambda (n lgth items x)
	       (if (= n items)
		   x
		   (repeats (+ n 1) lgth items
			    (append x (list
				       (format #f "Pseq([~{~a, ~}], inf)"
					       (list-ref shifted-seq n))))))))
	 #+end_src

	 Generate a list of increasing values, 0-lgth
	 #+name: value_list
	 #+begin_src scheme :var lgth=10
	 (define valuelist
	    (lambda (i n x)
	      (if (= i n)
		  x
		  (valuelist (+ i 1) n (append x (list (format #f "Pseq([~d], inf)" (+ i 1))))))))
	  (valuelist 0 lgth (list))
	 #+end_src

	 #+RESULTS: value_list
	 | Pseq([1], inf) | Pseq([2], inf) | Pseq([3], inf) | Pseq([4], inf) | Pseq([5], inf) | Pseq([6], inf) | Pseq([7], inf) | Pseq([8], inf) | Pseq([9], inf) | Pseq([10], inf) |

*** make p-arrays
**** repeat list code 
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))
     #+end_src

     #+RESULTS: repeat_list
     : ice-9/psyntax.scm:2338:44: In procedure expand-let:
     : Syntax error:
     : unknown file:5:0: no expressions in body in form (let ((source_list (quote (0.5 0.25 0.125 0.0625))) (reps (quote 4)) (function (quote "Pseq")) (param (quote "\\dur"))) (define (pseries lst i) (let ((max (length lst))) (when (< i max) (if (= i (- max 1)) (format #t "~a ], inf)" (list-ref lst i)) (format #t "~a, " (list-ref lst i))) (pseries lst (#{1+}# i))))) (define (repeat n lst) (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst)))
     : 
     : Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
     : scheme@(guile-user) [1]> 

**** repeat list code alt
     These are the definitions only for a list creation call, such as ~(pseries (apply append (repeat reps source_list)) 0)~ which will return a repeat list based on the input in ~source_list~.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_alt
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

(pseries (apply append (repeat reps source_list)) 0)
     #+end_src

     #+RESULTS: repeat_list_alt
     : 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625

**** repeat list full
     This functions returns a full EventList string.
     Functions:
     - pseries: function that prints out the items of a list in the context of a Pseq or similar.
     - repeat: Repeats items of a list
     Variables:
     - source_list: the source for the list manipulation.
     - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: repeat_list_full
     #+begin_src scheme :results output :var source_list=(list 0.5 0.25 0.125 0.0625) reps=4 function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))

       (define (repeat n lst)
	 (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

       (format #t "~a, " param)
       (format #t "~a([" function)
       (pseries (apply append (repeat reps source_list)) 0)
     #+end_src

     #+RESULTS: repeat_list_full
     : \dur, Pseq([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625 ], inf)

**** make p-function series
     These function all output a variety of P-functions that takes an array as first argument. The exact function to use is specified in the variable 'function'.
    
     Basic function to create a Prand with a list of numbers from 'start' to 'end'. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function.
     Variables:
     - start:
     - end:
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: make_incr_pfunction
     #+begin_src scheme :results output :var start=0 end=20 function="Prand" param="\\dur"
       (define (lp i max)
	 (when (< i max)
	   (if (= i (- max 1))
	       (format #t "~a ], inf)" i)
	       (format #t "~a, " i))
	   (lp (+ 1 i) max)))
       (format #t "~a, " param)
       (format #t "~a([" function)
       (lp start end)
     #+end_src

     Similar call to [[*make_pfunction][make_incr_pfunction]] but creating a Pseq instead.
     #+call: make_incr_pfunction(start=5, end=13, function="Pseq")

     #+RESULTS:
     : \dur, Pseq([5, 6, 7, 8, 9, 10, 11, 12 ], inf)

**** relying on other calls
     Basic function to create a P-type function with a list of numbers supplied as the argument ~elements~. This could equally well be injected in the template [[*sclang template][sclang template]]. Note that it is necessary to escape the backslash in the ~(format)~ function. This calles ~repeat
     Variables:
     - function: the Supercollider function to apply ("Pseq")
     - param: the parameter to address ("\dur")
     #+name: format_list
     #+begin_src scheme :results output :noweb yes :var elements = repeat_list() function="Pseq" param="\\dur"
       (define (pseries lst i)
	 (let ((max (length lst)))
	   (when (< i max)
	     (if (= i (- max 1))
		 (format #t "~a ], inf)" (list-ref lst i))
		 (format #t "~a, " (list-ref lst i)))
	     (pseries lst (1+ i)))))
       (format #t "~a, " param)
       (format #t "~a([" function)
       (pseries elements 0)
     #+end_src

     #+RESULTS: format_list
     : ERROR: In procedure length:
     : In procedure length: Wrong type argument in position 1: "ice-9/psyntax.scm:2338:44: In procedure expand-let:\nSyntax error:\nunknown file:5:0: no expressions in body in form (let ((source_list (quote (0.5 0.25 0.125 0.0625))) (reps (quote 4)) (function (quote \"Pseq\")) (param (quote \"\\\\dur\"))) (define (pseries lst i) (let ((max (length lst))) (when (< i max) (if (= i (- max 1)) (format #t \"~a ], inf)\" (list-ref lst i)) (format #t \"~a, \" (list-ref lst i))) (pseries lst (#{1+}# i))))) (define (repeat n lst) (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst)))\n\nEntering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.\nscheme@(guile-user) [1]> "
     : 
     : Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
     : scheme@(guile-user) [1]> 

     #+call: format_list(elements = list_multiplier_sin(mult=2, add=0))

*** make lists
**** multiply
     Multiply each item in the list with ~mult~
     #+name: list_multiplier
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=0.01
       (map (lambda (x) (* x 0.1)) lst)
     #+end_src

**** multiply->sin
     #+name: list_multiplier_sin
     #+begin_src scheme :var lst=incrementing_list(lgth=31) mult=200 add=100
       (map (lambda (x) (+ add (* mult (sin x))))
	    (map (lambda (x) (* x 0.1)) lst))
     #+end_src

**** sin function
     Run each item of the list through a sin function.
     #+name: list_sin
     #+begin_src scheme :var lst=incrementing_list[:var lgth=40]() add=2 mult=0.2
       (map (lambda (x) (* (+ (sin x) add) mult)) lst)
     #+end_src

   #+call: list_sin[:var lgth=4]()

**** incrementing
     #+name: incrementing_list
     #+begin_src scheme :var lgth=20
       (define incrementing-list
	 (lambda (n x)
	   (if (= n lgth)
	       x
	       (incrementing-list (+ n 1) (append x (list n))))))
       (incrementing-list 0 '())
     #+end_src

**** proof
     Make a simple call to the function above (noweb in scheme does not appear to be working).
     #+begin_src scheme :noweb yes :results value code :var t=make_incr_pfunction()
       t
     #+end_src

**** list creation
    #+name: my_source
    #+begin_src scheme :var repeats=10 exp=2 base=2
      (append (append (make-list repeats (expt base exp)) (make-list repeats (expt (+ base 1) exp))) (make-list repeats (expt (+ base 2)  exp)))
    #+end_src
**** simple repeat list
   Take a ilst ~lst~ and repeat each item ~n~ times.
   Variables:
   - source_list: the source for the list manipulation.
   - reps: the number of repetitions for the original item, other items are repeated ~(* (/ 1 divisor) repeats)~
   #+name: simple_repeat_list
   #+begin_src scheme :results value :var source_list=(list 1 0.5 0.25 0.125) reps=2
     (define (repeat n lst)
       (map (lambda (x) (make-list (* (inexact->exact (floor (/ 1 x))) n) x)) lst))

     (apply append (repeat reps source_list))
   #+end_src
   
