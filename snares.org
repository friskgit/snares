* Snare snippets
** audio init
   #+begin_src sclang :results none
     (
     ServerOptions.devices;
     s = Server.local;
     Server.local = Server.default;
     o = Server.local.options; // Get the local server's options
     o.device = "JackRouter";
     o.numOutputBusChannels = 16;
     o.numWireBufs = 128;
     o.memSize = 16384;
     //o.device = "Built-in Output";
     s.makeWindow;
     s.boot;
     )
   #+end_src
   #+begin_src sclang :results none
     s.quit;
   #+end_src
** jack
*** status
    #+begin_src shell
      jcon -c
    #+end_src

    #+RESULTS:

*** startup
    plain two channel interface, start asynchronous
    #+begin_src shell :async
      startjack -r 48000 -c 2
    #+end_src

    #+RESULTS:

    Edirol
    #+begin_src shell :async
      startjack -r 48000 -c 2 -d jp_co_roland_RDUSB00E6Dev_AudioEngine:14500000:0
    #+end_src

    #+RESULTS:

    #+begin_src shell
      startjack -l
    #+end_src

    #+RESULTS:

*** jconvolver
   start jconvolver 
   #+begin_src shell :dir ~/Library/mcfx/convolver_presets/kmh_lilla_salen_29/ :async
     echo "Starting up jconvolver"
     jconvolver_static_0.9.2.2 KMH_LILLA_SALEN.conf &
   #+end_src

   #+RESULTS:
   : Starting up jconvolver

   connect jconvolver to jack
   #+begin_src shell 
     jcon jcon out sys play 2
   #+end_src

   #+RESULTS:
   | Connecting | jconvolver:out_1 | to | system:playback_1 |
   | Connecting | jconvolver:out_2 | to | system:playback_2 |

    connect supercollider to jconvolver
   #+begin_src shell :results replace
     jcon scsyn out jcon in 16
     jcon jcon out system play 2
   #+end_src

*** connect multi to stereo
   - Odd multi output to left out
   - Even to right output
    #+begin_src shell
      for i in {0..8}; do
	  if ((i % 2 == 0)); then
	      jcon scsynth out$i sys playback_2 1;
	  else 
	      jcon scsynth out$i sys playback_1 1;
	  fi
      done
    #+end_src

    #+RESULTS:
    | Connecting | scsynth:out1 | to | system:playback_1 |
    | Connecting | scsynth:out2 | to | system:playback_2 |
    | Connecting | scsynth:out3 | to | system:playback_1 |
    | Connecting | scsynth:out4 | to | system:playback_2 |
    | Connecting | scsynth:out5 | to | system:playback_1 |
    | Connecting | scsynth:out6 | to | system:playback_2 |
    | Connecting | scsynth:out7 | to | system:playback_1 |
    | Connecting | scsynth:out8 | to | system:playback_2 |

    specific version of the above.
   #+begin_src shell :results replace
     jdis -a
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jcon scsynth out$i sys playback_1 1; 
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jcon scsynth out$i sys playback_2 1; 
     done
   #+end_src

    disconnect it
   #+begin_src shell :results replace
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jdis -d scsynth out$i sys playback_1;
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jdis -d scsynth out$i sys playback_2;
     done
   #+end_src

*** disconnect stereo
    #+begin_src shell :results replace
echo "Hej"
for i in {1..2}; do
 echo "$i"
done
#      jdis -d sys  sc 1
    #+end_src

    #+RESULTS:

*** jack for i_dispersed_snare in 1D118
   #+begin_src shell :results replace
     jdis -a
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jcon scsynth out$i sys playback_1 1; 
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jcon scsynth out$i sys playback_2 1; 
     done
   #+end_src

** recorder
   #+property: header-args:shell :var dir="/Users/henrik_frisk/Music/pieces/snares/audio/"

   #+name: record_me
   #+begin_src sclang :results none
     s.prepareForRecord("~/Music/single.wav", numChannels: 16);
     s.record;
   #+end_src
   #+name: rename_file
   #+begin_src shell :var fname="isnare_filter_routine.wav"
     file="/Users/henrik_frisk/Music/single.wav"
     mv "$file" "$dir$fname"
     echo "Moved $file to $dir and renamed it $fname"
   #+end_src

   #+begin_src sclang :results none
     s.pauseRecording;
   #+end_src
   #+name: stop_record
   #+begin_src sclang :results none
     s.stopRecording;
   #+end_src

   #+name: print_files
   #+begin_src shell
     ls "$dir"
   #+end_src

** play routines
   Routine recorded on July 24
   #+begin_src shell :noweb yes :results none
     echo "<<isnare_filter_mod()>>"
     echo "<<isnare_filter_routine()>>"
   #+end_src
** test tone
   #+begin_src sclang :results none
     {SinOsc.ar(440, 0, 0.1)}.play;
   #+end_src

   #+begin_src sclang :results none
r = Pbind(
\note, Pseq([1, 2, 3, ], inf)
)
   #+end_src
   #+begin_src sclang :results none

   #+end_src
** snare synths
*** snare 1
**** synthdef
     Simple instance of a snare synth
     #+begin_src sclang :results none
       (
       SynthDef(\snare, { | gain=4, freq=200, vol=2, q=1 |
	   var snd;
	   var env = Env([0, 1, 0], [0.0001, 0.5]);
	   snd = Snare.ar(0.00001, freq, gain, 1, q, 0.01, vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
	   Out.ar(0, snd);
       }).add;
       )
     #+end_src
**** player
     Play one hit on the snare above.
     #+name: reg_snare_load
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snare", [\freq, 100] );
     #+end_src

**** pbind: fast irregular, no snare.
     #+begin_src sclang :results none
       Pbind(\instrument, \snare,
	 \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
	   \dur, Prand([0.1, 0.2], inf),
\q, Prand([0.001, 5, 2], inf)
       ).play;
     #+end_src

     #+begin_src sclang :results none
       a = Pbind(\instrument, \snare,
	 \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
\dur, Pseq([0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
\q, Prand([0.001, 5, 2], inf)
       );
       b = Pbind(\instrument, \snare,
	 \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
\dur, Pseq([0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
       );
Ptpar([0.0, a, 0.1, b, 0.2, a]).play;
     #+end_src

*** snare 2
    Simple instance of a snare synth with more noise
    #+begin_src sclang :results none
      (
      SynthDef(\snares, { | gain=2, freq=200, vol=2, q=10 |
	  var snd;
	  var env = Env([0, 1, 0], [0.0001, 0.5]);
	  snd = Snares.ar(attack: 0.00001, freq: freq, gain: gain, q: q, rel: 0.01, vol_0: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
	  Out.ar(0, snd);
      }).add;
      )
    #+end_src
**** player
     Play one hit on the snare above.
     #+name: snares_load
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snares", [\freq, 100] );
     #+end_src
*** snare 3 (isnare2)
**** Example without groups
    Synth that is driven by an Impulse pulse generator.
    Load first the SynthDefs below.
    #+name: isnare_def
    #+begin_src sclang :results none
      (
      // Main snare synth
      SynthDef(\isnare, { | inBus1=0, inBus2=1, inBus3=2, inBus4=3, outBus=0, freq=2, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, dur=1 |
	  var snd;
	  var env;
	  var envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]);
	  b = 0;
	  envelope.times.do({ arg i; b = b + i; });
	  c = dur / b;
	  env = EnvGen.kr(
	      envelope,
	      timeScale: c,
	      doneAction: Done.freeSelf);
	  snd = IDispersedSnare.ar(Impulse.ar(freq), position, disperse, osc_1_freq: In.kr(inBus2), osc_2_freq: In.kr(inBus2) - 50, triangle_freq: In.kr(inBus3), noise_lvl: In.kr(inBus4)) * gain * env;
	  Out.ar(outBus, snd);
      }).add;

      // Control synth 1, modulated oscillator
      SynthDef(\control_osc, {
	  Out.kr(\bus.ir,
	      SinOsc.kr(
		  // modulate the frequency of the modulator
		  Line.kr(\start.ir(0.1),
		      \end.ir(2),
		      \dur.ir(10),
		      \lmult.ir(1),
		      \ladd.ir(0)),
		  \phase.kr(0),
		  \mult.ir(1),
		  \add.ir(0)));
      }).send(s);

      // Control synth 2, line
      SynthDef(\control_line, {
	  Out.kr(\bus.ir, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(10), \mult.kr(1), \add.kr(0)));
      }).send(s);

      // Control synth 3, saw-tooth
      SynthDef(\control_saw, {
	  Out.kr(\bus.ir, Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
      }).send(s);

      ~osc_control_1_bus = Bus.control(s, 1);
      ~osc_control_2_bus = Bus.control(s, 1);
      ~line_control_1_bus = Bus.control(s, 1);
      ~line_control_2_bus = Bus.control(s, 1);
      ~saw_control_1_bus = Bus.control(s, 1);
      )
    #+end_src

    Instantiate the synths. 
    #+name: isnare_load
    #+begin_src sclang :results none
      (
      ~osc_control_1 = Synth.new(\control_osc, [
	  \bus, ~osc_control_1_bus.index,
	  \add, 7,
	  \dur, 2,
	  \start, 10,
	  \end, 0.0001,
	  \mult, 5
      ]);
      ~rising_line_1 = Synth.after(~osc_control_1, \control_line, [
	  \bus, ~line_control_1_bus.index,
	  \mult, 500,
	  \add, 50,
	  \dur, 2]);
      ~falling_line_1 = Synth.after(~osc_control_1, \control_line, [
	  \bus, ~line_control_2_bus.index,
	  \start, 200,
	  \end, 40,
	  \dur, 2]);
      ~isnare_synth = Synth.after(~saw_control_1, \isnare, [
	  \inBus1, ~saw_control_1_bus.index,
	  \inBus2, ~line_control_1_bus.index,
	  \inBus3, ~line_control_2_bus.index,
	  \freq, 10,
	  \dur, 2]);
      )
    #+end_src

    Example note with decaying hits.
    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare,
	  \dur, 1,
	  \freq, 10
      ).play;
    #+end_src

**** Example using groups
***** Synth and modulator (1)
      #+name: isnare2_def
      #+begin_src sclang :results none
	(
	// Main snare synth
	~isnare_def = SynthDef(\isnare2, { | position=0, disperse=0 |
	    var snd, env, envelope, duration;
	    envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1], [-5, 0, -5]);
	    b = 0;
	    envelope.times.do({ arg i; b = b + i; });
	    duration = \dur.ir / b;
	    env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);
	    snd = IDispersedSnare.ar(Impulse.ar(\freq.kr(1) * In.kr(\inBus3.kr)),
			position,
			disperse,
			osc_1_freq: (\osc1.kr(330) * In.kr(\inBus1.kr)) + 100,
			osc_2_freq: (\osc2.kr(180) * In.kr(\inBus2.kr)) + 120,
			triangle_freq: (\tri.kr * In.kr(\inBus2.kr) + 200),
			noise_lvl: \noise.kr(0.1)) * \gain.kr(0.5) * env;
	    Out.ar(\outBus.ir, snd);
	}).add;

	// Control synth saw-tooth
	SynthDef(\control_saw2, {
	    Out.kr(\bus.ir(0), Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
	}).send(s);

	// Busses
	~saw_control_bus_1 = Bus.control(s, 1);
	~saw_control_bus_2 = Bus.control(s, 1);
	~saw_control_bus_3 = Bus.control(s, 1);
	)
      #+end_src
      
***** Create group and add control instrument (2)
      Instantiate all control instruments. This could be integrated into the main routine above: [[*Synth and modulator (1)][Synth and modulator (1)]] thus not needed to be loaded separately.
      #+name: start_controls
      #+begin_src sclang :results none
	~group = Group.new;
	~freq_ctrl = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_1.index,
	    \freq, 1,
	    \mult, 1,
	    \add, 1], ~group, \addToHead);
	~freq_ctrl2 = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_2.index,
	    \freq, 1, 
	    \mult, 1, 
	    \add, 1], ~group, \addToHead);
	~impulse_ctrl = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_3.index, 
	    \freq, 0.5, 
	    \mult, 1, 
	    \add, 1], ~group, \addToHead);
	// ~group.group.inspect;
      #+end_src

      Function to set attributes for ~impulse_ctrl~. Use ~~group.set(\freq, 10)~ to set all ~\freq~ attributes in one go.
      #+name: load_presets
      #+begin_src sclang :results none
	~param_update = { | range1=1, freq1=0.01, range2=1, freq2=1, range3=1, freq3=1 |
	    ~impulse_ctrl.set(\mult, range1);
	    ~impulse_ctrl.set(\add, range1);
	    ~impulse_ctrl.set(\freq, 0.3);

	    ~freq_ctrl.set(\freq, freq2);
	    ~freq_ctrl.set(\mult, range2);
	    ~freq_ctrl.set(\add, range2);

	    ~freq_ctrl2.set(\freq, freq3);
	    ~freq_ctrl2.set(\mult, range3);
	    ~freq_ctrl2.set(\add, range3);
	};
	"loaded".postln;
      #+end_src
***** Presets
      Nice and noisy
      #+name: isnare_preset_1
      #+begin_src sclang :results none :noweb yes
	<<load_presets>>
	~param_update.value(10, 1, 10, 1, 11, 1);
      #+end_src

      Dark and bassy
      #+name: isnare_preset_2
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(1, 1, 0, 1, 0, 1);
      #+end_src

      Heavily modulated
      #+name: isnare_preset_3
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(4, 5, 1.1, 100, 2, 110);
      #+end_src

      Medium dark
      #+name: isnare_preset_3
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(6, 100, 0.01, 0.002, 1.3, 0.001);
      #+end_src

      Poll a bus:
      #+begin_src sclang :results none
	{Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_3.index))}.play;
      #+end_src
***** Updating values in a routine
      Nice and noisy, lots of variation.
      #+begin_src sclang :results none
	(
	~routine = Routine({
	    var delta;
	    loop {
			delta = rrand(1, 10);
			"Will wait ".post; delta.postln;
			~impulse_ctrl.set(\add, delta);
			~freq_ctrl.set(\add, delta * 0.5);
			~freq_ctrl2.set(\mult, delta);
			1.yield;
	    }
	});
	)
	~routine.play;
      #+end_src

      #+begin_src sclang :results none

~routine.stop;
      #+end_src
***** Add and play the main instrument, depends on [[*Create group and add control instrument][Create group...]] and [[*Synth and modulator][Synth and modulator]] (3)
      Play it:
      #+name: play_isnare2
      #+begin_src sclang :results none :noweb yes
	<<start_controls>>
	~isnare_synth = Synth.after(~group, \isnare2, [
	    <<bus_assignment>>
	    \freq, 10,
	    \dur, 20]);
        ~tempo_update.value(20, 0.01);
      #+end_src

***** Play with a Pbind (4)
      Now including [[*Create group and add control instrument (2)][Create group ...]] with a noweb link. This can be tangled to self contained sclang code (test.sc in this example)
      #+begin_src sclang :results none :tangle test.sc :noweb yes
	<<start_controls>>
	<<isnare_preset_2>>
	~event_str = Pbind(\instrument, \isnare2,
	    <<bus_assignment>>
	    \group, ~group,
	    \addAction, 1,
	    \position, 0,
	    \disperse, 1,
	    \noise, 0.01,
	    \freq, Pwalk(Array.series(20, 0, 1), Pwrand([-2, -1, 0, 1, 2], [0.05, 0.1, 0.15, 1, 0.1].normalizeSum, inf), Pseq([1, -1], inf), 10),
	    \dur, Pgauss(8, 4, inf)
	).play;
      #+end_src

      Move repeated stuff out for cleaner Pbind
      #+name: bus_assignment
      #+begin_src sclang :results none
	\inBus1, ~saw_control_bus_1.index,
	\inBus2, ~saw_control_bus_2.index,
	\inBus3, ~saw_control_bus_3.index,
      #+end_src

      To play from the variable.
      #+begin_src sclang :results none
	~event_str.play;
	~event_str.reset;
      #+end_src

      Free the group
      #+name: free_group
      #+begin_src sclang :results none
	~group.freeAll;
	~group.free;
      #+end_src
**** Stuff
      Plot a control bus
      #+begin_src sclang :results none
	{In.kr(~saw_control_bus_3.index)}.plot;
      #+end_src

      Inspect a control bus:
      #+begin_src sclang :results none
	{Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_2.index))}.play;
      #+end_src

      #+begin_src sclang :results none :noweb eval
	//~init_durs.value
	(     
	~player1 = Pbind(
	    \instrument, \isnare,
	    \dur, Pseq(~init_durs.value, inf),
	    \freq, Prand([0, 0, 20], inf),
	    \osc1, Pgauss(330, 10, inf),
	    \osc2, Pgauss(180, 10, inf),
	    \tri, Pgauss(110, 30, inf),
	    \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	    \noise, Pgauss(0.3, 0.1, inf)
	).play;
	)
      #+end_src

      Test the Pbind ~~player1~
      #+begin_src sclang :results none
	//     ~player1.next(());
	~player1.stop;
      #+end_src
      #+begin_src sclang :results none :noweb eval
	(     
	~player1 = Pbind(
	    \instrument, \impulseA,
	    \dur, Pseq(~init_durs.value, 1),
	    \freq, Prand([0, 0], inf)
	).play;
	) 
      #+end_src

**** Method generation and manipulation
      Test method to generate the array.
      #+begin_src sclang :results none
	~init_durs.value;
      #+end_src
   
      Create duration array
      #+name: create_durs
      #+begin_src sclang :results none
	(
	~create_durs = { |arr=0, div=1, elem=4|
	    var ldiv = 1/div;
	    var lelem = elem * div;
	    arr ++ Array.fill(lelem, {ldiv;});
	}
	)
      #+end_src
   
      Load create_durs first (if not loaded silently through the fake variable x)
      #+name: init_durs
      #+begin_src sclang :results none :noweb yes
	(
	~init_durs = {
	    (
		~times = Array.new();
		for(1, 3, {arg i; ~times = ~create_durs.value(~times, (2**i), 4);});
		~times.postln;
	    )
	}
	)
      #+end_src

      Alternative function for creating an array of durations.
      #+name: durations_array
      #+begin_src sclang
	~durations = {
	    var durs = Array.new(64);
	    a = (1!4);
	    b = (0.5!8);
	    c = (0.25!16);
	    d = (0.125!32);
	    durs = a ++ b;
	    durs = durs ++ c;
	    durs = durs ++ d;
	};
      #+end_src

*** snare 4 filtered
    Synth that is driven by an Impulse pulse generator.
    #+name: isnare_filter_def
    #+begin_src sclang :results none
      (
      ~controlBus_1 = Bus.control(s, 1);
      SynthDef(\isnare_filter, { | outBus=0, freq=0, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16 |
	  var snd;
	  var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
	  var modulator = SinOsc.kr([1!16],[0.1!16]);
	  var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
	  par = par * modulator;
	  snd = IFilteredSnare.ar(Impulse.ar(freq),
	      band_1: b1, band_2: b2, band_3: b3,
	      band_4: b4, band_5: b5, band_6: b6,
	      band_7: b7, band_8: b8, band_9: b9,
	      band10: b10, band11: b11, band12: b12,
	      band13: b13, band14: b14, band15: b15,
	      band16: b16,  osc_1_freq: osc1, osc_2_freq: osc2,
	      triangle_freq: tri) * gain * env;
	  Out.ar(outBus, snd);
      }).add;

      SynthDef(\control_synth, { | bus |
	  Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
      }).send(s);
      )
    #+end_src

    #+begin_src shell :results none :noweb yes
      echo <<record_me()>>
    #+end_src
    #+begin_src shell :results none :noweb yes
      echo <<stop_record()>>

    #+end_src
    #+begin_src shell :noweb yes
      <<rename_file("isnare_filter_routine_b.wav")>>
    #+end_src

    SynthDef for a modulating snare drum synth. Parameters are:
    - ~freq~: The frequency of the impulse playing the snare.
    - ~gain~: General gain (0-1)
    - ~osc1/2~: The frequecy of the two osccilators in the synth.
    - ~tri~: The triangle wave frequecy
    - ~noise~: The noise level (0-1)
    - ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
    - ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
    - ~dur~: The duration of the note.
    - ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
    - ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
    #+name: isnare_filter_mod
    #+begin_src sclang :results none
      (
      SynthDef(\isnare_filter_mod, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, del, del_mod=0, dur, mod_freq_stretch |
	  var snd, modulator_pf;
	  var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
	  var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
	  var mod_f = Array.series(16, 1, mod_freq_stretch);
	  var mod_p = Array.series(16, 0, 0.4);
	  var modulator_f = SinOsc.kr(mod_f, mod_p, add: 0);
	  var unused = Array.series(16, 0.1, 0.05);
	  var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
	  modulator_pf = Select.kr(freq_mod + 1, [
		  (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
	      freq, 
		  (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
	  par = par * modulator_f;
	  snd = IFilteredSnare.ar(Impulse.ar(modulator_pf),
	      band_1: par[0], band_2: par[1], band_3: par[2],
	      band_4: par[3], band_5: par[4], band_6: par[5],
	      band_7: par[6], band_8: par[7], band_9: par[8],
	      band10: par[9], band11: par[10], band12: par[11],
	      band13: par[12], band14: par[13], band15: par[14],
	      band16: par[15], delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
	      triangle_freq: tri) * gain * env;
	  Out.ar(out, snd);
      }).add;
      )
    #+end_src

    #+begin_src sclang :results none
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\freq, 14, \dur, 14, \osc1, 200, \osc2, 330, \tri, 340] );
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\freq, 10, \freq_mod, 0, \dur, 12, \osc1, 120, \osc2, 235, \tri, 140, \del_mod, 0.5] );
      s.meter;
    #+end_src

    #+name: isnare_filter_routine
    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare_filter_mod,
	  \dur, 5,
	  \freq, Pgauss(8, 3, inf),
	  \freq_mod, Prand([0,1], inf),
	  \del_mod, Pgauss(0.5, 0.5, inf),
	  \b1, -50,
	  \b2, -50,
	  \b3, -50,
	  \b4, -50,
	  \b5, -50,
	  \b6, -50,
	  \b7, -50,
	  \b8, -50,
	  \b9, -50,
	  \b10, -50,
	  \b11, -50,
	  \b12, -50,
	  \b13, -50,
	  \b14, -50,
	  \b15, -50,
	  \b16, -50,
	  \osc1, Pgauss(230, 50, inf),
	  \osc2, Pgauss(180, 50, inf),
	  \tri, Pgauss(110, 30, inf),
	  \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	  \noise, Pgauss(0.0, 0.1, inf),
	  \mod_freq_stretch, Prand([0.1, 0.3, 0.5], inf)
      ).play;
    #+end_src

    Example of spatialization with filtering, no delay.
    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare_filter_mod,
	  \del_mod, 0,
	  \freq_mod, Prand([-1, 0, 1], inf),
	  \dur, 2,
	  \freq, Pgauss(10, 8, inf),
	  \b1, Pgauss(-20, 20, inf),
	  \b2, Pgauss(-20, 20, inf),
	  \b3, Pgauss(-20, 20, inf),
	  \b4, Pgauss(-20, 20, inf),
	  \b5, Pgauss(-20, 20, inf),
	  \b6, Pgauss(-20, 20, inf),
	  \b7, Pgauss(-20, 20, inf),
	  \b8, Pgauss(-20, 20, inf),
	  \b9, Pgauss(-20, 20, inf),
	  \b10, Pgauss(-20, 20, inf),
	  \b11, Pgauss(-20, 20, inf),
	  \b12, Pgauss(-20, 20, inf),
	  \b13, Pgauss(-20, 20, inf),
	  \b14, Pgauss(-20, 20, inf),
	  \b15, Pgauss(-20, 20, inf),
	  \b16, Pgauss(-20, 20, inf)
      ).play;
    #+end_src

    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare_filter_mod,
	  \del_mod, 0,
	  \freq_mod, Prand([0, 0], inf),
	  \dur, 0.1,
	  \freq, 10,
	\b1, Pseq([-0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, ], inf),
	\b2, Pseq([-4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, ], inf),
	\b3, Pseq([-8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, ], inf),
	\b4, Pseq([-12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, ], inf),
	\b5, Pseq([-16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, ], inf),
	\b6, Pseq([-21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, ], inf),
	\b7, Pseq([-25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, ], inf),
	\b8, Pseq([-29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, ], inf),
	\b9, Pseq([-33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, ], inf),
	\b10, Pseq([-37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, ], inf),
	\b11, Pseq([-42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, ], inf),
	\b12, Pseq([-46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, ], inf),
	\b13, Pseq([-50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, ], inf),
	\b14, Pseq([-54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, ], inf),
	\b15, Pseq([-58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, ], inf),
	\b16, Pseq([-63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, ], inf),
      ).play;
    #+end_src

    Controlling the filters
    #+begin_src sclang :results none
      (
      f = { |settings=0|
	  settings[1].postln;
      }
      )
    #+end_src

    #+begin_src sclang :results none :noweb eval
      //~init_durs.value
      (     
      ~player1 = Pbind(
	  \instrument, \isnare,
	  \dur, Pseq(~init_durs.value, inf),
	  \freq, Prand([0, 0, 20], inf),
	  \osc1, Pgauss(330, 10, inf),
	  \osc2, Pgauss(180, 10, inf),
	  \tri, Pgauss(110, 30, inf),
	  \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	  \noise, Pgauss(0.3, 0.1, inf)
      ).play;
      )
    #+end_src

    Stop playback
    #+begin_src sclang :results none
      ~player1.stop;
    #+end_src
*** bass snare
**** synthdef
     #+name: bsnare
     #+begin_src sclang :results none
       (
       ~bass_snare = SynthDef(\bsnare, { | freq=1, mod_freq=1 |
	   var snd;
	   snd = BassSnare.ar(Impulse.ar(freq),
	       osc_1_freq: 50,
	       osc_2_freq: 55,
	       triangle_freq: 45,
	       modulation_freq: mod_freq,
	       noise_sustain: 0.2,
	       noise_vol: 0.05,
	       noise_rel: 0.01,
	       noise_vol: 0.0);
	   Out.ar(0, snd);
       }).add
       )
     #+end_src

     #+begin_src sclang :results none
       ~bsnare = Synth.new("bsnare", [\freq, 2, \mod_freq, 5]);
     #+end_src
**** pbind for bsnare
     #+begin_src sclang :results none
       (
       ~bsnare_player = Pbind(
	   \instrument, \bsnare,
	   \dur, 0.5,
	   \freq, Pwhite(1, 4, inf),
	   \mod_freq, Prand([0, 1, 3, 5, 0], inf);
       ).play;
       )
     #+end_src
** test tone
   #+begin_src sclang :results none
     p = { Out.ar(12, SinOsc.ar(440, 0, 0.1)) }.play
   #+end_src
   #+begin_src sclang :results none
     (instrument: \snares, freq: 400).play;
   #+end_src

** pbind for accelerando
   This is the pbind for the acc defined here: [[*accelerando, fixed tempo][accelerando, fixed tempo]]
   #+begin_src sclang :results none
     (
     var seq = { |length=4|
	 { |x=0| x+1; if(x==0, {1.0}, {0.1})} ! length;
     };

     ~accent = Pbind(
	 \instrument, \snare,
	 \gain, Pdefn(\accents),
	 \dur, Pdefn(\duration)
     );
     Pdefn(\accents, Pseq(seq.value(4), 1));
     Pdefn(\duration, 1);
     )
   #+end_src
** accelerando, fixed tempo
   #+begin_src sclang :results none
     (
     var multiplier = 1.1; //the multiplier, lower than one for deaccelerando
     var seq = { |length=4|
	 { |x=0| x+1; if(x==0, {1.0}, {0.1})} ! length;
     };

     ~tClock = TempoClock(1); //start time is 1
     ~crntBeatsPerBar = 2;
     ~accent.play(quant: 0, clock: ~tClock);
     fork {
	 loop {
	     var barDur = 4; // Duration in seconds
	     var beatsPerBar = ~crntBeatsPerBar;
	     ~tClock.tempo = ~tClock.tempo * multiplier;
	     "Tempo:".postln;
	     ~tClock.tempo.postln;
	     if((~tClock.beatDur*(beatsPerBar+1)) < barDur,
		 {
		     var beatsToAdd = 1;
		     "Length of bar + 1 beat".postln;
		     (~tClock.beatDur*(beatsPerBar+1)).postln;
		     (
			 i = 1;
			 while( {(~tClock.beatDur*(beatsPerBar+i)) < barDur }, {i = i+1; beatsToAdd = i});
		     );
		     beatsToAdd.postln;
		     ~crntBeatsPerBar = beatsPerBar + beatsToAdd;
		     Pdefn(\accents, Pseq(seq.value(~crntBeatsPerBar), 1))
		 },
		 {
		     "Length of bar".postln;
		     (~tClock.beatDur*beatsPerBar).postln;
		     ((~tClock.beatDur*beatsPerBar)/~tClock.beatDur).postln
		 });
	     (~tClock.beatDur*~crntBeatsPerBar).wait;
	     ~accent.play(quant: 0, clock: ~tClock);
	 }
     };
     )
   #+end_src
** poly rhythm
   #+begin_src sclang :results none
     (
     ~clock = TempoClock(2);
     ~denom = Pbind(
	 \instrument, \snare,
	 \dur, 2,
	 \freq, 400
     );
     ~nom = Pbind(
	 \instrument, \snare,
	 \dur, 3,
	 \freq, 400
     );
     ~poly = Ppar([~nom, ~denom]).play(quant: 0, clock: ~clock);
     )
   #+end_src
** osc
*** set netaddress to 'b'
    #+name: set_netaddress
    #+begin_src sclang :results none
      b = NetAddr.new("127.0.0.1", 5510);
    #+end_src
*** routine to play 10 hits
    #+begin_src sclang :results none :noweb yes
      <<set_netaddress()>>
      // the value can also be a stream or a function
      (
      r = Routine {
	  10.do( { 
	      b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	      0.01.wait;
	      b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	      0.1.wait;
	  });
      }.play;
      );
    #+end_src
*** task in loop
    #+begin_src sclang :results none
      b = NetAddr.new("127.0.0.1", 5510);
      t = Task({ { 
	  b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	  0.01.wait;
	  b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	  1.wait;
      }.loop });
      t.start;
    #+end_src
    #+begin_src sclang :results none
      t.stop;
    #+end_src
*** pbind for osc
    Sending OSC messages from a Pbind.
    #+begin_src sclang :results none
      (
      ~play = Pbind(
	  \dur, 1,
	  \odur, Pfunc {|ev| b.sendMsg("/o_dispersed_snare/impulse/play", 1)},
	  \sdur, Pfunc {|ev| b.sendMsg("//o_dispersed_snare/impulse/play", 0)}
      ));

      ~play.play;
    #+end_src
** definition of ~play
   This is made to deal with the faust 'gate' not resetting itself.
   Set the netaddress and register the routine.
   #+name: set_play
   #+begin_src sclang :results none
     (
     ~play = {
	 1.do{
	     b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	     0.01.wait;
	     b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	 }
     }
     )
   #+end_src
   Play the routine above:
   #+begin_src sclang :results none
     ~play.fork
   #+end_src
   #+name: set_play_dep
   #+begin_src shell :results none :noweb yes
     <<set_netaddress()>>
     <<set_play()>>
   #+end_src
** play routine 1
   Depends on [[*deal with faust 'gate'][deal with faust 'gate']]
   #+begin_src sclang :results none
     (
     r = Routine {
	 0.5.idle(2);
	 0.25.idle(2);
	 0.125.idle(2);
	 0.0625.idle(2);
     };
     fork {
	 loop {
	     var rest = r.value;
	     rest.postln;
	     ~play.fork;
	     rest.wait;
	 }
     }
     );
   #+end_src
** play routine 2
   Parameters are:
   1. a scaling factor (default to one)
   2. the number of notes to play.
   Depends on the definition of ~~play~      
   #+begin_src sclang :results none :noweb yes
     <<set_play()>>
     <<p_random_rhythm_rout()>>
     <<p_random_rhythm()>>
   #+end_src
   #+name: p_random_rhythm_rout
   #+begin_src sclang :results none :noweb yes
     (
     l = Routine { arg in=1, reps=10;
	 var length = 1;
	 p = Prand([0.5, 0.25, 0.125, 1], inf);
	 q = p.asStream;
	 50.do { |i=0|
	     q.next.postln;
	     length = q.next * in;
	     b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [200, 300, 400].choose);
	     b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [210, 320, 440].choose);
	     ~play.fork;
	     q.next.wait;
	 }
     }
     )
   #+end_src
   #+name: p_random_rhythm 
   #+begin_src sclang :results none
     l.play.value(1, 100);
   #+end_src
** play routine 3
   #+begin_src sclang :results none
     (
     var osc1freq = Array.fill(10, { (100.rand*2)+100 });
     ~playme = Pbind(
	 \dur, Prand([0.1, 0.15, 0.05, 0.2, 0.25, 0.3], inf),
	 \play, Pfunc({[~play.fork, ~play.fork]}),
	 \osc1f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [ 190, 174, 178, 204, 138, 218, 232, 222, 276, 158 ].choose)}),
	 \osc2f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [200, 300, 400, 500, 450, 350, 250, 150].choose)}),
	 \noise_rel, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_rel", 0.1.linrand + 0.012 )}),
	 \noise_lvl, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_lvl", 0.5.linrand + 0.012 )}),
	 \noise_attack, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_attack", 0.1.linrand )}),
     ).play;
     )
   #+end_src

** play routine 4
   #+begin_src sclang :results none
     (
     var durs = Array.new(64);
     a = (1!4);
     b = (0.5!8);
     c = (0.25!16);
     d = (0.125!32);
     durs = a ++ b;
     durs = durs ++ c;
     durs = durs ++ d;
     ~playme = Pbind(
	 \dur, Pseq(durs, inf),
	 \play, Pn(Pfunc({~play.fork}), inf)
     ).play;
     )
   #+end_src

** routine loop
   #+begin_src sclang :results none
     (
     r = Routine({
	 var delta = 0;
	 loop {
	     delta = delta + 1;
	     "Will wait ".post; delta.postln;
	     0.5.yield;
	 }
     });
     )
   #+end_src
   #+begin_src sclang :results none
     r.next;

     TempoClock.default.sched(0, r);
   #+end_src
   #+begin_src sclang :results none
     r.stop;
   #+end_src
** archive
   Synth that is driven by an Impulse pulse generator.
   Load first the two SynthDefs below and use a global variable of ~isnare for the snare synth:
   #+begin_src sclang :results none
     (
     // Here is where the bus object is created in a global variable:
     ~controlBus_1 = Bus.control(s, 1);
     SynthDef(\isnare, { | outBus=0, inBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0 |
	 var snd;
	 var trig = In.ar(~impBus.index, 1);
	 snd = IDispersedSnare.ar(trig, position, disperse, osc_1_freq: osc1, osc_2_freq: osc2, triangle_freq: tri) * gain;
	 Out.ar(outBus, snd);
     }).add;

     SynthDef(\impulseA, { | effectBus=0, freq=1 |
	 var outB;
	 // Only to automatically free each instance
	 var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
	 outB = Impulse.ar(freq);
	 Out.ar(~impBus.index, outB);
     }).add;

     SynthDef(\control_synth, { | bus |
	 Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
     }).send(s);
     )
   #+end_src

   ... and then instantiate the main synth:
   #+name: isnare_load
   #+begin_src sclang :results none
     ~sisnare = Synth.new("isnare", [\cBus, ~controlBus_1.index, \disperse, 0] );
   #+end_src

   Play one single shot:
   #+begin_src sclang :results none
     ~impulse = Synth.before(~sisnare, "impulseA", [\freq, 0]);
     ~c_synth = Synth.before(~sisnare, "control_synth", [\bus, ~controlBus_1.index]);
     //s.meter;
   #+end_src

   Set parameters
   #+begin_src sclang :results none
     ~impulse.set(\freq, 0);
     ~sisnare.set(\position, {In.kr(~controlBus_1.index)});
   #+end_src

