#+STARTUP: indent overview hidestars

* Snare snippets
** TODO Things to do
- [ ] Implement distance in panning with reverb
- [ ] Glue \nlevel to \pulse
** audio init
Query interfaces
#+begin_src sclang :results none
  ServerOptions.devices;
  s.boot;
#+end_src

Set JackRouter to be the interface on Linux
#+name: boot_jack
#+begin_src sclang :results none
  (
  o = Server.local.options; // Get the local server's options
  o.numOutputBusChannels = 64;
  o.numWireBufs = 128;
  o.memSize  = (65536 * 4);
  //     s.makeWindow;
  //  s.makeGui(p);
  s.boot;
  )
#+end_src

Query for node tree:
#+begin_src sclang :results none
  // in post window
  s.queryAllNodes(queryControls: false)
  // in a gui window
  //     s.plotTree(interval: 0.5);
#+end_src

#+begin_src sclang :results none
  s.quit;
#+end_src
** jack
*** status
#+begin_src shell
  jcon -c
#+end_src

*** startup
Load library async for these.
plain two channel interface, start asynchronous
#+begin_src shell :async
  startjack -r 48000 -c 2
#+end_src

Edirol
#+begin_src shell :async
  startjack -r 48000 -c 2 -d jp_co_roland_RDUSB00E6Dev_AudioEngine:14500000:0
#+end_src

#+begin_src shell
  startjack -l
#+end_src

*** jconvolver
Remember to load the library ob-async prior to testing these:

~M-x load-library ob-async~

On osx the directory should be: "~/Library/mcfx/convolver_presets/kmh_lilla_salen_29/"

To start jconvolver:
#+name: jconvolver
#+begin_src shell :async :dir /home/henrikfr/Music/spatialization/klangkupolen/gerhard/convolution_config/kmh_lilla_salen_29
  echo "Starting up jconvolver"
  jconvolver KMH_LILLA_SALEN.conf &
#+end_src

#+RESULTS: jconvolver
: 81168f108377c0471c3a01d4197f5c74

disconnect supercollider from main out$
#+begin_src shell
  for i in {1..2}; do
      jdis -d scsynth out$i system playback_$i
  done
#+end_src

connect supercollider to jconvolver
#+begin_src shell :results replace
  jcon scsyn out jcon in 16
  jcon jcon out system play 2
#+end_src

#+RESULTS:

connect only jconvolver to jack
#+begin_src shell 
  jcon jcon out sys play 2
#+end_src

*** connect multi to stereo
- Odd multi output to left out
- Even to right output
  #+begin_src shell
    for i in {2..16}; do
        if ((i % 2 == 0)); then
            jcon scsynth out$i sys playback_2 1;
        else 
            jcon scsynth out$i sys playback_1 1;
        fi
    done
  #+end_src

  specific version of the above.
  #+begin_src shell :results replace
    for i in 1 3 5 7 9 11 13 15; do 
        echo $i
        jcon scsynth out$i sys playback_1 1; 
    done
    for i in 2 4 6 8 10 12 14 16; do 
        echo $i
        jcon scsynth out$i sys playback_2 1; 
    done
  #+end_src

  Connect scsynth to jconvolver 
  #+begin_src shell :results replace
    for i in {1..16}; do
        echo $i
        jcon scsynth out$i jcon in_$i
    done
  #+end_src

  Disconnect scsynth from jconvolver 
  #+begin_src shell :results replace
    for i in {1..16}; do
        echo $i
        jdis -d scsynth out$i jcon in_$i
    done
    jdis -d scsynth out1 jcon in_1
  #+end_src

  Disconnect scsynth from jconvolver 
  #+begin_src shell :results replace
    for i in {1..16}; do
        jdis -d scsynth "out$i" jcon "in_$i";
    done
  #+end_src

  disconnect it
  #+begin_src shell :results replace
    for i in 1 3 5 7 9 11 13 15; do 
        echo $i
        jdis -d scsynth out$i sys playback_1;
    done
    for i in 2 4 6 8 10 12 14 16; do 
        echo $i
        jdis -d scsynth out$i sys playback_2;
    done
  #+end_src

*** disconnect stereo
#+begin_src shell :results replace
  for i in {1..2}; do
      echo "$i"
  done
#+end_src

#+begin_src shell :results replace
  array=(1 2 8 6 10 9 5 7)
  for i in {1..8}; do
      echo "$array[$i]"
  done
#+end_src

*** jack for i_dispersed_snare in 1D118
#+begin_src shell :results replace
  jdis -a
  for i in 1 3 5 7 9 11 13 15; do 
      echo $i
      jcon scsynth out$i sys playback_1 1; 
  done
  for i in 2 4 6 8 10 12 14 16; do 
      echo $i
      jcon scsynth out$i sys playback_2 1; 
  done
#+end_src
*** jack for i_dispersed_snare in 1D114, 8 channels
#+begin_src shell :results replace
  declare -a outs=(1 2 3 4 5 6 7 8)
  declare -a ins=(1 2 8 6 10 9 5 7)
  for i in {0..7}; do
      ##	 echo ${outs[$i]} ${ins[i]}
      jcon scsynth out${outs[$i]} sys playback_${ins[i]}
  done
#+end_src
*** jack for lilla salen
#+begin_src shell :results replace
  for i in {1..16}; do
      jcon scsynth out$i sys playback_$i
  done
#+end_src
    
** recorder
#+property: header-args:shell :var dir="/Users/henrik_frisk/Music/pieces/snares/audio/"

#+name: record_me
#+begin_src sclang :results none
  s.prepareForRecord("~/Music/single.wav", numChannels: 16);
  s.record;
#+end_src
#+name: rename_file
#+begin_src shell :var fname="isnare_filter_routine.wav"
  file="/Users/henrik_frisk/Music/single.wav"
  mv "$file" "$dir$fname"
  echo "Moved $file to $dir and renamed it $fname"
#+end_src

#+begin_src sclang :results none
  s.pauseRecording;
#+end_src
   
#+name: stop_record
#+begin_src sclang :results none
  s.stopRecording;
#+end_src

#+name: print_files
#+begin_src shell
  ls "$dir"
#+end_src

** play routines
Routine recorded on July 24
#+begin_src shell :noweb yes :results none
  echo "<<isnare_filter_mod()>>"
  echo "<<isnare_filter_routine()>>"
#+end_src
** test tone
#+name: ssingle
#+begin_src sclang :results none
  {Out.ar(0, SinOsc.ar(440, 0, 0.1))}.play;
  s.meter;
#+end_src

GUI
#+begin_src sclang :results none
  (
  SynthDef(\pluck, { |out, freq=55|
    Out.ar(out,
          Pluck.ar(WhiteNoise.ar(0.06),
            EnvGen.kr(Env.perc(0,4), 1.0, doneAction: Done.freeSelf),
            freq.reciprocal,
            freq.reciprocal,
            10,
            coef:0.1)
    );
  }).add;

  w = Window.new("Hold arrow keys to trigger sound",
    Rect(300, Window.screenBounds.height - 300, 400, 100)).front;
  a = Slider(w, Rect(50, 20, 300, 40)).value_(0.5).step_(0.05).focus
  .action_({
    // trigger a synth with varying frequencies
    Synth(\pluck, [\freq, 55 + (1100 * a.value)]);
    w.view.background_(Gradient(Color.rand,Color.rand));
  })
  )
#+end_src
** snare synths
*** snare 1 (breakBeat)
**** synthdef
Simple instance of a snare synth played by an impulse.

This may be used for polyrhythmic snare using [[generic_snare][generic_snare]] below.

Used by a variety of snippets:
- [[*pbind for accelerando][pbind for accelerando]]
#+name: original_snare
#+begin_src sclang :results none
  ~snare_simple = SynthDef(\snare, {
    var snd;
    var env = Env([0, 1, 0], [0.0001, \length.ir(0.5)], \sine);
    var imp = Impulse.ar(\impf.kr(1), 0.0, 0.5, 0);
    var frq1=\freq.kr(300), frq2=frq1-100;
    snd = OGenericSnarefs.ar(imp, 0.00001, 0.001, \noiselvl.kr(0.1), \nrel.ir(0.1), frq1, frq2, \rel.ir(0.1), \trifrq.kr(111)) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(\out.ir(0), snd*\gain.ir(1));
  }).add;
#+end_src
  
#+name: break_snare
#+begin_src sclang :results none
  ~snare_simple = SynthDef(\breakSnare, {
    var snd;
    var env = Env([0, 1, 0], [0.000001, \length.ir(0.5)], \sine);
    var imp = Impulse.ar(\impf.kr(1), 0.0, 0.5, 0);
    var frq1=\freq.kr(300);
    var frq2 = \freq2.kr(200);
    snd = OGenericSnarefs.ar(imp, 0.00001, 0.001, \noiselvl.kr(0.1), \nrel.ir(0.1), frq1, frq2, \rel.ir(0.1), \trifrq.kr(111)) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(\out.ir(0), snd*\gain.ir(1));
  }).add;
#+end_src

#+name: break_snare_b
#+begin_src sclang :results none
  ~snare_phase_b = SynthDef(\breakSnareB, {
    arg pulse_bus;
    var snd,
    /* envelope for duration of phrase */
    env = Env(levels: [0, 1, 1, 0], times: [0.01, \length.ir(0.4), \fade.ir(2)], curve: \sine),
    pulse = \impf.kr(10),
    frq1 = \freq.kr(470),
    frq2 = \freq2.kr(245),
    trifreq = \trifrq.kr(65),
    nlevel = LinLin.kr(pulse / 120, 0, 1, 0.1, 0.001) * \noiselvl.kr(0.208);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.369), \attack.ir(0.000001), \fsweep.kr(0), \nattack.kr(0.009), nlevel, \nrel.kr(0.2), frq1, frq2, \rel.kr(0.135), trifreq) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(31, snd * \gain.kr(0.5));
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add;
#+end_src

VÃ¤ldigt snygg, on hit.
#+begin_src sclang :results none
  Synth.new("snare", [\impf, 100, \noiselvl, 0]);
#+end_src

#+begin_src sclang :results none
  Synth.new(\breakSnareB, [\impf, 840, \noiselvl, 0.0, \fade, 1]);
#+end_src

***** Gesture one
Similar to the above, but with modulation of Impulse tempo
#+name: extended_snare
#+begin_src sclang :results none
  (
  ~snare_simple = SynthDef(\snare_imp_mod, { 
    var snd,
    crv = \curve.ir(0),
    lngth = \length.ir(1),
    sstrt = \speedStart.ir(1),
    send = \speedEnd.ir(1),
    frq1 = \freq.kr(300),
    frq2 = \freq2.kr(200),
    nlvl = \noiselvl.kr(0.1),
    nrel = \nrel.ir(0.1),
    rel = \rel.ir(0.1),
    trifrq = \trifrq.kr(111),
    out = \out.ir(0),
    gain = \gain.ir(1),
    envcrv = \envCurve.ir(6);
    var mod_env = Env(
          levels: [sstrt, send],
          times: [lngth],
          curve: crv,
          releaseNode: 0,
          loopNode: 1,
    );
    var env = Env(
          levels: [0, 1, 0.7, 0],
          times: [0.0001, lngth*0.8, lngth*0.2],
          curve: \squared);
    var imp = Impulse.ar(EnvGen.ar(mod_env, gate: Impulse.ar(0.001), levelScale: 1, levelBias: 0.0, timeScale: 1, doneAction: 0));
    snd = OGenericSnarefs.ar(imp, 0.000001, 0.0001, nlvl, nrel, frq1, frq2, rel, trifrq) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(out, snd*gain);
  }).add;
  )
#+end_src

#+begin_src sclang :results none

  Env(
    levels: [0, 1, 0.9, 0],
    times: [1, 10-5, 10-4],
    curve: \squared,
  ).plot;

#+end_src
#+name: acc_long_640
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 640, \speedEnd, 640 , \freq1, 200, \freq2, 210, \trifrq, 100, \noiselvl, 0.001, \nrel, 0.01, \lngth, 0.1, \length, 15, \rel, 0.005, \out, [0,1], \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_long_400
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 400, \speedEnd, 400 , \freq1, 200, \freq2, 210, \trifrq, 100, \noiselvl, 0.001, \nrel, 0.01, \lngth, 0.1, \length, 15, \rel, 0.005, \out, 1, \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_snare
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 1, \speedEnd, 25, \freq, 400, \trifrq, 100, \length, 5, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_deep
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 2,  \speedStart, 2, \speedEnd, 40, \freq, 200, \trifrq, 420, \length, 1, \out, 1, \gain, 0.2, \envCurve, 40] );
#+end_src

#+name: snare_single
#+begin_src sclang :results none :noweb yes
  ~test = Synth.new("snare_imp_mod", [\freq, 400, \freq2, 300, \trifrq, 80, \length, 5, \out, 0, \gain, 1.3, \envCurve, 10, \noiselvl, 0.01, \nrel, 0.04, \curve, 4,  \speedStart, 0.01, \speedEnd, 0.01] );
#+end_src

#+name: snare_bass
#+begin_src sclang :results none :noweb yes
  ~test2 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 100, \speedEnd, 100, \freq, 80, \freq2, 90, \trifrq, 60, \noiselvl, 0.001, \length, 20, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+name: snare_bass
#+begin_src sclang :results none :noweb yes
  ~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 60, \speedEnd, 70, \freq, 100, \freq2, 110, \trifrq, 85, \noiselvl, 0.01, \length, 10, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+begin_src sclang :results none
  ~play_snares = { |start, end, frq, time, out|
    var frq2, tri;
    frq2 = frq * 2;
    tri = frq / 2;
    ~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, start, \speedEnd, end, \freq, frq, \freq2, frq2, \trifrq, tri, \noiselvl, 0.01, \length, time, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10, \out, out] );
  }; 
  ~play_snares.value(9, 90, 100, 30, 0);
  ~play_snares.value(8, 80, 180, 30, 1);
#+end_src

#+begin_src sclang :results none
  ~test3.set(\freq, 100);
#+end_src

#+begin_src sclang :results none :noweb yes
  {<<acc_snare>>}.defer(0);
  {<<acc_deep>>}.defer(3.95);
  {<<snare_single>>}.defer(4.88);
#+end_src

***** Stuff
Example routine, as a looping gesture
#+name: looping_gesture
#+begin_src sclang :results none :tangle testme.sc :noweb yes
  ~intro_gesture = Routine ({
    var delta;
    loop {
          delta = 1;
          <<acc_snare>>
          delta.yield;
    }
  });
#+end_src

Another simple routine (not good for time critical events.
#+begin_src sclang :results none :noweb yes
  { 20.do({ <<snare_single>> 0.1.wait;}) }.fork;
#+end_src
     
#+begin_src sclang :results none :noweb yes
  <<looping_gesture>>
  ~intro_gesture.play;
  //	~intro_gesture.stop;
#+end_src

#+name: dacc_snare
#+begin_src sclang :noweb yes
  <<acc_snare>>
  ~reg_snare = Synth.new("snare_imp_mod", [\envCurve, 1, \curve, -4, \speedStart, 20, \speedEnd, 1, \freq, 400, \trifrq, 100, \length, 5, \out, 1, \gain, 1, \vol, 1] );
#+end_src

A feedback snare
#+begin_src sclang :results none
  (
  ~snare_fb = SynthDef(\snarefb, { | gain=4, freq=200, vol=2, q=1, out=0 |
    var snd;
    var env = Env([0, 1, 0], [0.0001, 0.5]);
    snd = SnaresFb.ar(gain: gain, vol: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(out, snd);
  }).add;
  )
#+end_src

A dispersed snare over many channels
#+begin_src sclang :results none
  (
  ~snare_disp = SynthDef(\snaredisp, { | freq=200, q=1, out=0, pos=0, disp=1, impf=0, attack=0.0001, noiselvl=0.1, noiserel=0.1, osc1f=330, osc2f=180, trianglef=111, mainlvl=0.5, length=1 |
    var snd;
    var env = Env([0, 1, 0], [0.0001, length]);
    var imp = Impulse.ar(impf, 0.0, 0.5, 0);
    snd = ODispersedSnare.ar(imp, pos, disperse: disp, attack: attack, noise_lvl: noiselvl, noise_rel: noiserel, osc_1_freq: osc1f, osc_2_freq: osc2f, triangle_freq: trianglef);// * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(out, snd * mainlvl);
  }).add;
  )
#+end_src

A second version of the dispersed snare above
#+begin_src sclang :results none
  (
  ~snare_disp = SynthDef(\snaredisp2, { | out=0, length=2 |
    var snd;
    var env = Env([0, 1, 0], [0.0001, length]);
    var imp = Impulse.ar(10, 0.0, 0.5, 0);
    snd = ODispersedSnare.ar(imp);
    Out.ar(out, snd);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  ~snare_simple.free;
  ~snare_fb.free;
  ~snare_disp.free;
#+end_src

**** break beat

Use this to start the synth for break beats.
#+name: play_break_snare
#+begin_src sclang :results none :noweb yes
  <<break_snare>>
  ~playBreakSnare = { |start=1, bus, noise=0.0001, length=40, release=0.05|
    Synth.new("breakSnare", [\impf, start, \freq, 50, \freq2, 110, \trifrq, 50, \noiselvl, noise, \length, length, \rel, release, \nrel, 0.05, \out, bus, \gain, 1] );
  };
#+end_src

Call this function to double the impulse speed and alter the parameters of the [[snare_break][snare_break]] synth.
#+name: double_pace
#+begin_src sclang :results none
  ~doubleSpeed = { |synth, divisor=0|
    var fractions = [1.0, 1.0125, 1.024, 1.08, 1.125, 1.25, 1.2656, 1.4815, 1.5, 1.7778, 1.875, 2.0 ],
    breakpoint = 50;
    "called".postln;
    synth.get(\impf, {arg val;
          var newVal = val,
          newFreq,
          newFreq2,
          relDivisor = 0.8,	
          newNoise;
          if(newVal > 6, {
            synth.get(\noiselvl, {arg nse;
                  newNoise = nse * 0.5;
                  synth.set(\noiselvl, newNoise);
                  "New noise level is ".post;
                  newNoise.postln;		
            });
          });
          synth.get(\rel, {arg rel;
            synth.set(\rel, rel * relDivisor);
            "New release is ".post;
            (rel * relDivisor).postln;	  
          });	  
          if(newVal > breakpoint, { newFreq = newVal });
          if(newVal > (breakpoint * 2), { newFreq2 = newVal * 0.5 });
          newVal = (val*2) * fractions[divisor];
          synth.set(\impf, newVal);
          synth.set(\freq, newFreq);
          synth.set(\freq2, newFreq2);
          "New impulse frequency is ".post;
          newVal.postln;
    });
  };
#+end_src

#+begin_src sclang :results none :noweb yes
  var synthA, synthB;
  <<double_pace>>
  ~initializeAudioBusses.value();
  synthA = ~playBreakSnare.value(2, ~audioBusses[0].index);
  synthB = ~playBreakSnare.value(3, ~audioBusses[1].index);
  r = Routine({
    var delta;
    loop {
          delta = 5;
          delta.yield;
          ~doubleSpeed.value(synthA, 0);
          ~doubleSpeed.value(synthB, 0);
    }
  });
  TempoClock.default.sched(0, r);
#+end_src

#+begin_src sclang :results none
  r.stop;
#+end_src

Routine to double the speed on the snare beat.
#+begin_src sclang :results none :noweb yes
  var ratio = 81/80;
  <<play_break_snare>>
  r = Routine({
    var delta;
    loop {
          delta = 5;
          delta.yield;
          ~breakBeatA.get(\impf, {arg val; ~breakBeatA.set(\impf, (val*2)*ratio)});
          ~breakBeatA.get(\impf, {arg val; val.postln});
    }
  });
  TempoClock.default.sched(0, r);
#+end_src

**** player
Play one hit on the snare above.
#+name: reg_snare_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snare", [\freq, 400, \trifrq, 100, \length, 0.09, \out, 25, \gain, 1, \vol, 1] );
#+end_src

Play a series of hits for the duration of ~\length~.
#+name: generic_snare
#+begin_src sclang :results none
  ~snare_simple = Synth.new("snare", [\impf, 0.1, \freq, 300, \nrel, 0.05, \length, 0.1, \noiselvl, 0.002, \out, 0] );
  //       s.meter;
#+end_src

#+begin_src sclang :results none
  ~breakBeat = Pbind 
#+end_src
Exaple of speeding up hits using a ~Routine~
#+begin_src sclang :results none :noweb yes
  (
  <<generic_snare>>

  Routine({
    x=1;
    0.2.wait;
    100.do({
          ~snare_simple.set(\impf, x);
          x.postln;
          x = x + 1;
          0.1.wait
    })
  }).play;
  )
#+end_src
     
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
    \out, 0,
    \impf, 0.1,
    \freq, Pseq((150..600), 100),
    \nrel, Pseq((0.005..0.4), 100),
    \length, 0.15,
    \dur, Pseries((0.5..0.01), 10),
  ).play;
#+end_src

#+begin_src sclang :results none
  ~fb_snare = Synth.new("snarefb", [\out, 1, \gain, 2, \vol, 2] );
#+end_src

Snygga effekter genom att panorera dessa tvÃ¥ ljud med Radius och Elevation.
#+begin_src sclang :results none
  ~disp_snare1 = Synth.new("snaredisp", [\out, 1, \impf, 3000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 20] );
  ~disp_snare1 = Synth.new("snaredisp", [\out, 0, \impf, 2000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 25] );
  s.meter;
#+end_src

#+begin_src sclang :results none
  Pbind(\instrument, \snaredisp,
    \out, 0,
    \impf, 10,
    \dur, 0.5,
    \pos, 6,
  ).play
#+end_src

#+begin_src sclang :results none
  ~dist_snare = Synth.new("snaredisp", [\out, 0, \impf, 0, \pos, 0, \disp, 1, \noiserel, 0, \noiselvl, 0.01] );
#+end_src

Closer and closer.
#+begin_src sclang :results none
  ~range = [(1..10)].do({ arg item, i; [item/20]; });
  Pbind(\instrument, \snaredisp,
    \out, Pseq((31..31), 16), // This is for feeding the signal to the ambisonics engine
    \noiserel, Pseq([0.0, 0.001, 0.002, 0.003, 0.005, 0.007, 0.01, 0.02, 0.03, 0.04, 0.045, 0.050, 0.055, 0.06, 0.065, 0.07], 16),
    \nopiselvl, 0.0,
    \osc1f, Pseq((150..2000), 16),
    \osc2f, 180,
    \mainlvl, Pseq([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16], 16),
    \dur, 1
  ).play;
  //s.meter;
#+end_src
     
For testing
#+begin_src sclang :results none
  a = Array.fill(16, {arg i; i * 0.001; });
  b = Array.fill(32, { arg i; i / 32 + 0.05 }).reverse;
  Pbind(\instrument, \snaredisp,
    \out, 0,
    \noiserel, Pseq(a, 32),
    \ nopiselvl, 0.0,
    \osc1f, Pseq((150..2000), 32),
    \osc2f, Pseq((400..170), 32),
    \mainlvl, 0.5,
    \dur, Pseq(b, 32)
  ).play
#+end_src
**** pbind: fast irregular, no snare.
Very nice sounding pattern
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
    \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
    \dur, Prand([0.1, 0.2], inf),
    \q, Prand([0.001, 5, 2], inf),
    \out, Prand((0..1), inf) //([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], inf)
  ).play;
#+end_src
     

#+begin_src sclang :results none
  Pbind(\instrument, \snarefb,
    \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
    \dur, Prand([0.1, 0.2, 0.4], inf),
    \q, Prand([0.001, 5, 2], inf),
    \out, Prand( (0 .. 16), inf)
  ).play;
#+end_src

Ptpar running two Pbinds
#+begin_src sclang :results none
  a = Pbind(\instrument, \snare,
    \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
    \dur, Pseq([0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
    \q, Prand([0.001, 5, 2], inf)
  );
  b = Pbind(\instrument, \snare,
    \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
    \dur, Pseq([0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
  );
  Ptpar([0.0, a, 1, b, 2, a]).play;
#+end_src
*** snare phase (polyrhythmic harmony)
**** synthdef
Four hits per pulse. Min speed is 1/2 sec. These synths play severl hits for each impuls to allow for high frequencies. ~ISnarePhase~ in this version has an accent on every four hits, which may not be desireable in all cases. Plays until stopped.
#+name: i_snare_phase_1
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\snare_phase, {
    var snd, pulse = \pulse.kr(10);
    var frq1 = \freq.kr(300),
    frq2 = \freq2.kr(300);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111));
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add
#+end_src

~i_snare_phase_2~ differs from the above ([[i_snare_phase_1][i_snare_phase_1]]) only by the addition of an envelope over the ~\length~ of the instance. 
#+name: i_snare_phase_2
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\snare_phase_2, {
    var snd, pulse = \pulse.kr(10);
    var frq1 = \freq.kr(300),
    frq2 = \freq2.kr(300),
    env = Env.new(levels: [0, 1, 0], times: [0.2, \length.ir(0.1)], curve: \sin);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111)) * EnvGen.kr(env, timeScale: \length.ir(0.1), doneAction: Done.freeSelf);
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add
#+end_src

**** player
Simple example, of a snare with no snare.
#+name: single
#+begin_src sclang :results none :noweb yes
  <<i_snare_phase_1>>;
  ~singletest = Synth.new("snare_phase", [\pulse, 1, \length, 1, \freq, 290, \nlevel, 0, \out, 0, \gain, 0.9]);
#+end_src

Make a series of notes up the harmonic series. Works very nicely. The variables for the function are:
1. ~mode~: which mode to run the function in (0: harmonic rising, 1: inharmonic falling, 2: experimental
2. ~fund~: fundamental frequency for the modes.
3. ~reps~: how many rrepetitions of the function.
4. ~delta~: delta time bwetween the notes.
#+name: play_snare_phase
#+begin_src sclang :results none :noweb yes
  <<i_snare_phase_2>>;
  ~play_chord = { |mode, fund, reps, delta, out|
    var freq, len, osc1, osc2, tri, nlvl, gain;

    switch(mode,
          /* mode == 0 */	
          0, 	{
            /* Starting from frequency x going down */
            freq = Array.fill(reps, {arg i; fund * (i + 1)});
            osc1 = Array.fill(reps, {arg i; 200 * (i + 1)});
            osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
            tri =  Array.fill(reps, {arg i; 410 * (i + 1)});

          },
          /* mode == 1 */	
          1,  {
            /* Starting from the fundamental, going up */
            //                          freq = Array.fill(reps, {arg i; fund - (100 * i)});
            freq = Array.fill(reps, {arg i; fund /  (1 + i)});	
            osc1 = Array.fill(reps, {arg i; 250 * (i + 1)});
            osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
            tri =  Array.fill(reps, {arg i; 410 * (i + 1)});

          },
          2,  {
            /* Inharmonic */
            freq = Array.fill(reps, {arg i; fund * ((i * 1) + 1)});
            osc1 = Array.fill(reps, {arg i; 200 * (i + 1)});
            osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
            tri =  Array.fill(reps, {arg i; 310 * (i + 1)});
          });
    len = Array.exprand(reps, 8, 12);
    gain = Array.fill(reps, {arg i; 1 / (i + 1) * 0.8;});
    nlvl = Array.rand(reps, 0, 0);

    fork {
          [\pulse, freq, \length, len, \freq, osc1, \freq2, osc2, \trifreq, tri, \nlevel, nlvl, \gain, gain, \out, out].flop.do { |args|
            args.postln;
            Synth("snare_phase_2", args);
            delta.wait;
          }
    };
  };
#+end_src

Play a chord according to [[play_snare_phase][play_snare_phase]] with the synth [[i_snare_phase_2][i_snare_phase_2]].
Very nice sound and texture. Useful.
#+begin_src sclang :results none
  ~play_chord.value(1, 9, 2, 2, 0);
  ~play_chord.value(1, 8, 2, 2, 1);
  ~play_chord.value(1, 5, 2, 2, 1);
#+end_src

***** Polyrhythmic functions (works)
Polyrhythmic function with two synths (in the array ~synths~) at different speeds. 
#+name: poly_rythm
#+begin_src sclang :results none
  ~polyr = { | nom, denom, f, osc1, osc2 |
    var f1, f2, phase1, phase2, synths;
    postf("freq is %\n", f);
    f1 = nom * f;
    "f1 is ".post; f1.postln;
    f2 = denom * f;
    "f2 is ".post; f2.postln;
    synths = [
          Synth.new("snare_phase", [\pulse, f1, \freq, 100, \freq2, 130, \nlevel, 0.3, \nrel, 0.1, \gain, 0.4, \out, 1] ),
          Synth.new("snare_phase", [\pulse, f2, \freq, 50, \freq2, 230, \nlevel, 0.3, \nrel, 0.1, \gain, 0.4, \out, 0] )
    ];
  };
#+end_src

Start the polyrhythmic structure above
#+begin_src sclang :results none
  k = ~polyr.value(3, 5, 1);
#+end_src

Adjust values in the polyrhythmic structure above.
#+begin_src sclang :results none
  k[1].set(\nlevel, 0.2);
  //k[0].set(\pulse, 1, \nlevel, 0.0, \freq, 400, \freq2, 200, \trifreq, 300);
#+end_src

Function setting the values relative to the pulse. This relies on ~poly_rhythm~ above that delivers the synths.
#+name: phased_set_values
#+begin_src sclang :results none :noweb yes
  <<poly_rythm>>
  ~phased_set_values = { |frequency=10, nom, denom, synth|
    var freq = frequency, nlevel, f1, f2, t3, normalizedf, maxf = 2000;
    normalizedf = freq / maxf;
    c = ControlSpec(1, 2000, \lin, 0.0001);
    freq = c.unmap(freq);
    //d = [0.05, 0.00001, -40].asSpec;
    d = ControlSpec(0.005, 0.00001, -40, 0.00001);
    nlevel = d.map(freq);
    f1 = freq * 2 + 50;
    f2 = freq * 3 + 50;
    t3 = freq * 4 + 50;
    synth[0].set(\pulse, frequency*nom, \nlevel, nlevel, \freq, f1*nom, \freq2, f2*nom, \trifreq, 300);
    synth[1].set(\pulse, frequency*denom, \nlevel, nlevel, \freq, f1*denom, \freq2, f2*denom, \trifreq, 300);
  };
  ~polyr_synth = ~polyr.value(1, 2, 3);
  ~phased_set_values.value(1, 2,  3, k);
#+end_src

Change values in the synth
#+begin_src sclang :results none
  ~phased_set_values.value(1, 5, 3, k);
  ~phased_set_values.value(2, 5, 4, l);
#+end_src

Loop to do a accelerando. Uncomment the first two lines to also load the other patches.
#+begin_src sclang :results none :noweb yes
  <<phased_set_values>>
  (
  t = Task({
    (1..500).do({ |pulse|
          ~phased_set_values.value(pulse*1, 3, 4, ~polyr_synth);
          ~polyr_synth[0].set(\nlevel, 1/pulse);
          ~polyr_synth[1].set(\nlevel, 1/pulse);
          ~polyr_synth[0].set(\freq, 100 + (pulse / 100));
          ~polyr_synth[1].set(\freq, 100 - (pulse / 250));
          if(pulse % 10 == 1,
            { "Current nlevel: ".post;		
                  (1/pulse).postln;
            }, { });
          0.2.wait;
    });
  }).play;
  )
#+end_src

GUI for controling the speed.
#+begin_src sclang :results none
  (
  var mapped;
  w = Window.new.front;
  c = ControlSpec(1, 1000, \linear, 0.01); // min, max, mapping, step
  b = NumberBox(w, Rect(20, 20, 150, 20));
  d = NumberBox(w, Rect(20, 120, 150, 20));

  a = Slider(w, Rect(20, 60, 150, 20)).action_({
    mapped = c.map(a.value);
    b.value_(mapped);
    k[0].set(\pulse, mapped);
  });

  e = Slider(w, Rect(20, 160, 150, 20)).action_({
    mapped = c.map(e.value);
    d.value_(mapped);
    k[1].set(\pulse, mapped);
  });
  a.action.value;
  e.action.value;
  )     
#+end_src

Polyrhythmic object with two synths at different speeds. (Doesn't work)
#+name: poly_rhythm_ii
#+begin_src sclang :results none
  PolyRhythm = {
    var f=1, f1, f2, nom=1, denom=1, phase_1, phase_2;
    f1 = nom * f;
    f2 = denom * f;
    phase_1 = Synth.new("snare_phase", [\pulse, f1, \freq, 100, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 0] );
    phase_2 = Synth.new("snare_phase", [\pulse, f2, \freq, 50, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 1] );
  };
  a = PolyRhythm.new;
  a.f_(2);
  a.nom_(2);
  a.denom_(3);
#+end_src

*** snare dispersed
This is very nice with a few patterns to it at the bottom under control signals
**** synth
define the synth
#+name: snare_disp_4
#+begin_src sclang :results none
  ~disp_snare = SynthDef(\snaredisp4, { | dur=60, out=33, pos=0, disp=0, pulse=2000, att=0.00001, n_attack=0.01, n_level=0.2, n_rel=0.1, osc1_f=100, osc2_f=130, release=0.01, tri_f=300 |
    var snd, env;
    env = Env.new(levels: [0, 1, 1, 0], times: [0.01, dur, 0.01]);
    snd = IDispersedSnare.ar(pos, disp, pulse, att, n_attack, n_level, n_rel, osc1_f, osc2_f, release, tri_f) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(out, snd);
  }).play(s);
  //s.plotTree;
#+end_src
     
define the busses
#+name: snare_disp_4_bus
#+begin_src sclang :results none
  ~busses = Array.new(4);
  ~duration = 20;

  b = Bus.control(s, 1);
  ~disp_snare.map(\pos, b);
  c = Bus.control(s, 1);
  c.set(4000);
  ~disp_snare.map(\pulse, c);
  d = Bus.control(s, 1);
  d.set(0.1);
  ~disp_snare.map(\n_rel, d);
  e = Bus.control(s, 1);
  e.set(0.2);
  ~disp_snare.map(\n_level, e);

  //      {Out.kr(b, Line.kr(0, 29, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(4000, 200, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.1, 0.005, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.2, 0.001, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
#+end_src

#+begin_src sclang :results none
  s.makeGui(p);
#+end_src
**** player
#+name: play_disp_snare_4
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snaredisp4", [\dur, 30, \out, 0, \pos, 2, \disp, 0, \pulse, 500, \gain, 20, \vol, 5] );
  //       ~reg_snare.free;
#+end_src

**** control signals
Various tasks that alter the parameters of the synth
This takes the positions parameter
#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~pos_task = Task({
    loop {
          (0..28).do({ |position|
            position.postln;
            ~reg_snare.set(\pos, position);
            0.5.wait;
          });
    }
  }).play;
#+end_src

Slowly increaseing disperse parameter
#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~disp_task = Task({
    loop {
          (0..100).do({ |disperse|
            var disp;
            disp = disperse/100;
            ~reg_snare.set(\disp, disp);
            0.1.wait;
          });
    }
  }).play;
#+end_src

#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~pulse_task = Task({
    loop {
          (5000..100).do({ |pulse_time|
            var pulse, disp;
            pulse = pulse_time;
            disp = 1 / pulse_time;
            ~reg_snare.set(\pulse, pulse);
            ~reg_snare.set(\disp, pulse);	
            0.01.wait;
          });
    }
  }).play;
#+end_src

Control the speed via a slider.
#+begin_src sclang :results none
  (
  w = Window.new.front;
  b = NumberBox(w, Rect(20, 20, 150, 20));
  a = Slider(w, Rect(20, 60, 150, 20)).action_({
    b.value_(a.value);
    ~reg_snare.set(\pos, (a.value * 10));
  });
  a.action.value;
  )     
#+end_src

*** snare 2 (osx)
Simple instance of a snare synth with more noise
#+begin_src sclang :results none
  (
  SynthDef(\snares, { | gain=2, freq=200, vol=2, q=10 |
    var snd;
    var env = Env([0, 1, 0], [0.0001, 0.5]);
    snd = Snares.ar(attack: 0.00001, freq: freq, gain: gain, q: q, rel: 0.01, vol_0: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(0, snd);
  }).add;
  )
#+end_src
**** player
Play one hit on the snare above.
#+name: snares_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snares", [\freq, 100] );
#+end_src
*** snare 3 (isnare2)
**** Example without groups
Synth that is driven by an Impulse pulse generator.
Load first the SynthDefs below.
#+name: isnare_def
#+begin_src sclang :results none
  (
  // Main snare synth
  SynthDef(\isnare, { | inBus1=0, inBus2=1, inBus3=2, inBus4=3, outBus=0, freq=2, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, dur=1 |
    var snd;
    var env;
    var envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]);
    b = 0;
    envelope.times.do({ arg i; b = b + i; });
    c = dur / b;
    env = EnvGen.kr(
          envelope,
          timeScale: c,
          doneAction: Done.freeSelf);
    snd = IDispersedSnare.ar(Impulse.ar(freq), position, disperse, osc_1_freq: In.kr(inBus2), osc_2_freq: In.kr(inBus2) - 50, triangle_freq: In.kr(inBus3), noise_lvl: In.kr(inBus4)) * gain * env;
    Out.ar(outBus, snd);
  }).add;

  // Control synth 1, modulated oscillator
  SynthDef(\control_osc, {
    Out.kr(\bus.ir,
          SinOsc.kr(
            // modulate the frequency of the modulator
            Line.kr(\start.ir(0.1),
                  \end.ir(2),
                  \dur.ir(10),
                  \lmult.ir(1),
                  \ladd.ir(0)),
            \phase.kr(0),
            \mult.ir(1),
            \add.ir(0)));
  }).send(s);

  // Control synth 2, line
  SynthDef(\control_line, {
    Out.kr(\bus.ir, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(10), \mult.kr(1), \add.kr(0)));
  }).send(s);

  // Control synth 3, saw-tooth
  SynthDef(\control_saw, {
    Out.kr(\bus.ir, Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
  }).send(s);

  ~osc_control_1_bus = Bus.control(s, 1);
  ~osc_control_2_bus = Bus.control(s, 1);
  ~line_control_1_bus = Bus.control(s, 1);
  ~line_control_2_bus = Bus.control(s, 1);
  ~saw_control_1_bus = Bus.control(s, 1);
  )
#+end_src

Instantiate the synths. 
#+name: isnare_load
#+begin_src sclang :results none
  (
  ~osc_control_1 = Synth.new(\control_osc, [
    \bus, ~osc_control_1_bus.index,
    \add, 7,
    \dur, 2,
    \start, 10,
    \end, 0.0001,
    \mult, 5
  ]);
  ~rising_line_1 = Synth.after(~osc_control_1, \control_line, [
    \bus, ~line_control_1_bus.index,
    \mult, 500,
    \add, 50,
    \dur, 2]);
  ~falling_line_1 = Synth.after(~osc_control_1, \control_line, [
    \bus, ~line_control_2_bus.index,
    \start, 200,
    \end, 40,
    \dur, 2]);
  ~isnare_synth = Synth.after(~saw_control_1, \isnare, [
    \inBus1, ~saw_control_1_bus.index,
    \inBus2, ~line_control_1_bus.index,
    \inBus3, ~line_control_2_bus.index,
    \freq, 10,
    \dur, 2]);
  )
#+end_src

Example note with decaying hits.
#+begin_src sclang :results none
  Pbind(
    \instrument, \isnare,
    \dur, 1,
    \freq, 10
  ).play;
#+end_src

**** Example using groups
***** Synth and modulator (1)
#+name: isnare2_def
#+begin_src sclang :results none
  (
  // Main snare synth
  ~isnare_def = SynthDef(\isnare2, { | position=0, disperse=0 |
    var snd, env, envelope, duration;
    envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1], [-5, 0, -5]);
    b = 0;
    envelope.times.do({ arg i; b = b + i; });
    duration = \dur.ir / b;
    env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);
    snd = IDispersedSnare.ar(Impulse.ar(\freq.kr(1) * In.kr(\inBus3.kr)),
          position,
          disperse,
          osc_1_freq: (\osc1.kr(330) * In.kr(\inBus1.kr)) + 100,
          osc_2_freq: (\osc2.kr(180) * In.kr(\inBus2.kr)) + 120,
          triangle_freq: (\tri.kr * In.kr(\inBus3.kr) + 200),
          noise_lvl: \noise.kr(0.1)) * \gain.kr(0.5) * env;
    Out.ar(\outBus.ir, snd);
  }).add;

  // Control synth saw-tooth
  SynthDef(\control_saw2, {
    Out.kr(\bus.ir(0), Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
  }).send(s);

  // Busses
  ~saw_control_bus_1 = Bus.control(s, 1);
  ~saw_control_bus_2 = Bus.control(s, 1);
  ~saw_control_bus_3 = Bus.control(s, 1);
  )
#+end_src

One hit
#+begin_src sclang :results none
  a = Synth(\isnare2, [ \position, 0, \disperse, 0, \noise, 0.5, \dur, 0.03, \freq, 1]);
#+end_src
#+begin_src sclang :results none
  s.plotTree;
#+end_src

***** Create group and add control instrument (2)
Instantiate all control instruments. This could be integrated into the main routine above: [[*Synth and modulator (1)][Synth and modulator (1)]] thus not needed to be loaded separately.
#+name: start_controls
#+begin_src sclang :results none
  ~group = Group.new;
  ~freq_ctrl = Synth(\control_saw2, [
    \bus, ~saw_control_bus_1.index,
    \freq, 1,
    \mult, 1,
    \add, 1], ~group, \addToHead);
  ~freq_ctrl2 = Synth(\control_saw2, [
    \bus, ~saw_control_bus_2.index,
    \freq, 1, 
    \mult, 1, 
    \add, 1], ~group, \addToHead);
  ~impulse_ctrl = Synth(\control_saw2, [
    \bus, ~saw_control_bus_3.index, 
    \freq, 0.5, 
    \mult, 1, 
    \add, 1], ~group, \addToHead);
  // ~group.group.inspect;
#+end_src

Function to set attributes for ~impulse_ctrl~. Use ~~group.set(\freq, 10)~ to set all ~\freq~ attributes in one go.
#+name: load_presets
#+begin_src sclang :results none
  ~param_update = { | range1=1, freq1=0.01, range2=1, freq2=1, range3=1, freq3=1 |
    ~impulse_ctrl.set(\mult, range1);
    ~impulse_ctrl.set(\add, range1);
    ~impulse_ctrl.set(\freq, freq1);

    ~freq_ctrl.set(\freq, freq2);
    ~freq_ctrl.set(\mult, range2);
    ~freq_ctrl.set(\add, range2);

    ~freq_ctrl2.set(\freq, freq3);
    ~freq_ctrl2.set(\mult, range3);
    ~freq_ctrl2.set(\add, range3);
  };
  "loaded".postln;
#+end_src

***** Presets
Nice and noisy
#+name: isnare_preset_1
#+begin_src sclang :results none :noweb yes
  <<load_presets>>
  ~param_update.value(10, 1, 10, 1, 11, 1);
#+end_src

Dark and bassy
#+name: isnare_preset_2
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(1, 1, 0, 1, 0, 1);
#+end_src

Heavily modulated
#+name: isnare_preset_3
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(4, 5, 1.1, 100, 2, 110);
#+end_src

Medium dark
#+name: isnare_preset_3
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(6, 100, 0.01, 0.002, 1.3, 0.001);
#+end_src

Inharmonic
#+name: isnare_preset_4
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(1, 52, 1, 50, 1, 100);
#+end_src

Shady
#+name: isnare_preset_4
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(10, 23, 10, 24, 10, 200);
#+end_src

Poll a bus:
#+begin_src sclang :results none
  {Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_3.index))}.play;
#+end_src
***** Updating values in a routine
Nice and noisy, lots of variation.
#+begin_src sclang :results none
  (
  ~routine = Routine({
    var delta;
    loop {
          delta = rrand(1, 10);
          "Will wait ".post; delta.postln;
          ~impulse_ctrl.set(\add, delta);
          ~freq_ctrl.set(\add, delta * 0.5);
          ~freq_ctrl2.set(\mult, delta);
          1.yield;
    }
  });
  ~routine.play;
  )
#+end_src

#+begin_src sclang :results none
  ~routine.stop;
#+end_src
***** Add and play the main instrument, depends on [[*Create group and add control instrument][Create group...]] and [[*Synth and modulator][Synth and modulator]] (3)
Play it:
#+name: play_isnare2
#+begin_src sclang :results none :noweb yes
  <<start_controls>>
  ~isnarce_synth = Synth.after(~group, \isnare2, [
    <<bus_assignment>>
    \freq, 10,
    \dur, 20]);
  ~tempo_update.value(20, 0.01);
#+end_src

***** Play with a Pbind (4)
These work really well!

Now including [[*Create group and add control instrument (2)][Create group ...]] with a noweb link. This can be tangled to self contained sclang code (test.sc in this example)
#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_4>>
  ~event_str = Pbind(\instrument, \isnare2,
    <<bus_assignment>>
    \group, ~group,
    \addAction, 1,
    \position, 0,
    \disperse, 1,
    \noise, 0.0001,
    \freq, 10,
    \dur, 0.1
  ).play;
#+end_src

#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_1>>
  ~event_str = Pbind(\instrument, \isnare2,
    <<bus_assignment>>
    \group, ~group,
    \position, 12,
    \disperse, 0,
    \noise, 0.01,
    \freq, 1,
    \dur, 0.1,
  ).play;
#+end_src

Move repeated stuff out for cleaner Pbind
#+name: bus_assignment
#+begin_src sclang :results none
  \inBus1, ~saw_control_bus_1.index,
  \inBus2, ~saw_control_bus_2.index,
  \inBus3, ~saw_control_bus_3.index,
#+end_src

To play from the variable.
#+begin_src sclang :results none
  ~event_str.play;
  ~event_str.reset;
#+end_src

Free the group
#+name: free_group
#+begin_src sclang :results none
  ~group.freeAll;
  ~group.free;
#+end_src
**** Stuff
Plot a control bus
#+begin_src sclang :results none
  {In.kr(~saw_control_bus_3.index)}.plot;
#+end_src

Inspect a control bus:
#+begin_src sclang :results none
  {Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_2.index))}.play;
#+end_src

#+begin_src sclang :results none :noweb eval
  //~init_durs.value
  (     
  ~player1 = Pbind(
    \instrument, \isnare,
    \dur, Pseq(~init_durs.value, inf),
    \freq, Prand([0, 0, 20], inf),
    \osc1, Pgauss(330, 10, inf),
    \osc2, Pgauss(180, 10, inf),
    \tri, Pgauss(110, 30, inf),
    \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
    \noise, Pgauss(0.3, 0.1, inf)
  ).play;
  )
#+end_src

Test the Pbind ~~player1~
#+begin_src sclang :results none
  //     ~player1.next(());
  ~player1.stop;
#+end_src
#+begin_src sclang :results none :noweb eval
  (     
  ~player1 = Pbind(
    \instrument, \impulseA,
    \dur, Pseq(~init_durs.value, 1),
    \freq, Prand([0, 0], inf)
  ).play;
  ) 
#+end_src

**** Method generation and manipulation
Test method to generate the array.
#+begin_src sclang :results none
  ~init_durs.value;
#+end_src
   
Create duration array
#+name: create_durs
#+begin_src sclang :results none
  (
  ~create_durs = { |arr=0, div=1, elem=4|
    var ldiv = 1/div;
    var lelem = elem * div;
    arr ++ Array.fill(lelem, {ldiv;});
  }
  )
#+end_src
   
Load create_durs first (if not loaded silently through the fake variable x)
#+name: init_durs
#+begin_src sclang :results none :noweb yes
  (
  ~init_durs = {
    (
          ~times = Array.new();
          for(1, 3, {arg i; ~times = ~create_durs.value(~times, (2**i), 4);});
          ~times.postln;
    )
  }
  )
#+end_src

Alternative function for creating an array of durations.
#+name: durations_array
#+begin_src sclang
  ~durations = {
    var durs = Array.new(64);
    a = (1!4);
    b = (0.5!8);
    c = (0.25!16);
    d = (0.125!32);
    durs = a ++ b;
    durs = durs ++ c;
    durs = durs ++ d;
  };
#+end_src

*** snare 4 filtered
Synth that is driven by an Impulse pulse generator.
#+name: isnare_filter_def
#+begin_src sclang :results none
  (
  ~controlBus_1 = Bus.control(s, 1);
  SynthDef(\isnare_filter, { | outBus=0, freq=0, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16 |
    var snd;
    var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
    var modulator = SinOsc.kr([1!16],[0.1!16]);
    var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
    par = par * modulator;
    snd = IFilteredSnare.ar(Impulse.ar(freq),
          band_1: b1, band_2: b2, band_3: b3,
          band_4: b4, band_5: b5, band_6: b6,
          band_7: b7, band_8: b8, band_9: b9,
          band10: b10, band11: b11, band12: b12,
          band13: b13, band14: b14, band15: b15,
          band16: b16,  osc_1_freq: osc1, osc_2_freq: osc2,
          triangle_freq: tri) * gain * env;
    Out.ar(outBus, snd);
  }).add;

  SynthDef(\control_synth, { | bus |
    Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
  }).send(s);
  )
#+end_src

#+begin_src shell :results none :noweb yes
  echo <<record_me()>>
#+end_src
#+begin_src shell :results none :noweb yes
  echo <<stop_record()>>

#+end_src
#+begin_src shell :noweb yes
  <<rename_file("isnare_filter_routine_b.wav")>>
#+end_src

SynthDef for a modulating snare drum synth. Parameters are:
- ~freq~: The frequency of the impulse playing the snare.
- ~gain~: General gain (0-1)
- ~osc1/2~: The frequecy of the two osccilators in the synth.
- ~tri~: The triangle wave frequecy
- ~noise~: The noise level (0-1)
- ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
- ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
- ~dur~: The duration of the note.
- ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
- ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
  #+name: isnare_filter_mod
  #+begin_src sclang :results none
    (
    SynthDef(\isnare_filter_mod_8, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, del, del_mod=0, dur, mod_freq_stretch |
      var snd, modulator_pf;
      var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
      var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
      modulator_pf = Select.kr(freq_mod + 1, [
            (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
            freq, 
            (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
      snd = IFilteredSnare8.ar(Impulse.ar(modulator_pf),
            band_1: b1, band_2: b2, band_3: b3,
            band_4: b4, band_5: b5, band_6: b6,
            band_7: b7, band_8: b8, delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
            triangle_freq: tri) * gain * env;
      Out.ar(out, snd);
    }).add;
    )
  #+end_src

  #+begin_src sclang :results none
    p = Pbind(\instrument, \isnare_filter_mod_8,
      \dur, 0.1,
      \out, 0,
      \freq, 1,
      \freq_mod, 0,
      \del_mod, 0,
      \b1, Pshuf([-0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, ], inf),
      \b2, Pshuf([-5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, ], inf),
      \b3, Pshuf([-10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, ], inf),
      \b4, Pshuf([-14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, ], inf),
      \b5, Pshuf([-19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, ], inf),
      \b6, Pshuf([-24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, ], inf),
      \b7, Pshuf([-29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, ], inf),
      \b8, Pshuf([-34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, ], inf),
    ).play;

    b = Pbind(\instrument, \isnare_filter_mod_8,
      \dur, 1,
      \out, 8, 
      \freq, 10,
      \freq_mod, 0,
      \del_mod, 0,
      \b1, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b2, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b3, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b4, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b5, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b6, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b7, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      \b8, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
    );

    Ptpar([0, p, 0.66666, b]).play
    //      b.play;
  #+end_src

  SynthDef for a modulating snare drum synth. Parameters are:
  - ~freq~: The frequency of the impulse playing the snare.
  - ~gain~: General gain (0-1)
  - ~osc1/2~: The frequecy of the two osccilators in the synth.
  - ~tri~: The triangle wave frequecy
  - ~noise~: The noise level (0-1)
  - ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
  - ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
  - ~dur~: The duration of the note.
  - ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
  - ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
    #+name: isnare_filter_mod
    #+begin_src sclang :results none
      (
      SynthDef(\isnare_filter_mod, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, del, del_mod=0, dur, mod_freq_stretch |
        var snd, modulator_pf;
        var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
        var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
        var mod_f = Array.series(16, 1, mod_freq_stretch);
        var mod_p = Array.series(16, 0, 0.4);
        var modulator_f = SinOsc.kr(mod_f, mod_p, add: 0);
        var unused = Array.series(16, 0.1, 0.05);
        var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
        modulator_pf = Select.kr(freq_mod + 1, [
              (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
              freq, 
              (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
        par = par * modulator_f;
        snd = IFilteredSnare.ar(Impulse.ar(modulator_pf),
              band_1: par[0], band_2: par[1], band_3: par[2],
              band_4: par[3], band_5: par[4], band_6: par[5],
              band_7: par[6], band_8: par[7], band_9: par[8],
              band10: par[9], band11: par[10], band12: par[11],
              band13: par[12], band14: par[13], band15: par[14],
              band16: par[15], delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
              //band16: par[15], delay: del, osc_1_freq: osc1, osc_2_freq: osc2,	
              triangle_freq: tri) * gain * env;
        Out.ar(out, snd);
      }).add;
      )
    #+end_src

    #+begin_src sclang :results none
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 0, \freq, 0.1, \freq_mod, 00, \mod_freq_stretch, 1, \dur, 10, \osc1, 200, \osc2, 330, \tri, 340, \noise, 1, \del_mod, 2, \del, 2000] );
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 1, \freq, 10, \freq_mod, 2, \dur, 12, \osc1, 120, \osc2, 235, \tri, 140, \del_mod, 0.5] );
      // s.meter;
    #+end_src

    #+name: isnare_filter_routine
    #+begin_src sclang :results none
      Pbind(
        \instrument, \isnare_filter_mod,
        \dur, 5,
        \freq, Pgauss(8, 3, inf),
        \freq_mod, Prand([0,1], inf),
        \del_mod, Pgauss(0.5, 0.5, inf),
        \b1, -120,
        \b2, -120,
        \b3, -120,
        \b4, -120,
        \b5, -120,
        \b6, -120,
        \b7, -120,
        \b8, -120,
        \b9, -120,
        \b10, -120,
        \b11, -120,
        \b12, -120,
        \b13, -120,
        \b14, -120,
        \b15, -120,
        \b16, -120,
        \osc1, Pgauss(230, 50, inf),
        \osc2, Pgauss(180, 50, inf),
        \tri, Pgauss(110, 30, inf),
        \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
        \noise, Pgauss(0.0, 0.1, inf),
        \mod_freq_stretch, Prand([0.1, 0.3, 0.5], inf)
      ).play;
    #+end_src

    Example of spatialization with filtering, no delay.
    #+begin_src sclang :results none
      Pbind(
        \out, 0,
        \instrument, \isnare_filter_mod,
        \del_mod, 0,
        \freq_mod, Prand([-0.2, 0, 1], inf),
        \dur, 10,
        \freq, Pgauss(10, 8, inf),
        \b1, Pgauss(-70, 20, inf),
        \b2, Pgauss(-70, 20, inf),
        \b3, Pgauss(-70, 20, inf),
        \b4, Pgauss(-70, 20, inf),
        \b5, Pgauss(-70, 20, inf),
        \b6, Pgauss(-70, 20, inf),
        \b7, Pgauss(-70, 20, inf),
        \b8, Pgauss(-70, 20, inf),
        \b9, Pgauss(-70, 20, inf),
        \b10, Pgauss(-70, 20, inf),
        \b11, Pgauss(-70, 20, inf),
        \b12, Pgauss(-70, 20, inf),
        \b13, Pgauss(-70, 20, inf),
        \b14, Pgauss(-70, 20, inf),
        \b15, Pgauss(-70, 20, inf),
        \b16, Pgauss(-70, 20, inf)
      ).play;
    #+end_src

    #+begin_src sclang :results none
      Pbind(
        \instrument, \isnare_filter_mod,
        \out, 0,
        \del_mod, 0,
        \freq_mod, Prand([0, 0], inf),
        \dur, 0.1,
        \freq, 10,
        \b1, Pseq([-0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, ], inf),
        \b2, Pseq([-4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, ], inf),
        \b3, Pseq([-8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, ], inf),
        \b4, Pseq([-12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, ], inf),
        \b5, Pseq([-16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, ], inf),
        \b6, Pseq([-21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, ], inf),
        \b7, Pseq([-25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, ], inf),
        \b8, Pseq([-29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, ], inf),
        \b9, Pseq([-33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, ], inf),
        \b10, Pseq([-37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, ], inf),
        \b11, Pseq([-42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, ], inf),
        \b12, Pseq([-46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, ], inf),
        \b13, Pseq([-50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, ], inf),
        \b14, Pseq([-54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, ], inf),
        \b15, Pseq([-58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, ], inf),
        \b16, Pseq([-63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, ], inf),
      ).play;
    #+end_src

    #+begin_src sclang :results none
      a = Pbind(\instrument, \isnare_filter_mod,
        \dur, 0.001,
        \freq, 5,
        \freq_mod, 0.09,
        \del_mod, 0.1,
        \b1, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
        \b2, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
        \b3, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
        \b4, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
        \b5, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
        \b6, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
        \b7, Pseq([-76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, ], inf),
        \b8, Pseq([-64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, ], inf),
        \b9, Pseq([-47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, ], inf),
        \b10, Pseq([-24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, ], inf),
        \b11, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
        \b12, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
        \b13, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
        \b14, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
        \b15, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
        \b16, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
      );

      b = Pbind(\instrument, \isnare_filter_mod,
        \dur, 0.005,
        \freq, 1,
        \freq_mod, 2,
        \del_mod, 5,
        \b1, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
        \b2, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
        \b3, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
        \b4, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
        \b5, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
        \b6, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
        \b7, Prand([-11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, ], inf),
        \b8, Prand([-10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, ], inf),
        \b9, Prand([-8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, ], inf),
        \b10, Prand([-8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, ], inf),
        \b11, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
        \b12, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
        \b13, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
        \b14, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
        \b15, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
        \b16, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
      );
      Ptpar([0, a, 0.5, b]).play;
    #+end_src

    Controlling the filters
    #+begin_src sclang :results none :noweb eval
      ~init_durs.value
      (     
      ~player1 = Pbind(
        \instrument, \isnare,
        \dur, Pseq(~init_durs.value, inf),
        \freq, Prand([0, 0, 20], inf),
        \osc1, Pgauss(330, 10, inf),
        \osc2, Pgauss(180, 10, inf),
        \tri, Pgauss(110, 30, inf),
        \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
        \noise, Pgauss(0.3, 0.1, inf)
      ).play;
      )
    #+end_src

    Stop playback
    #+begin_src sclang :results none
      ~player1.stop;
    #+end_src
*** bass snare 1
Used in the drum loop among other places.
**** synthdef
#+name: bsnare
#+begin_src sclang :results none
  (
  ~bass_snare = SynthDef(\bsnare, {
    var snd;
    var impfreq = \impfreq.kr(1),
    osc1 = \osc1.kr(50),
    osc2 = \osc2.kr(70),
    trifreq = \trifreq.kr(10),
    fltq = \fltq.kr(1),
    fltfreq = \fltfrq.kr(100),
    fltgain = \fltgain.kr(1),
    modfreq = \modfreq.kr(0),
    attack = \attack.kr(0.0000001),
    rel = \release.kr(0.1),
    noise_attack = \nattack.kr(1e-08),
    noise_sustain = \nsustain.kr(0.016),
    noise_rel = \nrel.kr(0.1),
    noise_vol = \nvol.kr(0.073),
    dur = \length.ir(0.5),
    gain = \gain.ir(1.0),
    env = Env.new(levels: [0, 1, 0], times: [0.000001, dur]);
    snd = OBassSnare.ar(Impulse.ar(impfreq),
          osc_1_freq: osc1,
          osc_2_freq: osc2, 
          triangle_freq: trifreq,
          flt_frq: fltfreq,
          flt_q: fltq,
          flt_gain: fltgain,
          modulation_freq: modfreq,
          noise_sustain: 0.2,
          noise_vol: 0.05,
          noise_rel: 0.01) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(0, snd * gain);
  }).add
  )
#+end_src

#+name: bsnare_play
#+begin_src sclang :results none
  ~bsnare = Synth.new("bsnare", [\impfreq, 0, \mod_freq, 0]);
#+end_src

#+begin_src sclang :results none
  ~bsnare = Synth.new("bsnare", [\impfreq, 1, \mod_freq, 0, \trifreq, 150, \osc1, 130, \osc2, 70, \nvol, 0.5, \nrel, 0.9, \release, 0.001, \fltfrq, 400, \fltq, Kms0.1, \gain, 4]);
#+end_src

#+begin_src sclang :results none
  SynthDef(\odisp_snare, {
    var impfreq = \impfreq.kr(1), position = \pos.kr(0), disperse = \disperse.kr(1), attack = \attack.kr(1e-08),
    noise_attack = \nattack.kr(1e-08), noise_lvl = \nlevel.kr(0.1), noise_rel = \nrel.kr(0.1),
    osc1 = \osc1freq.kr(330), osc2 = \osc2freq.kr(180), rel = \rel.kr(0.1),
    trifreq = \trifreq.kr(111);
    var snd;
    var modulator = SinOsc.kr([1!16],[0.1!16]);
    snd = ODispersedSnare.ar(Impulse.ar(impfreq),
          osc_1_freq: osc1, osc_2_freq: osc2,
          triangle_freq: trifreq);
    Out.ar(position, snd);
  }).add;
#+end_src

#+begin_src sclang :results none
  ~snare = Synth.new("odisp_snare", [\impfreq, 30, \disperse, 0]);
  s.meter;
#+end_src

**** pbind for bsnare
#+begin_src sclang :results none
  (
  ~bsnare_player = Pbind(
    \instrument, \bsnare,
    \dur, 0.5,
    \impfreq, Pwhite(1, 4, inf),
    \mod_freq, 0,
    \fltfrq, Pwhite(100, 200, inf),
    \fltq, Pseq((1..60) / 60, inf),
    \fltgain, Pseq(1 / (1..10), 20),
    \fltfreq, Pseq((100..200), 20)
  ).play;
  )
#+end_src
*** snare 5: isnaredisp 
**** synthdef
#+name: flt_snare_dispersed
#+begin_src sclang :results none
  (
  ~isnaredisp = SynthDef(\isnaredisp, {
    var snd,
    o_offset = \offset.ir(0),
    period = \pulse_period.kr(5000),
    random = \random.ir(1),
    osc1 = \osc1.kr(50),
    osc2 = \osc2.kr(60),
    tri = \triangle.kr(90),
    noise_lvl = \noise_lvl.kr(0.1),
    noise_attack = \noise_attack.kr(0.0001),
    noise_rel = \noise_rel.kr(0.1);
    snd = IFilteredSnareDispersed.ar(
          offset: o_offset,
          random: random,
          tempo: period,
          osc_1_freq: osc1,
          osc_2_freq: osc2,
          triangle_freq: tri,
          noise_lvl: noise_lvl,
          noise_attack: noise_attack,
          noise_rel: noise_rel);
    Out.ar(0, snd);
  }).add
  )
#+end_src

Start it up
#+begin_src sclang :results none
  ~ifiltsnare = Synth.new("isnaredisp", [\pulse_period, 10000, \random, 0, \offset, ]);
  s.meter;
#+end_src

Control the speed via a slider.
#+begin_src sclang :results none
  (
  w = Window.new.front;
  b = NumberBox(w, Rect(20, 20, 150, 20));
  a = Slider(w, Rect(20, 60, 150, 20)).action_({
    b.value_(a.value);
    ~ifiltsnare.set(\pulse_period, (a.value * 48000));
  });
  a.action.value;
  )     
#+end_src

*** snare 6: ambisonics
**** synthdef
Simple instance of a snare synth

#+begin_src sclang :results none :noweb yes
  <<boot_jack>>
#+end_src

#+name: original_snare_two
#+begin_src sclang :results none
  (
  ~snare_one = SynthDef(\snare, { | gain=1, freq=2000, vol=4, q=1, out=0, length=0.5 |
    var snd;
    var env = Env([0, 1, 0], [0.0001, length]);
    snd = IGenericSnarefs.ar(freq,
          \attack.kr(0.000001),
          \noiseattack.kr(0.000001),
          \noiselvl.kr(0.1),
          \noiserel.kr(0.01),
          \osc1.kr(300),
          \osc2.kr(200),
          \release.ir(0.1),
          \tri.kr(400)) * EnvGen.kr(env, doneAction: Done.freeSelf);
    snd = snd * 0.2;
    Out.ar(out, snd);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  ~snare_one.free;
#+end_src

**** player
Play one hit on the snare above.
#+name: reg_snare_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snare", [\freq, 5000, \noiselvl, 0.1, \out, 0, \length, 0.1] );
#+end_src
     
Pbind for ambisonics
#+name: player
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
    \freq, 3000,
    \out, 0,
    \dur, Prand([0.1, 0.2], inf)
  ).play;
  s.meter;
#+end_src
     
#+call: play()

Double player
#+name: play
#+begin_src sclang :results none
  ~a_player = Pbind(\instrument, \snare,
    \freq, 3000,
    \out, 31,
    \dur, 0.1,
    \freq, 300
  ); 
  ~b_player = Pbind(\instrument, \snare,
    \freq, 1000,
    \out, 33,
    \dur, 0.2
  );
  ~a_player.play;
  ~b_player.play;
  s.meter;
#+end_src

#+begin_src sclang :results none
  ~a_player.stop;
  ~b_player.stop;
#+end_src
     
#+call: connect()

**** ambisonics
     
***** 1D114 3rd order
Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
#+name: encode
#+begin_src sclang :results none
  (
  // Settings
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 16;
  s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal.put(0, {HOAEncoder.ar(~order, In.ar(31, 1), \azpana.kr(3.14), \elpana.kr(3.14))});
  ~hoaSignal.put(1, ({HOAEncoder.ar(~order, In.ar(33, 1), \azpanb.kr(3.14), \elpanb.kr(3.14))}));
  ~hoaSignal.fadeTime = 1;

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
    var in; in = \in.ar(0!~hoaNumChannels);
    in.add(0);
    KMH114AEC3h3pFull6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src

Print the possible control keys for this NodeProxy
#+begin_src sclang :results none
  ~hoaSignal.controlKeys;
#+end_src
      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src
***** 1D108 3rd order
Start the player
#+call: play()
Start the encoder
#+call: encode()
Connect the encoder with the decoder
#+call: connect()


Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
#+name: encode
#+begin_src sclang :results none :noweb yes
  (
  // Settings
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 8;
  s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
  ~hoaSignal.play;

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal[0] = { HOAEncoder.ar(~order, In.ar(31, 1), \azpana.kr(-3.14), \elpana.kr(0), \gaina.kr(0), plane_spherical:1) };
  ~hoaSignal[1] = { HOAEncoder.ar(~order, In.ar(33, 1), \azpanb.kr(-3.14), \elpanb.kr(0),  plane_spherical:1) };
  ~hoaSignal.fadeTime = 0.1;

  // Panning automation
  // Create a new panner NodeProxy
  ~azimuthA = NodeProxy.control(s, 1);
  ~azimuthB = NodeProxy.control(s, 1);

  // Set its source to a control signal 
  ~azimuthA.source = { MouseX.kr(-pi, pi); };
  //	 ~azimuthA.source = { SinOsc.kr(0.1, 0, 0.7pi, 0); };
  ~azimuthB.source = { SinOsc.kr(0.2, 0, 0.5pi, 0); };

  // Call .set on the object you want to control given the parameter and the control proxy as arguments

  ~hoaSignal.set(\azpana, ~azimuthA);
  //	 ~hoaSignal.set(\azpanb, ~azimuthB);
  //	 ~azimuthA.play;
  //	 ~azimuthB.play;

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
    var in; in = \in.ar(0!~hoaNumChannels);
    in.add(0);
    KMH108AE3h3pNormal6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src

      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src

Control the panning position A
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 3.14);
  ~hoaSignal.set(\elpana, 3.14);
  ~hoaSignal.set(\azpanb, 3.14);
  ~hoaSignal.set(\elpanb, 3.14);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 0);
  ~hoaSignal.set(\elpana, 0);
  ~hoaSignal.set(\azpanb, 0);
  ~hoaSignal.set(\elpanb, 0);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, -3.14);
  ~hoaSignal.set(\elpana, -3.14);
  ~hoaSignal.set(\azpanb, -3.14);
  ~hoaSignal.set(\elpanb, -3.14);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 1.25);
  ~hoaSignal.set(\elpana, 1.25);
  ~hoaSignal.set(\azpanb, 1.25);
  ~hoaSignal.set(\elpanb, 1.25);
#+end_src

***** Lilla salen 3rd order
Start server
#+call: boot_jack()
Start the player
#+call: play()
Start the encoder
#+call: l_encode()
Connect the encoder with the decoder
#+call: connect()

#+begin_src sclang :results none

#+end_src
Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
#+name: l_encode
#+begin_src sclang :results none :noweb yes
  (
  // Settings
  var trig;
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 29;
  // s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
  //~hoaSignal.play;

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal[0] = { HOAEncoder13.ar(In.ar(31, 1), \gaina.kr(0), \rad.kr(2), \azpana.kr(-3.14), \elpana.kr(0)) };
  ~hoaSignal[1] = { HOAEncoder13.ar(In.ar(33, 1), \gaina.kr(0), \rad.kr(2), \azpanb.kr(-3.14), \elpanb.kr(0)) };
  ~hoaSignal.fadeTime = 0.1;

  // Panning automation
  // Create a new panner NodeProxy
  ~azimuthA = NodeProxy.control(s, 1);
  ~azimuthB = NodeProxy.control(s, 1);
  ~elevationA = NodeProxy.control(s, 1);
  ~elevationB = NodeProxy.control(s, 1);
  ~radiusA = NodeProxy.control(s, 1);

  // Set its source to a control signal 
  // The HOAencoder used above has 0 deg in front moving counter 
  // clockwise to 360 deg at front again.
  // 90 deg Y-axis is top and -90 is bottom

  // ~azimuthA.source = { MouseX.kr(0, 360); };
  // ~azimuthB.source = { MouseX.kr(0, 360); };
  // ~elevationA.source = { MouseY.kr(-90, 90); };
  // ~elevationB.source = { MouseY.kr(-90, 90); };
  trig = Impulse.kr(0.01);
  ~azimuthA.source = { LinLin.kr(Phasor.kr(Impulse.kr(1), 0.05/ControlRate.ir), 0, 1, 0, 360); };
  ~azimuthB.source = { LinLin.kr(Phasor.kr(Impulse.kr(1), 0.1/ControlRate.ir), 0, 1, 0, 360); };
  //~radiusA.source = { MouseX.kr(360, 1); };

  // Call .set on the object you want to control given the parameter and the control proxy as arguments
  ~hoaSignal.set(\azpana, ~azimuthA);
  ~hoaSignal.set(\azpanb, ~azimuthB);
  ~hoaSignal.set(\elpana, ~elevationA);
  ~hoaSignal.set(\elpanb, ~elevationB);
  ~hoaSignal.set(\rad, ~radiusA);

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
    var in; in = \in.ar(0!~hoaNumChannels);
    in.add(-10);
    KMHLSDome3h3pNormal6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src
      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src
***** panning
Panning instrument
#+name: snare_panner
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, In.kr();
#+end_src

***** Connect
Signal, encoded and decoded, but not mapped. Use this.
#+name: connect
#+begin_src sclang :results none
  (
  ~decoder.play(0, ~decoderNumChannels, vol: 16.0);
  ~hoaSignal <>> ~decoder;
  )
#+end_src

***** Disconnect
#+begin_src sclang :results none
  ~decoder.clear;
  ~hoaSignal.clear;
  ~hoaSignalA.clear;
  ~hoaSignalB.clear;
#+end_src

*** snare 7: convolution
**** synthdef
#+begin_src sclang :results none
  (
  SynthDef(\isnare, { | outBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, pulse=200, dur=1, distance=0 |
    var snd, rev;
    var env = Env([0, 1, 0], [0.0001, 0.5]);
    snd = IDispersedSnare.ar(position, disperse, pulse) * EnvGen.kr(env, timeScale: dur, doneAction: Done.freeSelf);
    rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
    Out.ar(outBus, snd);
  }).add;
  )
#+end_src

Named controls
#+begin_src sclang :results none
  (
  SynthDef(\isnarenc, {
    var snd;
    var env = Env([0, 1, 0], [0.0001, 0.5]);
    snd = ODispersedSnare.ar(Impulse.ar(\pulse.ar(440)), \position.kr(0), \disperse.kr(0)) * EnvGen.kr(env, timeScale: \dur.kr(1), doneAction: Done.freeSelf);
    //	   rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
    Out.ar(\outBus.ir, snd);
  }).add;
  )
#+end_src
     
**** player
#+begin_src sclang :results none
  (
  a = Array.fill(16, { arg i; (i + 1) / 16 });
  Pbind (\instrument, \isnarenc,
    //	   \position, Pseq((0..29), inf),
    \position, 0,
    \outBus, 0,
    \disperse, 0.0,
    \pulse, 10000,
    \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
    \gain, Pseq(a, inf),
    \distance, Pseq(a.reverse, inf),
    \dur, 2
  ).play;
  )
  //       s.meter;
#+end_src

#+begin_src sclang :results none
  a = Array.fill(16, { arg i; (i + 1) / 16 });
  Pbind (\instrument, \isnare,
    \position, Pseq((0..29), inf),
    \disperse, 0.0,
    \impf, 80000, //Pfunc({30.rand2}),
    \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
    \gain, Pseq(a, 16),
    \distance, Pseq(a.reverse, 16),
    \dur, 1
  ).play;

  Pbind (\instrument, \isnare,
    \position, 1,
    \distance, Pseq([0, 0.1, 0.2, 0.3, 0.4, 0.5], 10),
    \disperse, 0,
    \impf, 10000,
    \dur, 1,
    \delta, 0
  ).play;
#+end_src

**** convolution
preparation; essentially, allocate an impulse response buffer, then
follow a special buffer preparation step to set up the data the plugin needs.
Different options are provided commented out for loading impulse responses from soundfiles.
 

#+begin_src sclang :results none

  (
  â
  // also 4096 works on my machine; 1024 too often and amortisation too pushed, 8192 more high load FFT
  ~fftsize = 4096;
  â
  s.waitForBoot {
    â
    {
          var ir, irbuffer, bufsize;
          â
          // // MONO ONLY
          // pre-existing impulse response sound files
          // (could also use any general soundfile too for cross-synthesis effects)
          // irbuffer = Buffer.read(s, "/Volumes/data/audio/ir/ir2.wav");
          â
          // synthesise the honourable 'Dan Stowell' impulse response
          â
          ir = [1] ++ 0.dup(100) ++ (
            (1, 0.99998 .. 0)
            .collect {|f|
                  f = f.squared.squared;
                  f = if(f.coin) { 0 }{ f.squared };
                  f = if(0.5.coin) { 0 - f } { f }
            } * 0.1
          );
          ir = ir.normalizeSum;
          â
          irbuffer = Buffer.loadCollection(s, ir);
          â
          s.sync;
          â
          bufsize = PartConv.calcBufSize(~fftsize, irbuffer);
          â
          // ~numpartitions= PartConv.calcNumPartitions(~fftsize, irbuffer);
          â
          ~irspectrum = Buffer.alloc(s, bufsize, 1);
          ~irspectrum.preparePartConv(irbuffer, ~fftsize);
          â
          s.sync;
          â
          irbuffer.free; // don't need time domain data anymore, just needed spectral version
    }.fork;
    â
  }
  )
  â
  ~target = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

  (
  {
    var input = PlayBuf.ar(1, ~target, loop:1);
    var rev = PartConv.ar(input, ~fftsize, ~irspectrum.bufnum, 0.5);
    var mix = (input * 0) + (rev * 1);
    Out.ar(0, mix);
  }.play
  )

  (
  {
    PlayBuf.ar(1, ~target, loop:1);
  }).play

#+end_src
     
*** snare 8: polyrhythmic
**** synthdef
The ~\amp~ parameter does not work in the faust model. Instead, use ~\vol~.
#+name: i_snare_poly
#+begin_src sclang :results none
  (
  ~isnarePoly = SynthDef(\isnarePoly, {
    var snd, env, envelope, duration=1, pulse, nlvl, nr, vol=0.5;
    /* Envelope and duration */
    envelope = Env.new(
          levels: [0, 1, 0.7, 0],
          times: [0.2, 0.2, 0.6],
          curve: \sine
    );
    b = 0;
    envelope.times.do({ arg i; b = b + i; });
    duration = \dur.ir / b;
    env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);

    /* Parameter: pulse */
    pulse = \pulse.kr(40) * \pulseMod.kr(1);
    /*
          Parameter: noislevel.
          Scale it to pulse
    ,*/
    vol = \vol.kr(0.5);
    nlvl = LinExp.kr(pulse, 1, 800, 0.02, 0.000001);
    nr = LinExp.kr(pulse, 1, 800, 0.2, 0.001);
    snd = ISnarePhaseDisp.ar(\pos.kr(0),
          \disperse.kr(0),
          pulse,
          1,
          \attack.kr(0.0001),
          \fsweep.kr(0),
          \nattack.kr(0.0001),
          nlvl,
          \nrel.kr(0.15),
          //nr,	
          \osc1.kr(300),
          \osc2.kr(140),
          \rel.kr(0.01),
          \tri.kr(130));
    Out.ar(\outBus.ir, snd * env * vol);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  a = Synth.new(\isnarePoly, [\pulse, 200, \dur, 5, \rel, 0.3, \vol, 0.4, \attack, 0.01, \osc1, 100, \osc2, 200, \tri, 120, \nattack, 0.0002], addAction: \addToTail);
#+end_src

#+begin_src sclang :results none
  (
  SynthDef(\controlSnare, { arg bus;
    Out.kr(bus, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(1), doneAction: Done.freeSelf));
  }).add;
  )
#+end_src

Free busses and instances
#+begin_src sclang :results none
  ~speedControl.numChannels;
  ~speedControl.free;
#+end_src

#+begin_src sclang :results none
  { Poll.kr(Impulse.kr(10), LinExp.kr(Line.kr(1, 100, 5, doneAction: Done.freeSelf), 1, 200, 0.9, 0.00001)) }.play;
#+end_src

#+begin_src sclang :results none
  { Poll.kr(Line.kr(1, 100, 5, doneAction: Done.freeSelf)) }.play;
#+end_src
**** player
Load synth def:
#+call: i_snare_poly()

To play the ISnarePhaseDisp with modulation:
#+begin_src sclang :results none :noweb yes
  ~speedControl = Bus.control(s, 1);
  <<i_snare_poly()>>;
  a = Synth.new(\isnarePoly, [\pulse, 1, \rel, 0.01, \dur, 2], addAction: \addToTail);
  a.map(\pulseMod, ~speedControl);
  // y = {Out.kr(~speedControl, Line.kr(\start.kr(0.001), \end.kr(1), \dur.kr(10), doneAction: Done.freeSelf)) }.play(addAction: \addToHead);
  // y = {Out.kr(~speedControl, SinOsc.kr(1, 0, 1, 1))}.play(addAction: \addToHead);
  // b = Synth.new(\controlSnare, [~speedControl, \dur, 1, \start, 10, \end, 1], addAction: \addToHead);
#+end_src

#+begin_src sclang :results none
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \dur, 2,
    \rel, 0.01,
    \outBus, 1,
  ).trace.play;
#+end_src

Harmnony from integer multiples of freq 100 and 200 Hz. Very nice texture.
#+begin_src sclang :results none
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Prand([1,2,3,4], 10) * 200,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \dur, 13,
    \rel, 0.01,
    \outBus, 1,
  ).trace.play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Prand([1,2,3,4,5,6], 10) * 200,
    \dur, 21,
    \amp, 0.01,
    \rel, 0.01,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \dur, 13,
    \rel, 0.01,
    \outBus, 1,
  ).trace.play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
    \dur, 8,
    \amp, 0.01,
    \rel, 0.01,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
    \dur, 5,
    \amp, 0.01,
    \rel, 0.01,
    \outBus, 1
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse,  Pfunc(1+ 10.rand2.abs * 100),
    \dur, 3,
    \amp, 0.01,
    \rel, 0.01,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse,  Pfunc(1+ 10.rand2.abs * 100),
    \dur, 2,
    \amp, 0.01,
    \rel, 0.01,
    \outBus, 1
  ).play;
#+end_src

Corresponding polyrhythms from the above harmony (at a slower rate)
#+begin_src sclang :results none
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5], 10) * 2,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ),
    \rel, 0.04,
    \dur, 34,
    \outBus, 1,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5], 10) * 2,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ), 
    \rel, 0.045,
    \dur, 21,
    \amp, 0.01,
    \outBus, 0,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ),
    \rel, 0.04,
    \dur, 13,
    \outBus, 1,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ), 
    \rel, 0.04,
    \dur, 8,
    \amp, 0.01,
    \outBus, 0,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ), 
    \rel, 0.04,
    \dur, 5,
    \amp, 0.01,
    \outBus, 1,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ), 
    \rel, 0.04,
    \dur, 3,
    \amp, 0.01,
    \outBus, 0,
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \tri, Pfunc( Pkey(\pulse) * 50),
    \osc1, Pfunc({1.0.rand} * 400 ),
    \osc2, Pfunc({1.0.rand} * 300 ),
    \rel, 0.04,
    \dur, 2,
    \amp, 0.01,
    \outBus, 1,
  ).play;
#+end_src

Harmony following scale defined in documentation.org
Very nice but dense sound.
#+begin_src sclang :results none
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 261.6,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \dur, 20,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 1,
  ).trace.play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 264.87,
    \dur, 21,
    \amp, 0.01,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 267.87844,
    \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
    \dur, 21,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 1,
  ).trace.play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 282.52807,
    \dur, 13,
    \amp, 0.01,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 294.3,
    \dur, 21,
    \amp, 0.01,
    \rel, 0.001,
    \delta, Pkey(\dur) / 3,
    \outBus, 1
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse,  326.99987,
    \dur, 13,
    \amp, 0.01,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 331.08750,
    \dur, 15,
    \amp, 0.01,
    \rel, 0.001,
    \delta, Pkey(\dur) / 3,
    \outBus, 1
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 387.5554,
    \dur, 13,
    \amp, 0.01,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 392.4,
    \dur, 15,
    \amp, 0.01,
    \rel, 0.001,
    \delta, Pkey(\dur) / 3,
    \outBus, 1
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 465.06667,
    \dur, 13,
    \amp, 0.01,
    \rel, 0.01,
    \delta, Pkey(\dur) / 3,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 490.50036,
    \dur, 15,
    \amp, 0.01,
    \rel, 0.001,
    \delta, Pkey(\dur) / 3,
    \outBus, 1
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, 523.2,
    \dur, 15,
    \amp, 0.01,
    \rel, 0.001,
    \delta, Pkey(\dur) / 3,
    \outBus, 1
  ).play;
#+end_src

#+begin_src sclang :results none
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pseq([490.50036, 392.4], inf),
    \dur, 15,
    \amp, 0.01,
    \rel, 0.001,
    \delta, 2,
    \outBus, 1
  ).play;
#+end_src

Pbind with multi channel expansion playing the harmonies of [[file:documentation.org::snares_harmony][snares_harmony]].
#+begin_src sclang :results none
  var tuning, scale,
  freqs = [264.87, 267.87844, 282.52807, 294.3, 326.99987, 331.0875, 387.5554, 392.4, 465.06667, 490.50036, 523.2 ],
  vol = 0.8,
  rel = 0.001,
  delta = 6,
  seqA = [0, 1, 2, 3, 4, 5, 6, 7, 8],
  seqB = [2, 3, 4, 5, 6, 7, 8, 9, 10],
  // combined = [seqA, seqB].flop;
  combined = [[2,5,-3], [13, 7, 10], [0, 6, 8], [11,6,4], [-2, 4, 8], [1,10,7], [0,4,6], [3, 5, 10], [0,4,5], [3, 5, 12], [2,4,9]];
  beatings = [];

  tuning = Tuning.new(#[0, 0.215063, 0.410591, 1.33238, 2.0391, 3.86313, 4.0782, 6.80448, 7.019550000000001, 9.9609, 10.8827 ]);
  scale = Scale.new(#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11, tuning, name: \snarePitch);

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(combined, 1),
    \pulse, Pfunc({|ev| midicps(ev.note + 72);}),
    \dur, 6,
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 0
  ).play;
#+end_src

#+begin_src sclang
  var tuning, scale,
  freqs = [264.87, 267.87844, 282.52807, 294.3, 326.99987, 331.0875, 387.5554, 392.4, 465.06667, 490.50036, 523.2 ],
  vol = 0.8,
  rel = 0.001,
  delta = 6;

  tuning = Tuning.new(#[0, 0.215063, 0.410591, 1.33238, 2.0391, 3.86313, 4.0782, 6.80448, 7.019550000000001, 9.9609, 10.8827 ]);
  scale = Scale.new(#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11, tuning, name: \snarePitch);

  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pseq([freqs[1], freqs[1]/2, freqs[1]/4, freqs[1]/8, freqs[1]/16, freqs[1]/32, freqs[1]/64, freqs[1]/128, freqs[1]/256], 1),
    \dur, Pseq([10,6, 8, 10, 12, 14, 15, 16], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 0
  );
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pseq([freqs[4], freqs[4]/2, freqs[4]/4, freqs[4]/8, freqs[4]/16, freqs[4]/32, freqs[4]/64, freqs[4]/128, freqs[4]/256], 1),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 1
  );

  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pseq([freqs[1], freqs[1]/2, freqs[1]/3.8, freqs[1]/7, freqs[1]/15, freqs[1]/30, freqs[1]/60, freqs[1]/120, freqs[1]/248], 1),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \pulse, Pseq([freqs[4], freqs[4]/2, freqs[4]/3, freqs[4]/7, freqs[4]/14, freqs[4]/30, freqs[4]/60, freqs[4]/120, freqs[4]/250], 1),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 1
  ).play;
#+end_src

#+begin_src sclang
  var tuning, scale,
  freqs = [264.87, 267.87844, 282.52807, 294.3, 326.99987, 331.0875, 387.5554, 392.4, 465.06667, 490.50036, 523.2 ],
  vol = 0.4,
  rel = 0.001,
  delta = 9,
  seqA = [0, 1, 2, 3, 4, 5, 6, 7, 8],
  seqB = [2, 3, 4, 5, 6, 7, 8, 9, 10];

  tuning = Tuning.new(#[0, 0.215063, 0.410591, 1.33238, 2.0391, 3.86313, 4.0782, 6.80448, 7.019550000000001, 9.9609, 10.8827 ]);
  scale = Scale.new(#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11, tuning, name: \snarePitch);

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqA, 2),
    \pulse, Pfunc({|ev| midicps(ev.note + 60);}),
    \dur, Pseq([10,6, 8, 10, 12, 14, 15, 16], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 0
  );
  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqB, 2),
    \pulse, Pfunc({|ev| midicps(ev.note + 60);}),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 1
  );

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqA, 2),
    \pulse, Pfunc({|ev| midicps(ev.note + 48);}),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 0
  ).play;
  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqB, 2),
    \pulse, Pfunc({|ev| midicps(ev.note + 48);}),
    \dur, Pseq([10,6, 8, 10, 12, 14, 20, 30], 1),
    \vol, vol,
    \rel, rel,
    \delta, delta,
    \outBus, 1
  ).play;
#+end_src

#+begin_src sclang
  var tuning, scale, duration = 20, delta = 19;
  var seq1 = [0, 1, 2, 3, 4, 5, 6, 7, 8];
  var seq2 = [3, 4, 5, 6, 7, 6, 7, 9, 10];
  var seqa = [0, 4, 6, 8, 6, 4, 3, 1];
  var seqb = [4, 3, 2, 1, 0, 1, 2, 3];
  //  var seqa = [0, 1, 2, 3, 4, 3, 2, 1];
  //  var seqb = [4, 3, 2, 1, 0, 1, 2, 3];
  tuning = Tuning.new(#[0, 0.215063, 0.410591, 1.33238, 2.0391, 3.86313, 4.0782, 6.80448, 7.019550000000001, 9.9609, 10.8827 ]);
  scale = Scale.new(#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11, tuning, name: \snarePitch);

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqa, 2),
    \pulse, Pfunc({|ev| tuning[ev.note];}),
    \dur, duration,
    \vol, 0.01,
    \rel, 0.3,
    \attack, 0.01,
    \osc1, Pkey(\pulse) * 100,
    \osc2, Pkey(\pulse) * 200,
    \nattack, 0.0002,
    \delta, delta,
    \outBus, 0
  ).play;

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqb, 2),
    \pulse, Pfunc({|ev| tuning[ev.note];}),
    \dur, duration,
    \vol, 0.01,
    \rel, 0.3,
    \attack, 0.01,
    \osc1, Pkey(\pulse) * 50,
    \osc2, Pkey(\pulse) * 120,
    \nattack, 0.0002,
    \delta, delta,
    \outBus, 1
  ).play;

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqa, 2),
    \pulse, Pfunc({|ev| tuning[ev.note];}),
    \dur, duration,
    \vol, 0.01,
    \rel, 0.3,
    \attack, 0.01,
    \osc1, Pkey(\pulse) * 100,
    \osc2, Pkey(\pulse) * 200,
    \nattack, 0.0002,
    \delta, delta,
    \outBus, 0
  ).play;

  Pbind(
    \instrument, \isnarePoly,
    \note, Pseq(seqb, 2),
    \pulse, Pfunc({|ev| tuning[ev.note];}),
    \dur, duration,
    \vol, 0.01,
    \rel, 0.3,
    \attack, 0.01,
    \osc1, Pkey(\pulse) * 50,
    \osc2, Pkey(\pulse) * 120,
    \nattack, 0.0002,
    \delta, delta,
    \outBus, 1
  ).play;

#+end_src

#+begin_src sclang :results none
  s.reboot; // this will restart the server and thus reset the bus allocators
#+end_src

#+begin_src sclang :results none :noweb yes
  <<first_acc()>>
  <<second_acc()>>
#+end_src
#+name: first_acc
#+begin_src sclang :results none
  (
  var busA, busB, dur;
  dur = 24;
  busA = Bus.control(s, 1);
  busB = Bus.control(s, 1);
  y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.1, \end, 300]);
  x = Synth.after(y, \isnarePoly, [\pos, 1,\pulse, 1, \dur, dur, \busA, busA.index]);
  )
#+end_src

#+name: second_acc
#+begin_src sclang :results none
  (
  var busA, busB, dur;
  dur = 24;
  busA = Bus.control(s, 1);
  busB = Bus.control(s, 1);
  y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.00001, \end, 200]);
  x = Synth.after(y, \isnarePoly, [\pos, 0, \pulse, 0, \dur, dur, \busA, busA.index]);
  )
#+end_src
     
#+begin_src sclang :results none
  (
  f = {
    Task ({
          loop {
            100.do({ |val|
                  a.set(\pulse, 5 * val);
                  val.postln;
                  0.1.wait;
            });
          }
    });
  };
  u = f.value.play;
  )

#+end_src
** break beat
#+begin_src sclang :results none :noweb yes
  <<original_snare>>
  ~breakBeat = Pbind(
    \instrument, \snare,
    //    \dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5], inf),
    \dur, Pseq([1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.015625, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125 ],1),
    \freq, Prand((300..310), inf),	
    \noiseattack, 0.0001,	
    \noiselvl, 0.0001,
    \noiserel, 0.0005,
    \release, 0.001,
    \gain, 2,
    \tri, 300,
    \length, Prand((10..50)*0.01, inf),		
    \out, 0
  ).play;
#+end_src
** pbind for accelerando
This is the pbind for the acc defined here: [[*accelerando, fixed tempo][accelerando, fixed tempo]]
The Synthdef is here: [[*synthdef][snare]]
#+name: accelerando_accent
#+begin_src sclang :results none :noweb yes
  (
  ~accent = Pbind(
    \instrument, \snare,
    \gain, Pdefn(\accents),
    \dur, Pdefn(\duration),
    \out, 0
  ).play;
  )
  /     Pdefn(\accents, Pseq(seq.value(4), 1));
  //     Pdefn(\accents, Pfunc({{|x=0| x+1; if(x==0, {1.0}, {rrand(0.2, 0.15)})} ! 4 }, 1));
  //     Pdefn(\duration, 1);
#+end_src

Second instance
#+name: accelerando_accent_two
#+begin_src sclang :results none :noweb yes
  // var seq = { |length=4|
  //         { |x=0| x+1; if(x==0, {1.0}, {0.01})} ! length;
  // };
  (
  ~accent_two = Pbind(
    \instrument, \snare,
    \gain, Pdefn(\accents),
    \dur, Pdefn(\duration),
    \out, 1
  );
  // Pdefn(\accents, Pseq(seq.value(4), 1));
  // Pdefn(\duration, 1);
  )
#+end_src

#+begin_src sclang :results none
  ~accent_two.play;
#+end_src

** beat
*** drumloop
#+begin_src sclang :results none
  p = Plambda(
    Pbind(
          \a, Plet(\z, Pseries(0, 1, inf), Pseries(100, -1, inf)),
          \b, Pget(\z, 0, inf) * 2
    ).trace(key: \eventScope, prefix: "\nscope: ")
  ).asStream;

  p.next(());
#+end_src

#+begin_src sclang :results none
  (
  var a, b, c, t;
  a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
  b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
  c = Ppar([a, b]);
  t = c.asStream;
  20.do({ t.next(Event.default).postln; });
  )
#+end_src

Load SynthDefs:
#+call: bsnare()
#+call: original_snare()
#+call: i_snare_phase_2()
#+call: bsnare_play()

#+begin_src sclang :results none
  Synth.new("snare_phase", [\pulse, 1, \nlevel, 0]);
#+end_src

Bass drum pulse with variation
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
    \instrument, \bsnare,
    \impfreq, 0,
    \length, 0.2,
    \osc1, 80,
    \osc2, 50,
    \trifreq, 70,
    \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
    \fltq, Pseq((1..7), inf),
    \release, 0.9,
    \dur, beatsInLoop,
    \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
    \rate, Pfunc { thisThread.clock.tempo / originalTempo }
  ).play;
#+end_src

Snare drum beat
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
    \instrument, \snare,
    \impf, 10,
    \freq, 300,
    \trifreq, 100,
    \length, 0.2,
    \out, 1,
    \gain, 1,
    \dur, beatsInLoop,
    \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
    \rate, Pfunc {thisThread.clock.tempo / originalTempo}
  ).play;
#+end_src

Global variables
#+name: global_tempo
#+begin_src sclang :results none
  ~beatsInLoop = 8;
  ~originalTempo = 90 / 60;
  TempoClock.tempo = ~originalTempo;
#+end_src

First bass drum pattern
#+name: b_drum_1
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_1  = Pbind (
    \instrument, \bsnare,
    \impfreq, 100,
    \osc1, 80,
    \osc2, 70,
    \trifreq, 70,
    \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
    \fltq, Pseq((1..7), inf),
    \gain, 4,
    \release, 0.9,
    \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.3,
    \dur, ~beatsInLoop,
    \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
    \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  );
#+end_src

First bass drum pattern
#+name: b_drum_2
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_2  = Pbind (
    \instrument, \bsnare,
    \impfreq, 1,
    \osc1, 70,
    \osc2, 50,
    \trifreq, 75,
    \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
    \fltq, Pseq((1..7), inf),
    \gain, 4,
    \release, 0.9,
    \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.5,
    \dur, ~beatsInLoop,
    \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
    \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  ).play;
#+end_src

First snare drum
#+name: s_drum_1
#+begin_src sclang :results none
  ~loop_snare_1 = Pbind (
    \instrument, \snare,
    \impf, Prand([~originalTempo, ~originalTempo*7, ~originalTempo*9], inf),
    \freq, Pseq([100, 200], inf),
    \trifreq, 500,
    \length, Prand((40..80), inf) * 0.01,
    \out, 0,
    \gain, 0.05,
    \dur, ~beatsInLoop,
    \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
    \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_2
#+begin_src sclang :results none
  ~loop_snare_2 = Pbind(
    \instrument, \snare,
    \impf, Prand([~originalTempo, ~originalTempo*2, ~originalTempo*3, ~originalTempo*4], inf),
    \freq, Pseq([500, 520, 530], inf),
    \trifreq, 50,
    \length, Prand((80..150), inf) * 0.01,
    \out, 1,
    \gain, 0.2,
    \dur, ~beatsInLoop,
    \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
    \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_3
#+begin_src sclang :results none
  ~loop_snare_3 = Pbind(
    \instrument, \snare_phase_2,
    \freq, Pseq([400, 500], inf),
    \freq2, Pseq([400, 550], inf),	
    \length, Prand((70..100), inf) * 0.01,
    \out, 1,
    \gain, 0.4,
    \dur, ~beatsInLoop,
    \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
    \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+begin_src sclang :results none
  s.meter;
#+end_src
Attempt to make a complete beat with variation.
#+begin_src sclang :results none :noweb yes
  (
  <<bsnare()>>;
  <<original_snare()>>;
  <<i_snare_phase_2()>>;
  <<bsnare_play()>>;

  <<global_tempo()>>;
  <<b_drum_1()>>;
  <<b_drum_2()>>;
  <<s_drum_1()>>;
  <<s_drum_2()>>;
  <<s_drum_3()>>;
  p = Ptpar([
    0, ~loop_bass_dr_1,
    0.5, ~loop_bass_dr_2,
    0.75, Pn(
          ~loop_snare_1	
    ),
    1, Pn(
          Plazy {
            ~loop_snare_2	
          }	
  ),
  2, ~loop_bass_dr_1,
  2.75, ~loop_bass_dr_2,
  3, Pn(
  ~loop_snare_3
  ),
  4.5, ~loop_bass_dr_1,
  4.75, ~loop_bass_dr_2,
  5, Pn(
  Plazy {
    ~loop_snare_2	
  }	
  ),
  6, ~loop_bass_dr_1,
  6, ~loop_bass_dr_2,
  7, Pn(
  ~loop_snare_3
  )
  ], 1).play;
  )

#+end_src
** panning
*** testing
:PROPERTIES:
:NOTER_DOCUMENT: /home/henrikfr/org/textnotes.org
:END:
Generalized example module for stereo panning.
#+begin_src sclang :results none :noweb yes
  ~panner = SynthDef(\stereo_panner, { |in, out=0, pan=0|
    var sig, output, direction;
    sig = In.ar(in, 1);
    direction = pan;
    Out.ar(out, Pan2.ar(sig, pan));
  }).add;
#+end_src

#+begin_src sclang :results none
  ~panner.free; 
#+end_src

#+begin_src sclang :results none :noweb yes
  var synth;
  ~synth = Synth.after(~snare_phase_2, \stereo_panner, [in: 25, pan: 0, out: 0]);
  <<ssingle>>
  //  s.meter;
#+end_src

Pan the signal in ~\~synth~.
#+begin_src sclang :results none
  ~synth.set(\pan, -1);
#+end_src

#+begin_src sclang :results none
  s.meter;
#+end_src

An example NodeProxy ~\~stereo_panner~ that pans the signal in ~\~player~. This shoule be altered to take a signal as argument. 
#+begin_src sclang :results none
  ~player = NodeProxy.new(s, \audio, 2);
  ~player.fadeTime = 1;
  ~player.source = { SinOsc.ar(440, 0, 0.1); };

  ~stereo_panner = NodeProxy.new.play;
  ~stereo_panner.fadeTime = 1;
  ~stereo_panner.source = {
    var in;
    in = \in.ar(0);
    Pan2.ar(in, \pan.kr(0););
  };

  ~player <>> ~stereo_panner;
#+end_src

Pan the above signal through ~\~stereo_panner~.
#+begin_src sclang :results none
  ~stereo_panner.set(\pan, 1);
#+end_src

*** pan factory
#+call: boot_jack()

Set up a factory method that creates a new NodeProxy and returns it.
#+name: pan_source_factory
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~pan_source_factory = { |synth|
    n = NodeProxy.new(s, \audio, 2);
    n.fadeTime= 1;
    n.source = synth;
    n;
  };
#+end_src

A panner factory that instantiates a NodeProxy for stereo panning.
#+name: panner_factory
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner_factory = { |panf|
    p = NodeProxy.new.play(0, 16);
    p.fadeTime = 1;
    p.source = panf;
    p;
  };
#+end_src

Instantiate a new ~\~pan_source_factory~ instance by name of ~\~sounder~.
#+name: sounder
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder = ~pan_source_factory.value({ SinOsc.ar(440, 0, 0.1); });
#+end_src

Instantiate a new ~\~panner_factory~ instance by name of ~\~panner~. This is how one assigns a pan function to a connection.
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner = ~panner_factory.value({
    var in;
    in = \in.ar(0);
    Pan2.ar(in, \pan.kr(0););
  });
#+end_src

Assign a new panning function to the ~\~panner~:
#+begin_src sclang :results none
  ~panner.source = {
    var in;
    in = \in.ar(0);
    PanAz.ar(
          numChans: 5,
          in: in,
          pos: LFSaw.kr(MouseX.kr(0.2, 8, 'exponential')),
          level: 0.5,
          width: 3,
          orientation: 0.5
    );
  };
#+end_src

Get back the old panner
#+begin_src sclang :results none
  ~panner.source = {
    var in;
    in = \in.ar(0);
    Pan2.ar(in, \pan.kr(0););
  };
#+end_src

#+begin_src sclang
  s.meter;
#+end_src
Instantiate a new ~\~pan_source_factory~ and a ~\~panner_factory~ at the same time:
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder2 = ~pan_source_factory.value({ SinOsc.ar(600, 0, 0.1); });
  ~panner2 = ~panner_factory.value({
    var in;
    in = \in.ar(0);
    Pan2.ar(in, \pan.kr(-1););
  });
#+end_src

Connect the two and start the process
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder2 <>> ~panner2;
  ~sounder <>> ~panner;
#+end_src

Send messages to the instance:
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner.set(\pan, 1);
#+end_src

** accelerando, fixed tempo
This actually works in a weird way.
- Why are the beats sometimes doubled?

- Play with various tempi and distributions.

- Panning?

  Uses the original snare in this instance
  #+call: original_snare()

  Use these Pbinds: [[*pbind for accelerando][pbind for accelerando]]
  #+call: accelerando_accent()
  #+call: accelerando_accent_two()

  Main function:
  #+call: bar_stretching_acc()

  Prepare all fuinctions, then call either of the two functions below.
  #+begin_src sclang :results none :noweb yes :tangle acc.sc
    <<original_snare>>
    <<accelerando_accent>>
    <<accelerando_accent_two>>
    <<bar_stretching_acc>>
  #+end_src

Call the function
#+begin_src sclang :results none
  ~breakFunction.value(1.2, 1, ~accent);
#+end_src

Call two praces going in opposite tempo directions
#+begin_src sclang :results none
  (
  ~breakFunction.value(0.8, 32, ~accent);
  ~breakFunction.value(1.2, 1, ~accenti);
  )
#+end_src

Main routine that creates arrays of snare hits. For each bar the tempo is increased as well as the number of hits. The functions attempts to keep the length of the bar intact while raising the tempo.
#+name: bar_stretching_acc
#+begin_src sclang :results none :noweb yes :tangle yes
  ~beatsPerBar = 4;
  ~breakFunction = { arg mul=1, tpo=1, player = ~accent;	
    var multiplier = mul; //the multiplier, lower than one for deaccelerando
    var tClock, beatsPB=2;
    var seq = { |length=4|
          { |x=0| x+1; if(x==0, {1.0}, {rrand(0.1, 0.07)})} ! length;
    };
    seq.postln;

    tClock = TempoClock(tpo); //start time is 1
    player.play(quant: 0, clock: tClock);
    fork {
          loop {
            var barDur = 4; // Duration in seconds
            var beatsPerBar = ~beatsPerBar;
            tClock.tempo = tClock.tempo * multiplier;
            "Tempo:".postln;
            tClock.tempo.postln;
            if((tClock.beatDur*(beatsPerBar+1)) < barDur,
                  {
                    var beatsToAdd = 1;
                    "Length of bar + 1 beat".postln;
                    (tClock.beatDur*(beatsPerBar+1)).postln;
                    (
                          i = 1;
                          while( {(tClock.beatDur*(beatsPerBar+i)) < barDur }, {i = i+1; beatsToAdd = i});
                    );
                    beatsToAdd.postln;
                    beatsPerBar = beatsPerBar + beatsToAdd;
                    Pdefn(\accents, Pseq(seq.value(beatsPerBar), 1))
                  },
                  {
                    "Length of bar".postln;
                    (tClock.beatDur*beatsPerBar).postln;
                    ((tClock.beatDur*beatsPerBar)/tClock.beatDur).postln
                  });
            (tClock.beatDur*beatsPerBar).wait;
            player.play(quant: 0, clock: tClock);
          }
    };
  }
#+end_src
   
Example: play one segment
#+begin_src sclang :results none
  var seq = { |length=4|
    { |x=0| x+1; if(x==0, {1.0}, {rrand(0.17, 0.3)})} ! length;
  };
  ~accent.play(quant: 0, clock: TempoClock(10));
  Pdefn(\accents, Pseq(seq.value(30), 1))
#+end_src

Example: Create a accent array and print it.
#+begin_src sclang :results none
  (
  var seq = { |length=4|
    { |x=0| x+1; if(x==0, {1.0}, {rrand(0.1, 0.2)})} ! length;
  };
  seq.value(4).postln;
  )
#+end_src
  
** poly rhythm
#+call: original_snare_two
#+begin_src sclang :results none
~task = { |init_tempo=10, nom=3, denom=4|
~clock = TempoClock(init_tempo);
~denom = Pbind(
\instrument, \snare,
\dur, denom,
\freq, Prand((5000..4000), inf),	
\noiseattack, 0.0001,	
\noiselvl, 0.01,
\noiserel, 0.0005,
\release, 0.001,
\gain, 2,
\osc1, 120,
\osc2, 200,	
\tri, 100,
\length, Prand((10..50)*0.01, inf),		
\out, 0,		
).trace;
~nom = Pbind(
\instrument, \snare,
\dur, nom,
\freq, Prand((5000..4000), inf),
\noiseattack, 0.0001,	
\noiselvl, 0.01,
\noiserel, 0.0005,	
\release, 0.001,
\gain, 2,
\osc1, 100,
\osc2, 200,	
\tri, 200,
\length, Prand((10..50)*0.01, inf),	
\out, 1,	
);
~poly = Ppar([~nom, ~denom]).play(quant: 0, clock: ~clock);
}
#+end_src
#+begin_src sclang :results none
  ~task.value(10, 7, 8);
#+end_src

#+begin_src sclang :results none
  ~clock.stop;
#+end_src
#+begin_src sclang :results none
  ~task.value;
  ~clock.stop;
  ~clock.tempo = 50;
  ~clock.tempo = 440;
  ~clock.beatsPerBar = 9
#+end_src

** harmony
*** harmonic spat synth
**** boot audio
#+begin_src sclang :results none :noweb yes
  <<boot_jack>>;
#+end_src
**** list of global variables
Global variables and semaphhores

- ~~fundamental~  The fundamental pitch from which harmonics are built
- ~~alllRings~  General XY positions of the centerrs of the triangles.
- ~~spatializations~  List of the positions for each ~~audioBus~ that may be updated.
- ~~spatChannels~ Array of Ndefs, channels of VBAP panners  (same size as ~audioBusses~
- ~~spatNdefs~ 
- ~~controlBus~ 
- ~~frequencyBus~  The bus through which the frequency of the impulse is controlled (the \pulse)
- ~~audioBusses~ The channels that outputs audio from the synth.
- ~~spatPositions~ An array of initial spat positions, identified by a reference to the ~allRings~ array.

#+name: global_variables
#+begin_src sclang :results none
  /* Fundamental frequency */
  ~fundamental = 0.2;
  /* The general level of loggging */
  ~logging = 2;
  /* Spatialisation positions */
  ~allRings = [[-24.036688, 23.800417, 0.0, 0.0], [21.279257, 23.800417, 0.0, 0.0], [55.741675, 23.800417, 0.0, 0.0], [101.49442, 23.800417, 0.0, 0.0], [147.91193, 23.800417, 0.0, 0.0], [-167.82013, 23.800417, 0.0, 0.0], [ -123.784, 23.800417, 0.0, 0.0], [-79.887731, 23.800417, 0.0, 0.0], [ 0.247203, 56.476405, 0.0, 0.0], [69.013292, 56.476405, 0.0, 0.0], [158.89992, 56.476405, 0.0, 0.0], [-114.65354, 56.476405, 0.0, 0.0], [-90, 86.424489, 0.0, 0.0], [90, 86.424489, 0.0, 0.0], [0, 90, 0.0, 0.0]];
#+end_src

**** synth
#+name: harmonic_synth
#+begin_src sclang :results none
  (
  SynthDef("test", { arg freq = 440, out = 10, amp = 0.2;
    Out.ar(out, SinOsc.ar(freq, 0, amp));
  }).add;
  )
#+end_src

Main snare synth. The pulse parameter is controlled by the ~pulse_bus~
#+name: snare_phase_multi
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\p_snare, { arg pulse_bus;
    var snd,
    pulse = \pulse.kr(10),
    frq1 = \freq.kr(300),
    frq2 = \freq2.kr(300),
    trifreq = pulse * 3,
    nlevel = LinLin.kr(pulse / 120, 0, 1, 0.1, 0.001);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), nlevel, \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), trifreq);
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add
#+end_src

#+begin_src sclang :results none
  b = Bus.control(s,1).set(10);
  c = Synth.new(\p_snare, [\freq, [100, 200]]);
  c.map(\pulse, b);
  b.set(810);
  b.get.postln;
#+end_src

**** harmonics function
Initialize the arrays for freq/amp for the first 32 harmonics and create audio busses for each Synth that matches the sel array. Loads the synth [[*simple synth][harmonic_synth]].

- sel: Array of partials to play
- fund: Fundamental
- delta: time between notes (only init time)
#+name: harmonics
#+begin_src sclang :results none :noweb yes
  <<harmonic_synth>>;
  <<snare_phase_multi>>;
  f = { arg fund=200, sel = [1,2,3], delta = 0.05, amp_mode = \full, synth_mode = \sin;

    var harmonics, amp, index = 0, noise_level = 0, fbus, nmap;

    /* Fill arrays for pitches */
    harmonics = Array.fill(32, { arg i; (i+1)*fund; });
    switch(amp_mode, 
          \default, {amp = Array.fill(32, { arg i; 1/(i+1); }); },
          /* All harmonics with the same amplitude */	
          \full, {amp = Array.fill(32, { arg i; 0.3; });  },
          \linear, {amp = Array.series(32, 1, -0.03125)},
          \reverse, {amp = Array.series(32, 0.03125, 0.3125)}
    );	

    "Harmonics are loaded:".postln;
    harmonics.postln;

    /* Map frequency to noise level */
    //nmap = ~noiseMap.value;
    g = ControlSpec(0.1, 0.0, \linear, 0.001, 0);
    g.clipHi(0.1);
    g.clipLo(0.0);

    /* Frequency (pulse) control using a Bus */
    ~frequencyBus = Array.new(sel.size);

    /* Run the loop */
    t = Task({
          (0..31).do({ |i|
            var bus, synth;
            if(i == sel[index],
                  {
                    /* audio bus for output */		
                    bus = Bus.audio(s, 1);
                    ~audioBusses.add(bus);

                    /* Control bus for freq control */
                    fbus = Bus.control(s, 1);
                    fbus.value(harmonics[i]);		
                    ~frequencyBus.add(fbus);
                    ~originalFrequencies.add(harmonics[i]);
                    /* This sets the initial nlevel */		
                    noise_level = g.map(harmonics[i] / 120);
                    "pulse: ".post; harmonics[i].postln;		
                    "Noise level: ".post; noise_level.postln;
                    switch(synth_mode,
                          \sin, {			
                            synth = Synth("test", [\pulse, harmonics[i], \amp, amp[i], \out, bus]);
                          },
                          \snare, {
                            synth = Synth.new(\p_snare, [
                                  \bus, fbus,
                                  \pulse, harmonics[i],
                                  \length, 1,
                                  \freq, harmonics[i]/10,
                                  \freq2, harmonics[i]/2,
                                  \trifreq, harmonics[i] /20,
                                  \nlevel, noise_level,
                                  \out, bus,
                                  \gain, amp[i]]);
                            synth.map(\pulse, fbus);
                          }); //switch

                    if(~logging > 0,
                          {			
                            Post << "Harmonic " <<< i << ": " <<< harmonics[i] <<  ", " <<< amp[i] << " at noise level " << noise_level <<< " at Audio bus " <<< bus.index << Char.nl;
                            index = index + 1; i.postln;
                          },
                          { }); //if
                    ~synths.add( synth ); // synths.add
                  }, //if true
                  {  }); // false, end
            delta.wait;
          });
    });
    /* Return the task */
    t;
  };
#+end_src

#+begin_src sclang :results none
  ~synths[0].get(\freq).postln;
#+end_src

Function to map frequency to noise level
#+name: noise_map
#+begin_src sclang :results none
  ~noiseMap = { arg val;
    ~noiseMapSpec.map(val / 120).postln
  };
  ~noiseMap.value(119);
#+end_src

ControlSpec for the mapping between frequency and noise level
#+name: noise_mapping_spec
#+begin_src sclang :results none
  ~noiseMapSpec = ControlSpec(0.1, 0.0, \linear, 0.001, 0);
  ~noiseMapSpec.clipHi(0.1);
  ~noiseMapSpec.clipLo(0);
#+end_src

#+begin_src sclang :results none
  { LinLin.kr(1, 0, 1, 0.1, 0.0); }.plot
#+end_src
**** reverb
Load reverb
#+name: load_reverb
#+begin_src sclang :results none :noweb yes
  <<reverb_ndef>>
  <<reverb_specs>>
  <<reverb_panning>>
  <<connect_reverb>>
#+end_src

#+name: reverb_specs
#+begin_src sclang :results none
  Spec.add(\t60, [0.1, 60, \exp]);
  Spec.add(\damp, [0, 1]);
  Spec.add(\size, [0.5, 3]);
  Spec.add(\earlydiff, [0, 1]);
  Spec.add(\mdepth, [0, 50]);
  Spec.add(\mfreq, [0, 10]);
  Spec.add(\lowx, [0, 1]);
  Spec.add(\midx, [0, 1]);
  Spec.add(\highx, [0, 1]);
  Spec.add(\lowband, [100, 6000, \exp]);
  Spec.add(\highband, [1000, 10000, \exp]);
#+end_src

Load the reverb
#+name: reverb_ndef
#+begin_src sclang :results none
  Ndef(\reverb, {
    var src = In.ar(~reverbSendBus.index) * \amp.kr(1);
    src = JPverb.ar(
          src,
          \t60.kr(1,           0.05),
          \damp.kr(0,          0.05),
          \size.kr(1,          0.05),
          \earlydiff.kr(0.707, 0.05),
          \mdepth.kr(5,        0.05),
          \mfreq.kr(2,         0.05),
          \lowx.kr(1,          0.05),
          \midx.kr(1,          0.05),
          \highx.kr(1,         0.05),
          \lowband.kr(500,     0.05),
          \highband.kr(2000,   0.05)
    );
  });
#+end_src

Reset the two example Ndefs
#+begin_src sclang :results none
  Ndef(\reverb).clear;
  Ndef(\reverbPanning).clear;
#+end_src

#+name: reverb_panning
#+begin_src sclang :results none
  Ndef(\reverbPanning, {
    var src = \input.ar;
    PanX.ar(16, src, \revPanPos.kr(0), \revPanAmp.kr(1), \revPanSpread.kr(64));
  }).mold(16);
#+end_src

Connect the source to the reverb.
#+name: connect_reverb
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 1;
  Ndef(\reverbPanning).play(addAction: \addToTail);
  Ndef(\reverbPanning) <<>.input Ndef(\reverb);
  Ndef(\reverb).set(\t60, 0.7);
  Ndef(\reverb).set(\size, 0.2);
  Ndef(\reverb).set(\amp, 0.5);
  Ndef(\reverb).set(\earlydiff, 0.1);
  Ndef(\reverb).set(\mdepth, 1);
  Ndef(\reverbPanning).set(\revPanSpread, 64);
#+end_src

Start the two Ndefs (and stop)
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 5;
  Ndef(\reverbPanning).play;
  Ndef(\reverbPanning).stop;
  Ndef(\reverb).play;
  Ndef(\reverb).stop;
  Ndef(\reverbBus).play;
  Ndef(\reverbBus).stop;
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).set(\revPanSpread, 64);
  Ndef(\reverbPanning).set(\revPanAmp, 0.7);
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).scope;
#+end_src
**** generate harmonics
Initialize global variable ~~allRings~. Loads and calls the function defined in [[*harmonics function][harmonics function]] and plays it. The ~sel~ array defines the partials to be played. If this is three items long, the array of corresponding synths initatilzed in [[*harmonics function][harmonics function]] will be three.

After calling this, call [[*spatialisation][spatialisation]]: make_vbap to play the busses on the speakers.

- ~select~: The harmonics to play
- ~~spatPositions~: The angles for each audio bus (needs to be of equal length to ~sel~). These are initialized at the same time that the partials are selectd.

_1. Load this_

Function that loads ~global_variables~, ~all_rings~, ~harmonics~. It also initializes the ~~spatialisations~, however only the first value, azimuth. The following three 

#+name: generate_harmonics
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  (
  var select, task, mode = \dual;
  <<global_variables>>
  <<all_rings>>
  <<harmonics>>

  switch(mode,
    \full, {
          select = [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31];
          ~spatPositions = [0,1,5,6,3,2,7,4,9,11,8,10,12,13,14];
          "Full mode".postln;		
    },
    \dual, {
          select = [7, 9];
          ~spatPositions = [4,6];
          "Dual mode".postln;	
    }); // switch mode

  if(~logging > 1,
    {
          "Select array is ".post; select.size.postln;
          "Spat array is ".post; ~spatPositions.size.postln; },
    { }); //if clause

  /* Holds the busses */
  ~audioBusses = Array.new(select.size);
  /* Holds the synths */
  ~synths = Array.new(select.size);
  /* Holds the original frequency for each bin */
  ~originalFrequencies = Array.new(select.size);
  /* Holds the spat positions for each note, imported from ~allRings */
  ~spatializations = Array.new(~spatPositions.size);

  if(select.size == ~spatPositions.size,
    {
          if(~allRings.size >= ~spatPositions.size,
            {	
                  i = 0;	
                  while( {i < ~spatPositions.size},
                    { ~spatializations.add(~allRings[~spatPositions[i]]);
                          if(~logging > 1,
                            { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; }, { }); // if clause
                          i = i + 1;
                    }); // while clause
            }, { }); // if clause
    },
    { "'sel' and 'spat' have unequal number of elements".postln; }); // if clause

  /* Call the harmonics function and play it.*/
  task = f.value(~fundamental, select, 0.1, \full, \snare);
  task.play;
  )
#+end_src

Use this to re-initialize the spatialisations array. 
#+name: reinit_spatialisations
#+begin_src sclang :results none
  if(~allRings.size >= ~spatPositions.size,
    {	
          i = 0;	
          while( {i < ~spatPositions.size},
            { ~spatializations.add(~allRings[~spatPositions[i]]);
                  if(~logging > 1,
                    { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; },
                    { }); // if clause
                  i = i + 1;
            }); // while clause
    },
    { }; // if clause
  );
#+end_src
**** spatialisation
Spatialisation angles for three rings in triangles.

_1. Load all_
#+call: generate_harmonics()
#+call: make_vbap()
#+call: init_spatialization()
#+call: load_reverb()
#+call: show_meter()
#+call: free_all()

#+begin_src sclang :results none :noweb yes
  <<show_meter>>
#+end_src
_2. Load this_
Call this after running [[*generate harmonics][generate harmonics]] to start the spatialisation of the harmonics. It creates the VBAP instances (inside a Ndef) stored in ~~spatNdefs~. It also fills the ~~controlBus~ array with three channel busses for the control of azimuth, elevation and distance respectively.

The functions controlling panning are here: [[inter_pan][inter_pan]].
#+name: make_vbap
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  var revMap;
  <<vbap_speaker_array>>
  ~spatChannels = Array.new(~audioBusses.size); // Unused
  ~spatNdefs = Array.new(~audioBusses.size);
  ~reverbSendNdefs = Array.new(~audioBusses.size);
  ~reverbBus = Array.new(~audioBusses.size);
  ~controlBus = Array.new(~audioBusses.size);
  ~reverbSendBus = Bus.audio(s, 1);
  revMap = \sin.asWarp;
  ~audioBusses.do({ arg bus, i;
    o = "reverbBus" ++ i.asString.asSymbol;
    m = "ch" ++ i.asString.asSymbol;
    n = Bus.control(s, 4);
    ~controlBus.add(n);
    ~spatNdefs.add(
          Ndef.new(m, { arg src, azi = 0, ele = 0, spr = 0, dist = 0;
            src = In.ar(bus);
            azi = In.kr(n);
            ele = In.kr(n.index + 1);
            dist = LinLin.kr( In.kr(n.index + 2).squared, 0, 1, 1, 0.00001);
            spr = In.kr(n.index + 3);   
            src = src * dist;
            VBAP.ar(29, src, ~spkrBuffer.bufnum, In.kr(n), In.kr(n.index + 1), spr)});
    );
    ~reverbSendNdefs.add(
          Ndef(o, {
            var src;
            src = In.ar(bus) * In.kr(n.index + 2) * \revScaleI.kr(0.62);
            src = src * (revMap.map(In.kr(n.index + 2) + 1) * \revScaleII.kr(0.62));
            Out.ar(~reverbSendBus.index, src)
          });
    );	
    Ndef(m).fadeTime(1);
    Ndef(m).play(addAction: \addToTail);
    Ndef(o).play(addAction: \addToTail);});
  <<inter_pan>>
  <<update_panning>>
  <<reset_freqs>>
#+end_src

Function to start and stop individual nodes
#+name: play_control
#+begin_src sclang :results none
  var playControl = { arg index = 0, message = 0;
    if(index < ~spatNdefs.size,
          {
            case
            { message == \stop } { ~spatNdefs[index].stop; }
            { message == \play } { ~spatNdefs[index].play; };
          },
          { 
            "The index is outside of the size of thhe ~spatNdefs".postln;	
          });
  };
  playControl.value(0, \play);
#+end_src

Set the reverb
#+begin_src sclang :results none
  var setMe = 0.62;
  ~reverbSendNdefs[0].set(\revScaleI, setMe);
  ~reverbSendNdefs[0].set(\revScaleII, setMe);
  ~reverbSendNdefs[1].set(\revScaleI, setMe);
  ~reverbSendNdefs[1].set(\revScaleII, setMe);
#+end_src

#+begin_src sclang :results none
  ~spatNdefs[1].set(\spr, 0);
#+end_src

Set individual controlbusses
#+begin_src sclang :results none
  //  ~controlBus[0].getn(4, { arg n; n[3].postln; });
  ~controlBus[0].getnSynchronous(4)[3].postln;
  //  ~controlBus[1].getnSynchronous(4);
  ~controlBus[0].setn([147, 23, 0, 0]);
#+end_src

Control individual synths pulse.
#+begin_src sclang :results none
  var pulse = 10, synth = 0;
  ~synths[synth].set(\pulse, 2);
  ~synths[synth].get(\pulse, {arg item; item.postln; });
#+end_src

Set all synths parameter to a value.
#+begin_src sclang :results none
  ~updateSynths = { arg parameter = \trifreq, value = 100;
    var changeAll = ~synths.do({ arg item, i;
          item.set(parameter, value);
          "Setting ".post; parameter.post; " to ".post; value.postln;
    });
  };
  ~updateSynths.value(\nlevel, 0.1);
#+end_src

Set all spatNdefs parameter to a value.
#+begin_src sclang :results none
  ~updateVBAP = { arg parameter = \trifreq, value = 0;
    var changeAll = ~spatNdefs.do({ arg item, i;
          item.set(parameter, value);
          "Setting ".post; parameter.post; " to ".post; value.postln;
    });
  };
  ~updateVBAP.value(\spr, 0);
#+end_src

#+begin_src sclang :results none
  s.reboot;
#+end_src

#+begin_src sclang :results none
  ~reverbSendBus.scope;
#+end_src

#+begin_src sclang :results none
  ~controlBus[0].getnSynchronous(4)[3].scope;
#+end_src

Gradually increase parameter in one synth.
#+begin_src sclang :results none
  var speeder;
  speeder = { arg instance = 0, range = (3..200), delta = 0.5, param = \freq;
    var interpolate;
    interpolate = Task({
          range.do({ arg index;
            ~synths[1].set(param, index);
            delta.wait;	
          });
    });
    interpolate.play;
  };
  speeder.value(0, (150..190), 0.05, \freq);
#+end_src

Interpolate one pulse bus.
#+name: interpolate_pulse
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulseSingle = { arg int, bus, astart, aend, dur;
    {Out.kr(bus, Line.kr(astart, aend, dur, doneAction: 2))}.play(addAction: \addToHead);
  };
  ~interpolatePulseSingle.value(0, ~frequencyBus[0], 3, 1, 10);
#+end_src

Interpolate all busses. Call this from [[pulse_interpolate_array][pulse_interpolate_array]], that creates an array of values for pulse modulation and interpolation.
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulse = { arg map;
    map.rowsDo({ arg obj, i;
          if(~logging > 1,
            { 
                  "Starting envelope for item ".post; i.post; " from ".post; obj[0].post; " to ".post; obj[1].post; " in ".post; obj[2].post; " seconds.".postln;						
            }, { });
          {Out.kr(~frequencyBus[i], Line.kr(obj[0], obj[1], obj[2], doneAction: 2))}.play(addAction: \addToHead);
    });
    map;};
  /* Interpolate all busses by the same value */
  //  ~interpolatePulse.value(10, 1, 10);
#+end_src

Create an array of arrays, each with a start, end and dur parameter.
#+name: pulse_modulation
#+begin_src sclang :results none
  ~modulateSpeed = { arg mult = 2, dur = 2, end = 100, mode = 0;
    var mod_map = Array2D.new(~spatNdefs.size, 3);
    mod_map.rowsDo({ arg obj, i;
          mod_map[i,0] = ~frequencyBus[i].getSynchronous;
          switch(mode,
            0, {	
                  mod_map[i,1] = ~frequencyBus[i].getSynchronous * mult * ((i * 0.5) + 1);
            },		
            1, {
                  mod_map[i,1] = end;
            });
          mod_map[i,2] = dur;
    });
  };
  //  ~modulateSpeed.value(2, 2, 200, 0).postln;
  //  ~interpolatePulse.value(mod_map);
#+end_src

Build an array of arguments for the interpolation of the pulse frequence of the instruments. This is always relative to the current pulse frequency. Arguments are:
- ~mult~ multiplier for each iteration in the array
- ~duration~ the duration of the interpolation
- ~end~ end value (only for mode 1)
- ~mode~ the mode of the transformation: 0 = modulation map using the index and multiplier, 1 = linear map using end value for the modulation.
#+name: pulse_interpolate_array
#+begin_src sclang :results none
  ~interpolatePulse.value(~modulateSpeed.value(2, 20, 3, 1));
#+end_src

Create an array and interpolate the pulse frequence of the instruments.
#+begin_src sclang :results none :noweb yes
  <<pulse_modulation>>
  <<interpolate_pulse>>
  ~pulsePresets = { arg preset = 0;
    switch(preset,	
          1, {~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 50, 2, 20, 2000, 2])); },
          2, {~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 2, 20, 20, 2]));},
          3, {~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 6, 1]));},
          4, {~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 4, 1]));},
          5, {~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 5, 1, 1, 6]));},
          6, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [2, 32, 30, 1.5, 24, 30]));
            ~setSpatialization.value(\nther, 20);   
          },  
          7,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 20, 2, 1.5, 15]));
            ~setSpatialization.value(\sine, 15);
          },
          8,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [6, 100, 40, 2, 160, 45]));
            ~setSpatialization.value(\sine, 40);
          },
          9,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [100, 200, 40, 160, 6, 45]));
            ~setSpatialization.value(\simple, 40);
          },      
          10,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 5, 20, 2, 2]));
            ~setSpatialization.value(\simple, 5);   
          };	
    ) // switch
  };
  ~pulsePresets.value(1);
#+end_src

#+begin_src sclang :results none
  Array2D.fromArray(2, 3, [1, 5, 2, 20, 20, 2]).postln;
#+end_src

Set and get a bus' value:
#+begin_src sclang :results none
  //  ~frequencyBus[1].set(1);
  ~frequencyBus[1].getSynchronous.postln;
#+end_src

Reset original pulse frequencies.
#+name: reset_freqs
#+begin_src sclang :results none
  ~reset_freqs = { arg index = 0, mode = \all;

    if( (index != 0) && (mode == \all),
          {
            "If mode is = \all, index must be 0".postln;
            index = 0;
          }, { });

    switch(mode,
          \all, {
            ~frequencyBus.do({ arg bus, i;
                  "Setting voice ".post; i.post; " to original frequency: ".post; ~originalFrequencies[i].postln;
                  ~frequencyBus[i].set(~originalFrequencies[i]);
            });
          },
          \single, {
            "Setting voice ".post; index.post; " to original frequency: ".post; ~originalFrequencies[index].postln;
            ~frequencyBus[index].set(~originalFrequencies[index]);
          });
  };
  ~reset_freqs.value(0, \all);
#+end_src

#+begin_src sclang :results none
  ~originalFrequencies[0].postln;
#+end_src

#+begin_src sclang :results none
  ~updatePanning.value(5);
#+end_src

Function for generating the lines for the panning modulation using azimuth, elevation and distance.
#+name: inter_pan
#+begin_src sclang :results none  :tangle harmony.sc
  ~interPan = { arg bus, astart, aend, estart, eend, dstart, dend, sstart, send, dur;
    {Out.kr(bus.index, Line.kr(astart, aend, dur, doneAction: 2))}.play(addAction: \addToHead);
    {Out.kr(bus.index + 1, Line.kr(estart, eend, dur, doneAction: 2))}.play(addAction: \addToHead);
    {Out.kr(bus.index + 2, Line.kr(dstart, dend, dur, doneAction: 2))}.play(addAction: \addToHead);
    //          {Out.kr(bus.index + 3, Line.kr(sstart, send, dur, doneAction: 2))}.play(addAction: \addToHead);
    if(~logging > 1,
          {
            "Azimuth from ".post; astart.post; " to ".post; aend.postln;
            "Elevation from ".post; estart.post; " to ".post; eend.postln;
            "Distance from ".post; dstart.post; " to ".post; dend.postln;
            "Spread from ".post; sstart.post; " to ".post; send.postln;	   
          }, { });
  };
#+end_src

~update_panning~ is called to update panning positions in the ~spatNdefs~ arrays. The actual modulation happens in [[inter_pan_full][inter_pan]]. The function takes one argument:
- ~duration~: The interpolation time.
#+name: update_panning
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  <<inter_pan>>
  ~updatePanning = { arg duration;
    ~spatNdefs.do({ arg channel, i;
          ~spatializations[i].postln;	
          ~interPan.value(~controlBus[i],
            ~controlBus[i].getnSynchronous(3)[0], ~spatializations[i][0],
            ~controlBus[i].getnSynchronous(3)[1], ~spatializations[i][1],
            ~controlBus[i].getnSynchronous(3)[2], ~spatializations[i][2],
            //                          ~controlBus[i].getnSynchronous(4)[3], ~spatializations[i][3],
            0, ~spatializations[i][3],   
            duration);
    }); // end of spatNdefs.do
  }; //end of function
#+end_src

#+begin_src sclang :results none
  ~controlBus[1].getnSynchronous(3)[0].postln;
#+end_src
#+begin_src sclang :results none
  ~spatializations[1].postln;
#+end_src
#+begin_src sclang :results none
  ~updatePanning.value(5);
#+end_src

_3 Setting spatialization_

Loads necesary auxilliary functions and copies over the positions according to the ~spat_array~ argument. If provided it should be an array (length equal to the number of spat channels) of arrays, each of which is an array with [azimuth, elevation, distance and spread]. It calls ~~updatePanning~ before exiting. The function takes one arguments:
- ~spat_array~: An array of arrays with he indexes in the ~~allRings~ array to be copied over, the distancs and the spread.
#+name: set_spatialization
#+begin_src sclang :results none :noweb yes  :tangle harmony.sc
  <<spat_function>>
  <<update_panning>>
  ~setSpatPositions = { arg spat_array;
    ~spatializations.do({ arg item, i;
          var pos;
          /* Get the x/y position */	
          if(spat_array.size == 0,
            {
                  /* The call to ~setSpatPositions was done without an argument */
                  pos = ~spatializations.at(i);
                  if(~spatializations.at(i).size < 4,
                    {
                          pos.extend(4, 0);      
                    },
                    {
                    });      
            }, 
            {
                  /* The call to ~setSpatPositions was done with an argument */
                  pos = ~allRings.wrapAt(spat_array.wrapAt(i)[0]);
                  pos.put(2, spat_array.wrapAt(i)[1]);
                  pos.put(3, spat_array.wrapAt(i)[2]);
                  pos.postln;    
            }); /* End of if(spat_array.size) */
          /* update the distance parameter */
          pos.postln;  
          ~spatializations.put(i, pos);
          if(~logging > 1,
            {
                  "Set panning:".postln;
                  "Putting spat angles ".post;  pos[0].post; "/".post; pos[1].post; " at index ".post; i.post; " with distance ".post; pos[2].post; " and spread ".post; pos[3].postln;
            }, { }); // if logging
    }); // spatialilzation.do
    ~updatePanning.value(10);
  };
#+end_src

#+name: init_spatialization
#+begin_src sclang :results none :noweb yes
  <<set_spatialization>>
  ~setSpatPositions.value();
#+end_src
#+begin_src sclang :results none
  ~spatializations.at(0).size.postln;
#+end_src

Change spatialization. Spat is controlled by an arbitrary length array that points to one of the 14 (0-13) speaker positions available. Use the ~spat_function~ to create new presets.
#+begin_src sclang :results none
  ~setSpatialization.value(\distanceO, 10);
  ~setSpatialization.value(\distanceI, 5);
#+end_src

#+begin_src sclang :results none
  ~setSpatialization.value(\simple, 5);
#+end_src

#+begin_src sclang :results none
  var dist = 0.5, pos;
  pos = ~allRings.wrapAt([0,10].wrapAt(0));
  pos.put(2, dist);
#+end_src
#+name: spat_function
#+begin_src sclang :results none
  ~setSpatialization = { arg preset, time;
    switch(preset,
          \simple, { ~setSpatPositions.value([[0, 0.0, 90.0], [5, 0.0, 80.0]]); },
          \distanceI, { ~setSpatPositions.value([[0, 0.0], [1, 0.0]]); },
          \distanceO, { ~setSpatPositions.value([[0, 1], [1, 1]]); },
          \nther, { ~setSpatPositions.value([[3, 0.1], [0, 0.6]]); },
          \sine, { ~setSpatPositions.value([[0.0, 0.1], [2.0, 0.2], [4.0, 0.3], [6.0, 0.4], [7.0, 0.3], [9.0, 0.3], [10.0, 0.2], [12.0, 0.1], [13.0, 0.1], [13.0 , 0.1], [ 13.0, 0.1], [ 13.0, 0.1], [ 3.0, 0.1], [13.0 , 0.1], [12.0, 0.1], [10.0, 0.1], [9.0 , 0.1], [7.0, 0.1], [6.0, 0.1], [4.0, 0.1], [2.0, 0.1]]); },
          \frontTop, { ~setSpatPositions.value([[9, 0.3], [12, 0.4], [9, 0.3], [12, 0.3],[9, 0.3],[12, 0.3],[9, 0.3],[12, 0.3],[8, 0.3],[9, 0.3]]); },
          \back, { ~setSpatPositions.value([6,5,4,3,3,4,5,6,11,10,11,10,11,10,11]); },
          \allInOne, { ~setSpatPositions.value(Array.fill(15, { arg i; 1; })); },
          \random, { ~setSpatPositions.value(Array.rand(~spatializations.size, 0, 14)); });
  };
#+end_src

_4. Free all_
Free all busses and stop execution
#+name: free_all
#+begin_src sclang :results none :noweb yes
  <<free_busses>>
  Ndef(\reverbBus).clear;
  Ndef(\reverb).clear;
  CmdPeriod.run;
#+end_src

Reboot Supercollider
#+begin_src sclang :results none
  s.reboot;
#+end_src

Show meter
#+name: show_meter
#+begin_src sclang :results none
  s.meter;
#+end_src

Plot tree
#+name: plot_tree
#+begin_src sclang :results none
  s.plotTree
#+end_src
--------------------------------

#+begin_src sclang :results none
  ~audioBusses[1].scope;
#+end_src

#+name: spat_list
#+begin_src scheme :var mult=0.01 :noweb yes :results output
  <<sequenced_array>>
  (map (lambda (x)
         (format #t "~a, " (truncate (* x 14))))
       (seq-array-sin 0 21 (list)))
#+end_src

#+RESULTS: spat_list
: ice-9/boot-9.scm:1669:16: In procedure raise-exception:
: Unbound variable: seq-array-sin
: 
: Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
: scheme@(guile-user) [1]> 

***** spkrBuffer settings
The argument to ~VBAPSpeakerarray~ is ~3~ for 3D and an array of arrays of angle/elevation pairs:
#+name: vbap_speaker_array
#+begin_src sclang :results none :tangle harmony.sc
  ~spkrArray = VBAPSpeakerArray.new(3, [[ -34.689614 , 12.910417 ], [ -13.383763 , 12.910417 ], [ 10.440725 , 12.910417 ], [ 32.117788 , 12.910417 ],
    [ 55.741675 , 12.910417 ], [ 78.207673 , 12.910417 ], [ 101.49442 , 12.910417 ], [ 124.85167 , 12.910417 ],
    [ 147.91193 , 12.910417 ], [ 169.17789 , 12.910417 ], [ -167.82013 , 12.910417 ], [ -145.63454 , 12.910417 ],
    [ -123.784 , 12.910417 ], [ -102.64182 , 12.910417 ], [ -79.887731 , 12.910417 ], [ -57.926139 , 12.910417 ],
    [ -22.349553 , 34.696822 ], [ 22.843958 , 34.696822 ], [ 69.013292 , 34.696822 ], [ 115.56544 , 34.696822 ],
    [ 158.89992 , 34.696822 ], [ -158.89763 , 34.696822 ], [ -114.65354 , 34.696822 ], [ -68.170128 , 34.696822 ],
    [ -45 , 69.185799 ], [ 45 , 69.185799 ], [ 135 , 69.185799 ], [ -135 , 69.185799 ], [ 0 , 90 ]]);
  ~spkrArray.speakers[1].dump;
  ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
#+end_src

***** test with Synthdef
#+begin_src sclang :results none
  Synth.new(\vbap_panning, [\bus, ~audioBusses[0], \spkr_buffer, ~spkrBuffer.bufnum, \azimuth, 0, \elevation, 0, \spread, 0], addAction: \addToTail);
#+end_src

#+begin_src sclang :results none
  SynthDef(\vbap_panning, { var input, snd, bus;
    bus = \bus.kr;
    input = In.ar(bus);
    snd = VBAP.ar(29,
          input,
          \spkr_buffer.ir,
          \azimuth.kr(0),
          \elevation.kr(0),
          \spread.kr(0));
    Out.ar(0, snd);
  }).add;
#+end_src

**** free busses
#+name: free_busses
#+begin_src sclang :results none
  ~freeAllBusses = {
    var int = 0;
    if(~audioBusses.size == 0,
          { "Array is empty".postln },
          {
            while({ int < ~audioBusses.size }, {
                  if(~audioBusses[int].index == nil,
                    { "Bus cleared already".postln; },
                    {		
                          "Clearing bus ".post; ~audioBusses[int].index.postln;
                          ~audioBusses[int].free;
                          ~frequencyBus[int].free;			
                          ~controlBus[int].free;
                          ~synths[int].free;			
                    });		
                  int = int + 1;
            });
          })
  };
  ~freeAllBusses.value();

  ~freeNdefs = {
    Ndef.clear(0);
  };
  ~freeNdefs.value();
#+end_src
**** alternative stuff
Interpolate over pan values by means of Task
#+name: interpolator
#+begin_src sclang :results none 
  ~interpolator = { arg instance = 0, range = (0..180), delta = 0.05, param = \azi;
    var interpolate;
    interpolate = Task({
          range.do({ arg index;
            p = index;
            ~spatNdefs[instance].set(param, p);
            delta.wait;	
          });
    });
    interpolate;
  };
#+end_src

Set all channels' panning positions using the Task above.
#+begin_src sclang :results none
  ~spatNdefs.do({ arg channel, i;
    var ae, as, es = 0, ee = 1;
    as = channel.get(\azi);
    es = channel.get(\ele);
    ae = ~spatializations[i][0];
    ~interpolator.value(i, (as..ae), 0.1, \azi).play;
    ~interpolator.value(i, (es..ee), 0.1, \ele).play;
    //          "Angles are set to ".post; ae.postln;
    channel.set(\ele, ~spatializations[i][1]);
  });
#+end_src

Example calls for the ~~interpolator~ function.
#+begin_src sclang :results none
  q = ~interpolator.value(0, (0..180), 0.1).play;
  p = ~interpolator.value(1, (180..0), 0.1).play;
#+end_src

Fill the ~~spatializations~ array with random indexes.
#+begin_src sclang :results none :noweb yes
  var delta = 0.5;
  Task({
    (1..64).do({ arg index;
          var ~spatPositions =  Array.rand(12, 0, 13);
          ~spatializations.do({ arg item, i;
            ~spatializations.put(i, ~allRings[~spatPositions[i]]);
            "Putting ".post;  ~spatPositions[i].post; " at index ".post; i.postln;
          });
          ~spatChannels.do({ arg channel, i;
            channel.set(\ele, ~spatializations[i][0], \ele, ~spatializations[i][1]);
          });
          delta.wait;	
    });
  }).play;
#+end_src
*** reverb
Create Specs for the reverb parameters. Not sure if this is needed?
#+begin_src sclang :results none
  Spec.add(\t60, [0.1, 60, \exp]);
  Spec.add(\damp, [0, 1]);
  Spec.add(\size, [0.5, 3]);
  Spec.add(\earlydiff, [0, 1]);
  Spec.add(\mdepth, [0, 50]);
  Spec.add(\mfreq, [0, 10]);
  Spec.add(\lowx, [0, 1]);
  Spec.add(\midx, [0, 1]);
  Spec.add(\highx, [0, 1]);
  Spec.add(\lowband, [100, 6000, \exp]);
  Spec.add(\highband, [1000, 10000, \exp]);
#+end_src

Reset the two example Ndefs
#+begin_src sclang :results none
  Ndef(\reverbBus).clear;
  Ndef(\reverb).clear;
#+end_src

Load the source for the reverb.
#+begin_src sclang :results none
  Ndef(\src, {
    Splay.ar(Impulse.ar([1, 3, 5, 7, 9, 11]).scramble);
  });
#+end_src

Backup
#+name: reverb
#+begin_src sclang :results none
  Ndef(\reverb, {
    var src = \input.ar * \amp.kr(1);
    src = JPverb.ar(
          src,
          \t60.kr(1,           0.05),
          \damp.kr(0,          0.05),
          \size.kr(1,          0.05),
          \earlydiff.kr(0.707, 0.05),
          \mdepth.kr(5,        0.05),
          \mfreq.kr(2,         0.05),
          \lowx.kr(1,          0.05),
          \midx.kr(1,          0.05),
          \highx.kr(1,         0.05),
          \lowband.kr(500,     0.05),
          \highband.kr(2000,   0.05)
    );
  });
#+end_src

Start the two Ndefs (and stop)
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 1;
  Ndef(\reverb).play;
  Ndef(\src).play;
  Ndef(\src).stop;
  Ndef(\reverb).set(\t60, 0.1);
#+end_src

Connect the source to the reverb.
#+begin_src sclang :results none
  var src = Ndef(\reverb) <<>.input Ndef(\src);
  Out.ar(0, src.at(0!1));
#+end_src

#+begin_src sclang :results none
  var src;
  src = { [SinOsc.ar(440, 0, 0.3), SinOsc.ar(300, 0, 0.3)] };
  src.play(outbus: 2);
#+end_src
** osc
*** set netaddress to 'b'
#+name: set_netaddress
#+begin_src sclang :results none
  b = NetAddr.new("127.0.0.1", 5510);
#+end_src
*** routine to play 10 hits
#+begin_src sclang :results none :noweb yes
  <<set_netaddress()>>
  // the value can also be a stream or a function
  (
  r = Routine {
    10.do( { 
          b.sendMsg("/o_dispersed_snare/impulse/play", 1);
          0.01.wait;
          b.sendMsg("/o_dispersed_snare/impulse/play", 0);
          0.1.wait;
    });
  }.play;
  );
#+end_src
*** task in loop
#+begin_src sclang :results none
  b = NetAddr.new("127.0.0.1", 5510);
  t = Task({ { 
    b.sendMsg("/o_dispersed_snare/impulse/play", 1);
    0.01.wait;
    b.sendMsg("/o_dispersed_snare/impulse/play", 0);
    1.wait;
  }.loop });
  t.start;
#+end_src
#+begin_src sclang :results none
  t.stop;
#+end_src
*** pbind for osc
Sending OSC messages from a Pbind.
#+begin_src sclang :results none
  (
  ~play = Pbind(
    \dur, 1,
    \odur, Pfunc {|ev| b.sendMsg("/o_dispersed_snare/impulse/play", 1)},
    \sdur, Pfunc {|ev| b.sendMsg("//o_dispersed_snare/impulse/play", 0)}
  ));

  ~play.play;
#+end_src
*** definition of ~play
This is made to deal with the faust 'gate' not resetting itself.
Set the netaddress and register the routine.
#+name: set_play
#+begin_src sclang :results none
  (
  ~play = {
    1.do{
          b.sendMsg("/o_dispersed_snare/impulse/play", 1);
          0.01.wait;
          b.sendMsg("/o_dispersed_snare/impulse/play", 0);
    }
  }
  )
#+end_src
Play the routine above:
#+begin_src sclang :results none
  ~play.fork
#+end_src
#+name: set_play_dep
#+begin_src shell :results none :noweb yes
  <<set_netaddress()>>
  <<set_play()>>
#+end_src
*** play routine 1
Depends on [[*deal with faust 'gate'][deal with faust 'gate']]
#+begin_src sclang :results none
  (
  r = Routine {
    0.5.idle(2);
    0.25.idle(2);
    0.125.idle(2);
    0.0625.idle(2);
  };
  fork {
    loop {
          var rest = r.value;
          rest.postln;
          ~play.fork;
          rest.wait;
    }
  }
  );
#+end_src
*** play routine 2
Parameters are:
1. a scaling factor (default to one)
2. the number of notes to play.
   Depends on the definition of ~~play~      
   #+begin_src sclang :results none :noweb yes
     <<set_play()>>
     <<p_random_rhythm_rout()>>
     <<p_random_rhythm()>>
   #+end_src
   #+name: p_random_rhythm_rout
   #+begin_src sclang :results none :noweb yes
     (
     l = Routine { arg in=1, reps=10;
       var length = 1;
       p = Prand([0.5, 0.25, 0.125, 1], inf);
       q = p.asStream;
       50.do { |i=0|
             q.next.postln;
             length = q.next * in;
             b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [200, 300, 400].choose);
             b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [210, 320, 440].choose);
             ~play.fork;
             q.next.wait;
       }
     }
     )
   #+end_src
   #+name: p_random_rhythm 
   #+begin_src sclang :results none
     l.play.value(1, 100);
   #+end_src
*** play routine 3
#+begin_src sclang :results none
  (
  var osc1freq = Array.fill(10, { (100.rand*2)+100 });
  ~playme = Pbind(
    \dur, Prand([0.1, 0.15, 0.05, 0.2, 0.25, 0.3], inf),
    \play, Pfunc({[~play.fork, ~play.fork]}),
    \osc1f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [ 190, 174, 178, 204, 138, 218, 232, 222, 276, 158 ].choose)}),
    \osc2f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [200, 300, 400, 500, 450, 350, 250, 150].choose)}),
    \noise_rel, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_rel", 0.1.linrand + 0.012 )}),
    \noise_lvl, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_lvl", 0.5.linrand + 0.012 )}),
    \noise_attack, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_attack", 0.1.linrand )}),
  ).play;
  )
#+end_src

*** play routine 4
#+begin_src sclang :results none
  (
  var durs = Array.new(64);
  a = (1!4);
  b = (0.5!8);
  c = (0.25!16);
  d = (0.125!32);
  durs = a ++ b;
  durs = durs ++ c;
  durs = durs ++ d;
  ~playme = Pbind(
    \dur, Pseq(durs, inf),
    \play, Pn(Pfunc({~play.fork}), inf)
  ).play;
  )
#+end_src
** archive
Synth that is driven by an Impulse pulse generator.
Load first the two SynthDefs below and use a global variable of ~isnare for the snare synth:
#+begin_src sclang :results none
  (
  // Here is where the bus object is created in a global variable:
  ~controlBus_1 = Bus.control(s, 1);
  SynthDef(\isnare, { | outBus=0, inBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0 |
    var snd;
    var trig = In.ar(~impBus.index, 1);
    snd = IDispersedSnare.ar(trig, position, disperse, osc_1_freq: osc1, osc_2_freq: osc2, triangle_freq: tri) * gain;
    Out.ar(outBus, snd);
  }).add;

  SynthDef(\impulseA, { | effectBus=0, freq=1 |
    var outB;
    // Only to automatically free each instance
    var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
    outB = Impulse.ar(freq);
    Out.ar(~impBus.index, outB);
  }).add;

  SynthDef(\control_synth, { | bus |
    Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
  }).send(s);
  )
#+end_src

... and then instantiate the main synth:
#+name: isnare_load
#+begin_src sclang :results none
  ~sisnare = Synth.new("isnare", [\cBus, ~controlBus_1.index, \disperse, 0] );
#+end_src

Play one single shot:
#+begin_src sclang :results none
  ~impulse = Synth.before(~sisnare, "impulseA", [\freq, 0]);
  ~c_synth = Synth.before(~sisnare, "control_synth", [\bus, ~controlBus_1.index]);
  //s.meter;
#+end_src

Set parameters
#+begin_src sclang :results none
  ~impulse.set(\freq, 0);
  ~sisnare.set(\position, {In.kr(~controlBus_1.index)});
#+end_src

*** routine loop
#+begin_src sclang :results none
  (
  r = Routine({
    var delta = 0;
    loop {
          delta = delta + 1;
          "Will wait ".post; delta.postln;
          0.5.yield;
    }
  });
  )
#+end_src
#+begin_src sclang :results none
  r.next;

  TempoClock.default.sched(0, r);
#+end_src
#+begin_src sclang :results none
  r.stop;
#+end_src

    


    


           
** testing
*** ndef
It's possible to map an output of a nedfe to a specific parameter off another.
#+begin_src sclang :results none
  (
  Ndef(\sound, {
    RHPF.ar(
          \in1.ar([0, 0]) * \in2.ar([0, 0]),
          \freq.kr(6000, 2),
          \rq.kr(0.2)
    ) * 7
  }).play;
  Ndef(\sound).fadeTime = 0.2;    // avoid harsh clicks
  )

  Ndef(\a, { SinOsc.ar(MouseX.kr(300, 1000, 1) * [1, 1.2], \phase.ar([0, 0]) * 0.2) });
  Ndef(\b, { LFDNoise3.ar(MouseY.kr(3, 1000, 1) * [1, 1.2]) });
  Ndef(\c, { LFTri.ar(MouseY.kr(3, 10, 1) * [1, 1.2]).max(0) });
  Ndef(\a).fadeTime = 0.2;    // avoid harsh clicks again

  Ndef(\sound) <<>.in1 Ndef(\a);
  Ndef(\sound) <<>.in2 Ndef(\b);
  Ndef(\sound) <<>.in2 Ndef(\c);
  Ndef(\a) <<>.phase Ndef(\sound);
  Ndef(\a) <<>.phase nil;    // unmap
  Ndef.clear(3);        // fade out and clear all Ndefs
#+end_src

