#+STARTUP: indent overview hidestars

* Snare snippets
** audio init
   Query interfaces
   #+begin_src sclang :results none
     ServerOptions.devices;
     s.boot;
   #+end_src

   Set JackRouter to be the interface on Linux
   #+name: boot_jack
   #+begin_src sclang :results none
     (
     o = Server.local.options; // Get the local server's options
     o.numOutputBusChannels = 64;
     o.numWireBufs = 128;
     o.memSize = 65536;
     //     s.makeWindow;
     s.makeGui(p);
     s.boot;
     )
   #+end_src

   Query for node tree:
   #+begin_src sclang :results none
     // in post window
     s.queryAllNodes(queryControls: false)
     // in a gui window
//     s.plotTree(interval: 0.5);
   #+end_src

   #+begin_src sclang :results none
     s.quit;
   #+end_src
** jack
*** status
    #+begin_src shell
      jcon -c
    #+end_src

*** startup
    Load library async for these.
    plain two channel interface, start asynchronous
    #+begin_src shell :async
      startjack -r 48000 -c 2
    #+end_src

    Edirol
    #+begin_src shell :async
      startjack -r 48000 -c 2 -d jp_co_roland_RDUSB00E6Dev_AudioEngine:14500000:0
    #+end_src

    #+begin_src shell
      startjack -l
    #+end_src

*** jconvolver
    Remember to load the library ob-async prior to testing these:

    ~M-x load-library ob-async~

    On osx the directory should be: "~/Library/mcfx/convolver_presets/kmh_lilla_salen_29/"

    To start jconvolver:
    #+name: jconvolver
    #+begin_src shell :async :dir /home/henrikfr/Music/spatialization/klangkupolen/gerhard/convolution_config/kmh_lilla_salen_29
      echo "Starting up jconvolver"
      jconvolver KMH_LILLA_SALEN.conf &
    #+end_src

    #+RESULTS: jconvolver
    : 81168f108377c0471c3a01d4197f5c74

    disconnect supercollider from main out$
    #+begin_src shell
      for i in {1..2}; do
	  jdis -d scsynth out$i system playback_$i
      done
    #+end_src

    connect supercollider to jconvolver
    #+begin_src shell :results replace
      jcon scsyn out jcon in 16
      jcon jcon out system play 2
    #+end_src

    #+RESULTS:

    connect only jconvolver to jack
    #+begin_src shell 
      jcon jcon out sys play 2
    #+end_src

*** connect multi to stereo
   - Odd multi output to left out
   - Even to right output
    #+begin_src shell
      for i in {2..16}; do
	  if ((i % 2 == 0)); then
	      jcon scsynth out$i sys playback_2 1;
	  else 
	      jcon scsynth out$i sys playback_1 1;
	  fi
      done
    #+end_src

    specific version of the above.
   #+begin_src shell :results replace
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jcon scsynth out$i sys playback_1 1; 
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jcon scsynth out$i sys playback_2 1; 
     done
   #+end_src

   Connect scsynth to jconvolver 
   #+begin_src shell :results replace
     for i in {1..16}; do
         echo $i
	 jcon scsynth out$i jcon in_$i
     done
   #+end_src

   Disconnect scsynth from jconvolver 
   #+begin_src shell :results replace
     for i in {1..16}; do
	 echo $i
	 jdis -d scsynth out$i jcon in_$i
     done
     jdis -d scsynth out1 jcon in_1
   #+end_src

   Disconnect scsynth from jconvolver 
   #+begin_src shell :results replace
     for i in {1..16}; do
	 jdis -d scsynth "out$i" jcon "in_$i";
     done
   #+end_src

    disconnect it
   #+begin_src shell :results replace
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jdis -d scsynth out$i sys playback_1;
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jdis -d scsynth out$i sys playback_2;
     done
   #+end_src

*** disconnect stereo
    #+begin_src shell :results replace
      for i in {1..2}; do
       echo "$i"
      done
    #+end_src

    #+begin_src shell :results replace
      array=(1 2 8 6 10 9 5 7)
      for i in {1..8}; do
      echo "$array[$i]"
      done
    #+end_src

*** jack for i_dispersed_snare in 1D118
   #+begin_src shell :results replace
     jdis -a
     for i in 1 3 5 7 9 11 13 15; do 
	 echo $i
	 jcon scsynth out$i sys playback_1 1; 
     done
     for i in 2 4 6 8 10 12 14 16; do 
	 echo $i
	 jcon scsynth out$i sys playback_2 1; 
     done
   #+end_src
*** jack for i_dispersed_snare in 1D114, 8 channels
   #+begin_src shell :results replace
     declare -a outs=(1 2 3 4 5 6 7 8)
     declare -a ins=(1 2 8 6 10 9 5 7)
     for i in {0..7}; do
	 ##	 echo ${outs[$i]} ${ins[i]}
	 jcon scsynth out${outs[$i]} sys playback_${ins[i]}
     done
   #+end_src
*** jack for lilla salen
    #+begin_src shell :results replace
      for i in {1..16}; do
	  jcon scsynth out$i sys playback_$i
      done
    #+end_src
    
** recorder
   #+property: header-args:shell :var dir="/Users/henrik_frisk/Music/pieces/snares/audio/"

   #+name: record_me
   #+begin_src sclang :results none
     s.prepareForRecord("~/Music/single.wav", numChannels: 16);
     s.record;
   #+end_src
   #+name: rename_file
   #+begin_src shell :var fname="isnare_filter_routine.wav"
     file="/Users/henrik_frisk/Music/single.wav"
     mv "$file" "$dir$fname"
     echo "Moved $file to $dir and renamed it $fname"
   #+end_src

   #+begin_src sclang :results none
     s.pauseRecording;
   #+end_src
   
   #+name: stop_record
   #+begin_src sclang :results none
     s.stopRecording;
   #+end_src

   #+name: print_files
   #+begin_src shell
     ls "$dir"
   #+end_src

** play routines
   Routine recorded on July 24
   #+begin_src shell :noweb yes :results none
     echo "<<isnare_filter_mod()>>"
     echo "<<isnare_filter_routine()>>"
   #+end_src
** test tone
   #+begin_src sclang :results none
     {Out.ar(0, SinOsc.ar(440, 0, 0.1))}.play;
     s.meter;
   #+end_src

   GUI
   #+begin_src sclang :results none
     (
     SynthDef(\pluck, { |out, freq=55|
	 Out.ar(out,
		     Pluck.ar(WhiteNoise.ar(0.06),
			     EnvGen.kr(Env.perc(0,4), 1.0, doneAction: Done.freeSelf),
			     freq.reciprocal,
			     freq.reciprocal,
			     10,
			     coef:0.1)
	 );
     }).add;

     w = Window.new("Hold arrow keys to trigger sound",
	 Rect(300, Window.screenBounds.height - 300, 400, 100)).front;
     a = Slider(w, Rect(50, 20, 300, 40)).value_(0.5).step_(0.05).focus
     .action_({
	 // trigger a synth with varying frequencies
	 Synth(\pluck, [\freq, 55 + (1100 * a.value)]);
	 w.view.background_(Gradient(Color.rand,Color.rand));
     })
     )
   #+end_src
** snare synths
*** snare 1
**** synthdef
     Simple instance of a snare synth played by an impulse.

     This may be used for polyrhythmic snare using [[generic_snare][generic_snare]] below.

     Used by a variety of snippets:
     - [[*pbind for accelerando][pbind for accelerando]]
     #+name: original_snare
     #+begin_src sclang :results none
       (
       ~snare_simple = SynthDef(\snare, {
	   var snd;
	   var env = Env([0, 1, 0], [0.0001, \length.ir(0.5)], \sine);
	   var imp = Impulse.ar(\impf.kr(1), 0.0, 0.5, 0);
	   var frq1=\freq.kr(300), frq2=frq1-100;
	   snd = OGenericSnarefs.ar(imp, 0.00001, 0.001, \noiselvl.kr(0.1), \nrel.ir(0.1), frq1, frq2, \rel.ir(0.1), \trifrq.kr(111)) * EnvGen.kr(env, doneAction: Done.freeSelf);
	   Out.ar(\out.ir(0), snd*\gain.ir(1));
       }).add;
       )
     #+end_src
***** Gesture one
      Similar to the above, but with modulation of Impulse tempo
      #+name: extended_snare
      #+begin_src sclang :results none
	(
	~snare_simple = SynthDef(\snare_imp_mod, { 
		var snd,
		crv = \curve.ir(0),
		lngth = \length.ir(1),
		sstrt = \speedStart.ir(1),
		send = \speedEnd.ir(1),
		frq1 = \freq.kr(300),
		frq2 = \freq2.kr(200),
		nlvl = \noiselvl.kr(0.1),
		nrel = \nrel.ir(0.1),
		rel = \rel.ir(0.1),
		trifrq = \trifrq.kr(111),
		out = \out.ir(0),
		gain = \gain.ir(1),
	    envcrv = \envCurve.ir(6);
		var mod_env = Env(
			levels: [sstrt, send],
			times: [lngth],
			curve: crv,
			releaseNode: 0,
			loopNode: 1,
		);
		var env = Env([0, 1, 0], [0.0001, lngth], curve: envcrv);
		var imp = Impulse.ar(EnvGen.ar(mod_env, gate: Impulse.ar(0.001), levelScale: 1, levelBias: 0.0, timeScale: 1, doneAction: 0));
		snd = OGenericSnarefs.ar(imp, 0.000001, 0.0001, nlvl, nrel, frq1, frq2, rel, trifrq) * EnvGen.kr(env, doneAction: Done.freeSelf);
		Out.ar(out, snd*gain);
	}).add;
	)
      #+end_src

      #+name: acc_snare
      #+begin_src sclang :results none :noweb yes
	~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 1, \speedEnd, 25, \freq, 400, \trifrq, 100, \length, 5, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
      #+end_src

      #+name: acc_deep
      #+begin_src sclang :results none :noweb yes
	~reg_snare = Synth.new("snare_imp_mod", [\curve, 2,  \speedStart, 2, \speedEnd, 40, \freq, 200, \trifrq, 420, \length, 1, \out, 1, \gain, 0.2, \envCurve, 40] );
      #+end_src

      #+name: snare_single
      #+begin_src sclang :results none :noweb yes
	~test = Synth.new("snare_imp_mod", [\freq, 400, \freq2, 300, \trifrq, 80, \length, 5, \out, 0, \gain, 1.3, \envCurve, 10, \noiselvl, 0.4, \nrel, 0.04, \curve, 4,  \speedStart, 0.01, \speedEnd, 0.01] );
      #+end_src

      #+name: snare_bass
      #+begin_src sclang :results none :noweb yes
	~test2 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 100, \speedEnd, 100, \freq, 80, \freq2, 90, \trifrq, 60, \noiselvl, 0.001, \length, 10, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
      #+end_src

      #+name: snare_bass
      #+begin_src sclang :results none :noweb yes
	~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 60, \speedEnd, 70, \freq, 100, \freq2, 110, \trifrq, 85, \noiselvl, 0.01, \length, 10, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
      #+end_src

      #+begin_src sclang :results none
	~play_snares = { |start, end, frq, time, out|
		var frq2, tri;
		frq2 = frq * 2;
		tri = frq / 2;
		~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, start, \speedEnd, end, \freq, frq, \freq2, frq2, \trifrq, tri, \noiselvl, 0.01, \length, time, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10, \out, out] );
	}; 
	~play_snares.value(2, 60, 100, 10, 0);
	~play_snares.value(3, 40, 180, 10, 1);
      #+end_src

      #+begin_src sclang :results none
	~test3.set(\freq, 600);
      #+end_src
      #+begin_src sclang :results none :noweb yes
	{<<acc_snare>>}.defer(0);
	{<<acc_deep>>}.defer(3.95);
	{<<snare_single>>}.defer(4.88);
      #+end_src

***** Stuff
      Example routine, as a looping gesture
      #+name: looping_gesture
      #+begin_src sclang :results none :tangle testme.sc :noweb yes
	~intro_gesture = Routine ({
		var delta;
		loop {
			delta = 1;
			<<acc_snare>>
			delta.yield;
		}
	});
      #+end_src

      Another simple routine (not good for time critical events.
      #+begin_src sclang :results none :noweb yes
	{ 20.do({ <<snare_single>> 0.1.wait;}) }.fork;
      #+end_src
     
      #+begin_src sclang :results none :noweb yes
	<<looping_gesture>>
	~intro_gesture.play;
//	~intro_gesture.stop;
      #+end_src

      #+name: dacc_snare
      #+begin_src sclang :noweb yes
	<<acc_snare>>
	~reg_snare = Synth.new("snare_imp_mod", [\envCurve, 1, \curve, -4, \speedStart, 20, \speedEnd, 1, \freq, 400, \trifrq, 100, \length, 5, \out, 1, \gain, 1, \vol, 1] );
      #+end_src

      A feedback snare
      #+begin_src sclang :results none
	(
	~snare_fb = SynthDef(\snarefb, { | gain=4, freq=200, vol=2, q=1, out=0 |
	    var snd;
	    var env = Env([0, 1, 0], [0.0001, 0.5]);
	    snd = SnaresFb.ar(gain: gain, vol: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
	    Out.ar(out, snd);
	}).add;
	)
      #+end_src

      A dispersed snare over many channels
      #+begin_src sclang :results none
	(
	~snare_disp = SynthDef(\snaredisp, { | freq=200, q=1, out=0, pos=0, disp=1, impf=0, attack=0.0001, noiselvl=0.1, noiserel=0.1, osc1f=330, osc2f=180, trianglef=111, mainlvl=0.5, length=1 |
	    var snd;
	    var env = Env([0, 1, 0], [0.0001, length]);
	    var imp = Impulse.ar(impf, 0.0, 0.5, 0);
	    snd = ODispersedSnare.ar(imp, pos, disperse: disp, attack: attack, noise_lvl: noiselvl, noise_rel: noiserel, osc_1_freq: osc1f, osc_2_freq: osc2f, triangle_freq: trianglef);// * EnvGen.kr(env, doneAction: Done.freeSelf);
	    Out.ar(out, snd * mainlvl);
	}).add;
	)
      #+end_src

      A second version of the dispersed snare above
      #+begin_src sclang :results none
	(
	~snare_disp = SynthDef(\snaredisp2, { | out=0, length=2 |
	    var snd;
	    var env = Env([0, 1, 0], [0.0001, length]);
	    var imp = Impulse.ar(10, 0.0, 0.5, 0);
	    snd = ODispersedSnare.ar(imp);
	    Out.ar(out, snd);
	}).add;
	)
      #+end_src

      #+begin_src sclang :results none
	~snare_simple.free;
	~snare_fb.free;
	~snare_disp.free;
      #+end_src

**** player
     Play one hit on the snare above.
     #+name: reg_snare_load
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snare", [\freq, 400, \trifrq, 100, \length, 0.09, \out, 1, \gain, 1, \vol, 1] );
     #+end_src

     Play a series of hits for the duration of ~\length~.
     #+name: generic_snare
     #+begin_src sclang :results none
       ~snare_simple = Synth.new("snare", [\impf, 0.1, \freq, 300, \nrel, 0.05, \length, 0.1, \out, 0] );
//       s.meter;
     #+end_src

     Exaple of speeding up hits using a ~Routine~
     #+begin_src sclang :results none :noweb yes
       (
       <<generic_snare>>

       Routine({
	       x=1;
	       0.2.wait;
	       100.do({
		       ~snare_simple.set(\impf, x);
		       x.postln;
		       x = x + 1;
		       0.1.wait
	       })
       }).play;
       )
     #+end_src
     
     #+begin_src sclang :results none
       Pbind(\instrument, \snare,
	   \out, 0,
	   \impf, 0.1,
	   \freq, Pseq((150..600), 100),
	   \nrel, Pseq((0.005..0.4), 100),
	   \length, 0.15,
	   \dur, Pseries((0.5..0.01), 10),
       ).play;
     #+end_src

     #+begin_src sclang :results none
       ~fb_snare = Synth.new("snarefb", [\out, 1, \gain, 2, \vol, 2] );
     #+end_src

     Snygga effekter genom att panorera dessa tvÃ¥ ljud med Radius och Elevation.
     #+begin_src sclang :results none
       ~disp_snare1 = Synth.new("snaredisp", [\out, 1, \impf, 3000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 20] );
       ~disp_snare1 = Synth.new("snaredisp", [\out, 0, \impf, 2000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 25] );
       s.meter;
     #+end_src

     #+begin_src sclang :results none
       Pbind(\instrument, \snaredisp,
	   \out, 0,
	   \impf, 10,
	   \dur, 0.5,
	   \pos, 6,
       ).play
     #+end_src

     #+begin_src sclang :results none
       ~dist_snare = Synth.new("snaredisp", [\out, 0, \impf, 0, \pos, 0, \disp, 1, \noiserel, 0, \noiselvl, 0.01] );
     #+end_src

     Closer and closer.
     #+begin_src sclang :results none
       ~range = [(1..10)].do({ arg item, i; [item/20]; });
       Pbind(\instrument, \snaredisp,
	   \out, Pseq((31..31), 16), // This is for feeding the signal to the ambisonics engine
	   \noiserel, Pseq([0.0, 0.001, 0.002, 0.003, 0.005, 0.007, 0.01, 0.02, 0.03, 0.04, 0.045, 0.050, 0.055, 0.06, 0.065, 0.07], 16),
	   \nopiselvl, 0.0,
	   \osc1f, Pseq((150..2000), 16),
	   \osc2f, 180,
	   \mainlvl, Pseq([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16], 16),
	   \dur, 1
       ).play;
//s.meter;
     #+end_src
     
     For testing
     #+begin_src sclang :results none
a = Array.fill(16, {arg i; i * 0.001; });
b = Array.fill(32, { arg i; i / 32 + 0.05 }).reverse;
       Pbind(\instrument, \snaredisp,
	   \out, 0,
	   \noiserel, Pseq(a, 32),
	   \ nopiselvl, 0.0,
	   \osc1f, Pseq((150..2000), 32),
	   \osc2f, Pseq((400..170), 32),
	   \mainlvl, 0.5,
	   \dur, Pseq(b, 32)
       ).play
     #+end_src
**** pbind: fast irregular, no snare.
     Very nice sounding pattern
     #+begin_src sclang :results none
       Pbind(\instrument, \snare,
	   \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
	   \dur, Prand([0.1, 0.2], inf),
	   \q, Prand([0.001, 5, 2], inf),
	   \out, Prand((0..1), inf) //([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], inf)
       ).play;
     #+end_src
     

     #+begin_src sclang :results none
       Pbind(\instrument, \snarefb,
	   \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
	   \dur, Prand([0.1, 0.2, 0.4], inf),
	   \q, Prand([0.001, 5, 2], inf),
	   \out, Prand( (0 .. 16), inf)
       ).play;
     #+end_src

     Ptpar running two Pbinds
     #+begin_src sclang :results none
       a = Pbind(\instrument, \snare,
	 \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
\dur, Pseq([0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
\q, Prand([0.001, 5, 2], inf)
       );
       b = Pbind(\instrument, \snare,
	 \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
\dur, Pseq([0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
       );
Ptpar([0.0, a, 1, b, 2, a]).play;
     #+end_src
*** snare phase
**** synthdef
     Four hits per pulse. Min speed is 1/2 sec.
     #+name: i_snare_phase_1
     #+begin_src sclang :results none
       ~phased_snare = SynthDef(\snare_phase, {
	       var snd, pulse = \pulse.kr(10);
	       var frq1 = \freq.kr(300),
	       frq2 = \freq2.kr(300);
	       snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111));
	       Out.ar(\out.kr(0), snd * \gain.kr(0.5));
       }).add
     #+end_src

     #+name: i_snare_phase_2
          #+begin_src sclang :results none
       ~phased_snare = SynthDef(\snare_phase_2, {
               var snd, pulse = \pulse.kr(10);
               var frq1 = \freq.kr(300),
               frq2 = \freq2.kr(300),
               env = Env.new(levels: [1, 0], times: [\length.ir(0.1)], curve: \sin);
               snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111)) * EnvGen.kr(env, timeScale: \length.ir(0.1), doneAction: Done.freeSelf);
               Out.ar(\out.kr(0), snd * \gain.kr(0.5));
       }).add
     #+end_src

**** player
     Simple example
     #+begin_src sclang :results none
       Synth.new("snare_phase_2", [\pulse, 1, \nlevel, 0]);
     #+end_src

     Polyrhythmic function with two synths at different speeds. 
     #+name: poly_rhythm
     #+begin_src sclang :results none
       ~poly_rhythm = { | nom, denom, f |
	   var f1, f2;
	   postf("freq is %\n", f);
	   f1 = nom * f;
	   "f1 is ".post; f1.postln;
	   f2 = denom * f;
	   "f2 is ".post; f2.postln;
	   ~phased1 = Synth.new("snare_phase", [\pulse, f1, \freq, 100, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 0] );
	   ~phased2 = Synth.new("snare_phase", [\pulse, f2, \freq, 50, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 1] );
       };
       ~poly_rhythm.value(3, 5, 1);
     #+end_src

     Polyrhythmic function with two synths at different speeds. 
     #+name: polyr
     #+begin_src sclang :results none
       ~polyr = { | nom, denom, f |
	       var f1, f2, phase1, phase2, synths;
	       postf("freq is %\n", f);
	       f1 = nom * f;
	       "f1 is ".post; f1.postln;
	       f2 = denom * f;
	       "f2 is ".post; f2.postln;
	       synths = [ Synth.new("snare_phase", [\pulse, f1, \freq, 100, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 0] ), Synth.new("snare_phase", [\pulse, f2, \freq, 50, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 1] )];
       };
       k = ~polyr.value(1, 2, 3);
     #+end_src

     #+begin_src sclang :results none
       //k[0].set(\pulse, 1, \nlevel, 0.0, \freq, 400, \freq2, 200, \trifreq, 300);
       ~phased_set_values.value(1, 1, 3, k);
       ~phased_set_values.value(2, 3, 4, l);
     #+end_src
     Polyrhythmic object with two synths at different speeds. 
     #+name: poly_rhythm
     #+begin_src sclang :results none
       PolyRhythm = {
	   var >f=1, f1, f2, >nom=1, >denom=1, phase_1, phase_2;
	       f1 = nom * f;
	       f2 = denom * f;
	   phase_1 = Synth.new("snare_phase", [\pulse, f1, \freq, 100, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 0] );
	   phase_2 = Synth.new("snare_phase", [\pulse, f2, \freq, 50, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 1] );
       };
       a = PolyRhythm.new;
       a.f_(2);
       a.nom_(2);
       a.denom_(3);
     #+end_src

     Function setting the values relative to the pulse.
     #+name: phased_set_values
     #+begin_src sclang :results none
       ~phased_set_values = { |frequency=10, nom, denom, synth|
	       var freq = frequency, nlevel, f1, f2, t3, normalizedf, maxf = 2000;
	       normalizedf = freq / maxf;
	       c = ControlSpec(1, 2000, \lin, 0.0001);
	       freq = c.unmap(freq);
	       //d = [0.05, 0.00001, -40].asSpec;
	       d = ControlSpec(0.01, 0.00001, -40, 0.00001);
	       nlevel = d.map(freq);
	       f1 = freq * 2 + 50;
	       f2 = freq * 3 + 50;
	       t3 = freq * 4 + 50;
	       synth[0].set(\pulse, frequency*nom, \nlevel, nlevel, \freq, f1*nom, \freq2, f2*nom, \trifreq, 300);
	       synth[1].set(\pulse, frequency*denom, \nlevel, nlevel, \freq, f1*denom, \freq2, f2*denom, \trifreq, 300);
       };
       k = ~polyr.value(1, 2, 3);
       l = ~polyr.value(2, 2, 3);
       ~phased_set_values.value(1, 1, 3, k);
       ~phased_set_values.value(2, 3, 4, l);
     #+end_src

     Loop to do a accelerando. This also loads the other patches.
     #+begin_src sclang :results none :noweb yes
//       <<poly_rhythm>>
//       <<phased_set_values>>
       (
       t = Task({
	       loop {
		       (5..500).do({ |pulse|
//			       ~phased_set_values.set(pulse*0.1, 3, 2);
			       ~phased_set_values.value(pulse*0.1, 3, 4, k);
			       ~phased_set_values.value(pulse*0.1, 5, 6, l);
			       0.3.wait;
		       });
	       }
       }).play;
       )

     #+end_src

     #+begin_src sclang :results none
       (
       var mapped;
       w = Window.new.front;
       c = ControlSpec(1, 1000, \linear, 0.01); // min, max, mapping, step
       b = NumberBox(w, Rect(20, 20, 150, 20));
       d = NumberBox(w, Rect(20, 120, 150, 20));

       a = Slider(w, Rect(20, 60, 150, 20)).action_({
	       mapped = c.map(a.value);
	       b.value_(mapped);
	       ~phased1.set(\pulse, mapped);
       });

       e = Slider(w, Rect(20, 160, 150, 20)).action_({
	       mapped = c.map(e.value);
	       d.value_(mapped);
	       ~phased2.set(\pulse, mapped);
       });
       a.action.value;
       e.action.value;
       )     
     #+end_src
*** snare dispersed
This is very nice with a few patterns to it at the bottom under control signals
**** synth
define the synth
#+name: snare_disp_4
#+begin_src sclang :results none
  ~disp_snare = SynthDef(\snaredisp4, { | dur=60, out=33, pos=0, disp=0, pulse=2000, att=0.00001, n_attack=0.01, n_level=0.2, n_rel=0.1, osc1_f=100, osc2_f=130, release=0.01, tri_f=300 |
      var snd, env;
      env = Env.new(levels: [0, 1, 1, 0], times: [0.01, dur, 0.01]);
      snd = IDispersedSnare.ar(pos, disp, pulse, att, n_attack, n_level, n_rel, osc1_f, osc2_f, release, tri_f) * EnvGen.kr(env, doneAction: Done.freeSelf);
      Out.ar(out, snd);
  }).play(s);
//s.plotTree;
#+end_src
     
define the busses
#+name: snare_disp_4_bus
#+begin_src sclang :results none
  ~busses = Array.new(4);
  ~duration = 20;

  b = Bus.control(s, 1);
  ~disp_snare.map(\pos, b);
  c = Bus.control(s, 1);
  c.set(4000);
  ~disp_snare.map(\pulse, c);
  d = Bus.control(s, 1);
  d.set(0.1);
  ~disp_snare.map(\n_rel, d);
  e = Bus.control(s, 1);
  e.set(0.2);
  ~disp_snare.map(\n_level, e);

  //      {Out.kr(b, Line.kr(0, 29, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(4000, 200, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.1, 0.005, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.2, 0.001, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
#+end_src

#+begin_src sclang :results none
  s.makeGui(p);
#+end_src
**** player
#+name: play_disp_snare_4
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snaredisp4", [\dur, 30, \out, 0, \pos, 2, \disp, 0, \pulse, 500, \gain, 20, \vol, 5] );
       //       ~reg_snare.free;
     #+end_src

**** control signals
     Various tasks that alter the parameters of the synth
     This takes the positions parameter
     #+begin_src sclang :results none :noweb yes
       <<snare_disp_4>>
       <<snare_disp_4_bus>>
       <<play_disp_snare_4>>
       ~pos_task = Task({
               loop {
                       (0..28).do({ |position|
                               position.postln;
                               ~reg_snare.set(\pos, position);
                               0.5.wait;
                       });
               }
       }).play;
     #+end_src

     Slowly increaseing disperse parameter
     #+begin_src sclang :results none :noweb yes
       <<snare_disp_4>>
       <<snare_disp_4_bus>>
       <<play_disp_snare_4>>
       ~disp_task = Task({
           loop {
                       (0..100).do({ |disperse|
                               var disp;
                               disp = disperse/100;
                               ~reg_snare.set(\disp, disp);
                               0.1.wait;
                       });
           }
       }).play;
     #+end_src

#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~pulse_task = Task({
          loop {
                  (5000..100).do({ |pulse_time|
                          var pulse, disp;
                          pulse = pulse_time;
                          disp = 1 / pulse_time;
                          ~reg_snare.set(\pulse, pulse);
                          ~reg_snare.set(\disp, pulse);	
                          0.01.wait;
                  });
          }
  }).play;
#+end_src

     Control the speed via a slider.
    #+begin_src sclang :results none
      (
      w = Window.new.front;
      b = NumberBox(w, Rect(20, 20, 150, 20));
      a = Slider(w, Rect(20, 60, 150, 20)).action_({
	  b.value_(a.value);
	  ~reg_snare.set(\pos, (a.value * 10));
      });
      a.action.value;
      )     
    #+end_src

*** snare 2 (osx)
    Simple instance of a snare synth with more noise
    #+begin_src sclang :results none
      (
      SynthDef(\snares, { | gain=2, freq=200, vol=2, q=10 |
	  var snd;
	  var env = Env([0, 1, 0], [0.0001, 0.5]);
	  snd = Snares.ar(attack: 0.00001, freq: freq, gain: gain, q: q, rel: 0.01, vol_0: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
	  Out.ar(0, snd);
      }).add;
      )
    #+end_src
**** player
     Play one hit on the snare above.
     #+name: snares_load
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snares", [\freq, 100] );
     #+end_src
*** snare 3 (isnare2)
**** Example without groups
    Synth that is driven by an Impulse pulse generator.
    Load first the SynthDefs below.
    #+name: isnare_def
    #+begin_src sclang :results none
      (
      // Main snare synth
      SynthDef(\isnare, { | inBus1=0, inBus2=1, inBus3=2, inBus4=3, outBus=0, freq=2, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, dur=1 |
	  var snd;
	  var env;
	  var envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]);
	  b = 0;
	  envelope.times.do({ arg i; b = b + i; });
	  c = dur / b;
	  env = EnvGen.kr(
	      envelope,
	      timeScale: c,
	      doneAction: Done.freeSelf);
	  snd = IDispersedSnare.ar(Impulse.ar(freq), position, disperse, osc_1_freq: In.kr(inBus2), osc_2_freq: In.kr(inBus2) - 50, triangle_freq: In.kr(inBus3), noise_lvl: In.kr(inBus4)) * gain * env;
	  Out.ar(outBus, snd);
      }).add;

      // Control synth 1, modulated oscillator
      SynthDef(\control_osc, {
	  Out.kr(\bus.ir,
	      SinOsc.kr(
		  // modulate the frequency of the modulator
		  Line.kr(\start.ir(0.1),
		      \end.ir(2),
		      \dur.ir(10),
		      \lmult.ir(1),
		      \ladd.ir(0)),
		  \phase.kr(0),
		  \mult.ir(1),
		  \add.ir(0)));
      }).send(s);

      // Control synth 2, line
      SynthDef(\control_line, {
	  Out.kr(\bus.ir, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(10), \mult.kr(1), \add.kr(0)));
      }).send(s);

      // Control synth 3, saw-tooth
      SynthDef(\control_saw, {
	  Out.kr(\bus.ir, Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
      }).send(s);

      ~osc_control_1_bus = Bus.control(s, 1);
      ~osc_control_2_bus = Bus.control(s, 1);
      ~line_control_1_bus = Bus.control(s, 1);
      ~line_control_2_bus = Bus.control(s, 1);
      ~saw_control_1_bus = Bus.control(s, 1);
      )
    #+end_src

    Instantiate the synths. 
    #+name: isnare_load
    #+begin_src sclang :results none
      (
      ~osc_control_1 = Synth.new(\control_osc, [
	  \bus, ~osc_control_1_bus.index,
	  \add, 7,
	  \dur, 2,
	  \start, 10,
	  \end, 0.0001,
	  \mult, 5
      ]);
      ~rising_line_1 = Synth.after(~osc_control_1, \control_line, [
	  \bus, ~line_control_1_bus.index,
	  \mult, 500,
	  \add, 50,
	  \dur, 2]);
      ~falling_line_1 = Synth.after(~osc_control_1, \control_line, [
	  \bus, ~line_control_2_bus.index,
	  \start, 200,
	  \end, 40,
	  \dur, 2]);
      ~isnare_synth = Synth.after(~saw_control_1, \isnare, [
	  \inBus1, ~saw_control_1_bus.index,
	  \inBus2, ~line_control_1_bus.index,
	  \inBus3, ~line_control_2_bus.index,
	  \freq, 10,
	  \dur, 2]);
      )
    #+end_src

    Example note with decaying hits.
    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare,
	  \dur, 1,
	  \freq, 10
      ).play;
    #+end_src

**** Example using groups
***** Synth and modulator (1)
#+name: isnare2_def
#+begin_src sclang :results none
  (
  // Main snare synth
  ~isnare_def = SynthDef(\isnare2, { | position=0, disperse=0 |
      var snd, env, envelope, duration;
      envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1], [-5, 0, -5]);
      b = 0;
      envelope.times.do({ arg i; b = b + i; });
      duration = \dur.ir / b;
      env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);
      snd = IDispersedSnare.ar(Impulse.ar(\freq.kr(1) * In.kr(\inBus3.kr)),
                  position,
                  disperse,
                  osc_1_freq: (\osc1.kr(330) * In.kr(\inBus1.kr)) + 100,
                  osc_2_freq: (\osc2.kr(180) * In.kr(\inBus2.kr)) + 120,
                  triangle_freq: (\tri.kr * In.kr(\inBus3.kr) + 200),
                  noise_lvl: \noise.kr(0.1)) * \gain.kr(0.5) * env;
      Out.ar(\outBus.ir, snd);
  }).add;

  // Control synth saw-tooth
  SynthDef(\control_saw2, {
      Out.kr(\bus.ir(0), Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
  }).send(s);

  // Busses
  ~saw_control_bus_1 = Bus.control(s, 1);
  ~saw_control_bus_2 = Bus.control(s, 1);
  ~saw_control_bus_3 = Bus.control(s, 1);
  )
#+end_src

One hit
#+begin_src sclang :results none
  a = Synth(\isnare2, [ \position, 0, \disperse, 0, \noise, 0.5, \dur, 0.03, \freq, 1]);
#+end_src
#+begin_src sclang :results none
  s.plotTree;
#+end_src

***** Create group and add control instrument (2)
      Instantiate all control instruments. This could be integrated into the main routine above: [[*Synth and modulator (1)][Synth and modulator (1)]] thus not needed to be loaded separately.
      #+name: start_controls
      #+begin_src sclang :results none
	~group = Group.new;
	~freq_ctrl = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_1.index,
	    \freq, 1,
	    \mult, 1,
	    \add, 1], ~group, \addToHead);
	~freq_ctrl2 = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_2.index,
	    \freq, 1, 
	    \mult, 1, 
	    \add, 1], ~group, \addToHead);
	~impulse_ctrl = Synth(\control_saw2, [
	    \bus, ~saw_control_bus_3.index, 
	    \freq, 0.5, 
	    \mult, 1, 
	    \add, 1], ~group, \addToHead);
	// ~group.group.inspect;
      #+end_src

      Function to set attributes for ~impulse_ctrl~. Use ~~group.set(\freq, 10)~ to set all ~\freq~ attributes in one go.
      #+name: load_presets
      #+begin_src sclang :results none
	~param_update = { | range1=1, freq1=0.01, range2=1, freq2=1, range3=1, freq3=1 |
	    ~impulse_ctrl.set(\mult, range1);
	    ~impulse_ctrl.set(\add, range1);
	    ~impulse_ctrl.set(\freq, freq1);

	    ~freq_ctrl.set(\freq, freq2);
	    ~freq_ctrl.set(\mult, range2);
	    ~freq_ctrl.set(\add, range2);

	    ~freq_ctrl2.set(\freq, freq3);
	    ~freq_ctrl2.set(\mult, range3);
	    ~freq_ctrl2.set(\add, range3);
	};
	"loaded".postln;
      #+end_src

***** Presets
      Nice and noisy
      #+name: isnare_preset_1
      #+begin_src sclang :results none :noweb yes
	<<load_presets>>
	~param_update.value(10, 1, 10, 1, 11, 1);
      #+end_src

      Dark and bassy
      #+name: isnare_preset_2
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(1, 1, 0, 1, 0, 1);
      #+end_src

      Heavily modulated
      #+name: isnare_preset_3
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(4, 5, 1.1, 100, 2, 110);
      #+end_src

      Medium dark
      #+name: isnare_preset_3
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(6, 100, 0.01, 0.002, 1.3, 0.001);
      #+end_src

      Inharmonic
      #+name: isnare_preset_4
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(1, 52, 1, 50, 1, 100);
      #+end_src

      Shady
      #+name: isnare_preset_4
      #+begin_src sclang :results none :noweb yes :var mark="hoo"
	<<load_presets>>
	~param_update.value(10, 23, 10, 24, 10, 200);
      #+end_src

      Poll a bus:
      #+begin_src sclang :results none
	{Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_3.index))}.play;
      #+end_src
***** Updating values in a routine
      Nice and noisy, lots of variation.
      #+begin_src sclang :results none
	(
	~routine = Routine({
	    var delta;
	    loop {
			delta = rrand(1, 10);
			"Will wait ".post; delta.postln;
			~impulse_ctrl.set(\add, delta);
			~freq_ctrl.set(\add, delta * 0.5);
			~freq_ctrl2.set(\mult, delta);
			1.yield;
	    }
	});
	~routine.play;
	)
      #+end_src

      #+begin_src sclang :results none
	~routine.stop;
      #+end_src
***** Add and play the main instrument, depends on [[*Create group and add control instrument][Create group...]] and [[*Synth and modulator][Synth and modulator]] (3)
      Play it:
      #+name: play_isnare2
      #+begin_src sclang :results none :noweb yes
	<<start_controls>>
	~isnarce_synth = Synth.after(~group, \isnare2, [
	    <<bus_assignment>>
	    \freq, 10,
	    \dur, 20]);
	~tempo_update.value(20, 0.01);
      #+end_src

***** Play with a Pbind (4)
These work really well!

Now including [[*Create group and add control instrument (2)][Create group ...]] with a noweb link. This can be tangled to self contained sclang code (test.sc in this example)
#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_4>>
  ~event_str = Pbind(\instrument, \isnare2,
      <<bus_assignment>>
      \group, ~group,
      \addAction, 1,
      \position, 0,
      \disperse, 1,
      \noise, 0.0001,
      \freq, 10,
      \dur, 0.1
  ).play;
#+end_src

#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_1>>
  ~event_str = Pbind(\instrument, \isnare2,
          <<bus_assignment>>
          \group, ~group,
          \position, 12,
          \disperse, 0,
          \noise, 0.01,
          \freq, 1,
          \dur, 0.1,
  ).play;
#+end_src

Move repeated stuff out for cleaner Pbind
#+name: bus_assignment
#+begin_src sclang :results none
  \inBus1, ~saw_control_bus_1.index,
  \inBus2, ~saw_control_bus_2.index,
  \inBus3, ~saw_control_bus_3.index,
#+end_src

To play from the variable.
#+begin_src sclang :results none
  ~event_str.play;
  ~event_str.reset;
#+end_src

Free the group
#+name: free_group
#+begin_src sclang :results none
  ~group.freeAll;
  ~group.free;
#+end_src
**** Stuff
      Plot a control bus
      #+begin_src sclang :results none
	{In.kr(~saw_control_bus_3.index)}.plot;
      #+end_src

      Inspect a control bus:
      #+begin_src sclang :results none
	{Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_2.index))}.play;
      #+end_src

      #+begin_src sclang :results none :noweb eval
	//~init_durs.value
	(     
	~player1 = Pbind(
	    \instrument, \isnare,
	    \dur, Pseq(~init_durs.value, inf),
	    \freq, Prand([0, 0, 20], inf),
	    \osc1, Pgauss(330, 10, inf),
	    \osc2, Pgauss(180, 10, inf),
	    \tri, Pgauss(110, 30, inf),
	    \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	    \noise, Pgauss(0.3, 0.1, inf)
	).play;
	)
      #+end_src

      Test the Pbind ~~player1~
      #+begin_src sclang :results none
	//     ~player1.next(());
	~player1.stop;
      #+end_src
      #+begin_src sclang :results none :noweb eval
	(     
	~player1 = Pbind(
	    \instrument, \impulseA,
	    \dur, Pseq(~init_durs.value, 1),
	    \freq, Prand([0, 0], inf)
	).play;
	) 
      #+end_src

**** Method generation and manipulation
      Test method to generate the array.
      #+begin_src sclang :results none
	~init_durs.value;
      #+end_src
   
      Create duration array
      #+name: create_durs
      #+begin_src sclang :results none
	(
	~create_durs = { |arr=0, div=1, elem=4|
	    var ldiv = 1/div;
	    var lelem = elem * div;
	    arr ++ Array.fill(lelem, {ldiv;});
	}
	)
      #+end_src
   
      Load create_durs first (if not loaded silently through the fake variable x)
      #+name: init_durs
      #+begin_src sclang :results none :noweb yes
	(
	~init_durs = {
	    (
		~times = Array.new();
		for(1, 3, {arg i; ~times = ~create_durs.value(~times, (2**i), 4);});
		~times.postln;
	    )
	}
	)
      #+end_src

      Alternative function for creating an array of durations.
      #+name: durations_array
      #+begin_src sclang
	~durations = {
	    var durs = Array.new(64);
	    a = (1!4);
	    b = (0.5!8);
	    c = (0.25!16);
	    d = (0.125!32);
	    durs = a ++ b;
	    durs = durs ++ c;
	    durs = durs ++ d;
	};
      #+end_src

*** snare 4 filtered
    Synth that is driven by an Impulse pulse generator.
    #+name: isnare_filter_def
    #+begin_src sclang :results none
      (
      ~controlBus_1 = Bus.control(s, 1);
      SynthDef(\isnare_filter, { | outBus=0, freq=0, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16 |
	  var snd;
	  var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
	  var modulator = SinOsc.kr([1!16],[0.1!16]);
	  var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
	  par = par * modulator;
	  snd = IFilteredSnare.ar(Impulse.ar(freq),
	      band_1: b1, band_2: b2, band_3: b3,
	      band_4: b4, band_5: b5, band_6: b6,
	      band_7: b7, band_8: b8, band_9: b9,
	      band10: b10, band11: b11, band12: b12,
	      band13: b13, band14: b14, band15: b15,
	      band16: b16,  osc_1_freq: osc1, osc_2_freq: osc2,
	      triangle_freq: tri) * gain * env;
	  Out.ar(outBus, snd);
      }).add;

      SynthDef(\control_synth, { | bus |
	  Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
      }).send(s);
      )
    #+end_src

    #+begin_src shell :results none :noweb yes
      echo <<record_me()>>
    #+end_src
    #+begin_src shell :results none :noweb yes
      echo <<stop_record()>>

    #+end_src
    #+begin_src shell :noweb yes
      <<rename_file("isnare_filter_routine_b.wav")>>
    #+end_src

    SynthDef for a modulating snare drum synth. Parameters are:
    - ~freq~: The frequency of the impulse playing the snare.
    - ~gain~: General gain (0-1)
    - ~osc1/2~: The frequecy of the two osccilators in the synth.
    - ~tri~: The triangle wave frequecy
    - ~noise~: The noise level (0-1)
    - ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
    - ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
    - ~dur~: The duration of the note.
    - ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
    - ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
    #+name: isnare_filter_mod
    #+begin_src sclang :results none
      (
      SynthDef(\isnare_filter_mod_8, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, del, del_mod=0, dur, mod_freq_stretch |
	  var snd, modulator_pf;
	  var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
	  var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
	  modulator_pf = Select.kr(freq_mod + 1, [
		  (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
	      freq, 
		  (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
	  snd = IFilteredSnare8.ar(Impulse.ar(modulator_pf),
	      band_1: b1, band_2: b2, band_3: b3,
	      band_4: b4, band_5: b5, band_6: b6,
	      band_7: b7, band_8: b8, delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
	      triangle_freq: tri) * gain * env;
	  Out.ar(out, snd);
      }).add;
      )
    #+end_src

    #+begin_src sclang :results none
      p = Pbind(\instrument, \isnare_filter_mod_8,
	  \dur, 0.1,
\out, 0,
	  \freq, 1,
	  \freq_mod, 0,
	  \del_mod, 0,
	  \b1, Pshuf([-0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, ], inf),
	  \b2, Pshuf([-5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, ], inf),
	  \b3, Pshuf([-10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, ], inf),
	  \b4, Pshuf([-14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, ], inf),
	  \b5, Pshuf([-19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, ], inf),
	  \b6, Pshuf([-24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, ], inf),
	  \b7, Pshuf([-29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, ], inf),
	  \b8, Pshuf([-34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, ], inf),
      ).play;

      b = Pbind(\instrument, \isnare_filter_mod_8,
	  \dur, 1,
\out, 8, 
	  \freq, 10,
	  \freq_mod, 0,
	  \del_mod, 0,
	  \b1, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b2, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b3, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b4, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b5, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b6, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b7, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
	  \b8, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
      );

      Ptpar([0, p, 0.66666, b]).play
      //      b.play;
    #+end_src

    SynthDef for a modulating snare drum synth. Parameters are:
    - ~freq~: The frequency of the impulse playing the snare.
    - ~gain~: General gain (0-1)
    - ~osc1/2~: The frequecy of the two osccilators in the synth.
    - ~tri~: The triangle wave frequecy
    - ~noise~: The noise level (0-1)
    - ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
    - ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
    - ~dur~: The duration of the note.
    - ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
    - ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
    #+name: isnare_filter_mod
    #+begin_src sclang :results none
      (
      SynthDef(\isnare_filter_mod, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, del, del_mod=0, dur, mod_freq_stretch |
	  var snd, modulator_pf;
	  var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
	  var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
	  var mod_f = Array.series(16, 1, mod_freq_stretch);
	  var mod_p = Array.series(16, 0, 0.4);
	  var modulator_f = SinOsc.kr(mod_f, mod_p, add: 0);
	  var unused = Array.series(16, 0.1, 0.05);
	  var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
	  modulator_pf = Select.kr(freq_mod + 1, [
		  (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
	      freq, 
		  (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
	  par = par * modulator_f;
	  snd = IFilteredSnare.ar(Impulse.ar(modulator_pf),
	      band_1: par[0], band_2: par[1], band_3: par[2],
	      band_4: par[3], band_5: par[4], band_6: par[5],
	      band_7: par[6], band_8: par[7], band_9: par[8],
	      band10: par[9], band11: par[10], band12: par[11],
	      band13: par[12], band14: par[13], band15: par[14],
	      band16: par[15], delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
	      triangle_freq: tri) * gain * env;
	  Out.ar(out, snd);
      }).add;
      )
    #+end_src

    #+begin_src sclang :results none
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 0, \freq, 0.1, \freq_mod, 20, \mod_freq_stretch, 2, \dur, 10, \osc1, 200, \osc2, 330, \tri, 340, \noise, 1, \del_mod, 0 ] );
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 16, \freq, 10, \freq_mod, 2, \dur, 12, \osc1, 120, \osc2, 235, \tri, 140, \del_mod, 0.5] );
      s.meter;
    #+end_src

    #+name: isnare_filter_routine
    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare_filter_mod,
	  \dur, 5,
	  \freq, Pgauss(8, 3, inf),
	  \freq_mod, Prand([0,1], inf),
	  \del_mod, Pgauss(0.5, 0.5, inf),
	  \b1, -50,
	  \b2, -50,
	  \b3, -50,
	  \b4, -50,
	  \b5, -50,
	  \b6, -50,
	  \b7, -50,
	  \b8, -50,
	  \b9, -50,
	  \b10, -50,
	  \b11, -50,
	  \b12, -50,
	  \b13, -50,
	  \b14, -50,
	  \b15, -50,
	  \b16, -50,
	  \osc1, Pgauss(230, 50, inf),
	  \osc2, Pgauss(180, 50, inf),
	  \tri, Pgauss(110, 30, inf),
	  \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	  \noise, Pgauss(0.0, 0.1, inf),
	  \mod_freq_stretch, Prand([0.1, 0.3, 0.5], inf)
      ).play;
    #+end_src

    Example of spatialization with filtering, no delay.
    #+begin_src sclang :results none
      Pbind(
	  \out, 0,
	  \instrument, \isnare_filter_mod,
	  \del_mod, 0,
	  \freq_mod, Prand([-0.2, 0, 1], inf),
	  \dur, 10,
	  \freq, Pgauss(10, 8, inf),
	  \b1, Pgauss(-70, 20, inf),
	  \b2, Pgauss(-70, 20, inf),
	  \b3, Pgauss(-70, 20, inf),
	  \b4, Pgauss(-70, 20, inf),
	  \b5, Pgauss(-70, 20, inf),
	  \b6, Pgauss(-70, 20, inf),
	  \b7, Pgauss(-70, 20, inf),
	  \b8, Pgauss(-70, 20, inf),
	  \b9, Pgauss(-70, 20, inf),
	  \b10, Pgauss(-70, 20, inf),
	  \b11, Pgauss(-70, 20, inf),
	  \b12, Pgauss(-70, 20, inf),
	  \b13, Pgauss(-70, 20, inf),
	  \b14, Pgauss(-70, 20, inf),
	  \b15, Pgauss(-70, 20, inf),
	  \b16, Pgauss(-70, 20, inf)
      ).play;
    #+end_src

    #+begin_src sclang :results none
      Pbind(
	  \instrument, \isnare_filter_mod,
	  \out, 0,
	  \del_mod, 0,
	  \freq_mod, Prand([0, 0], inf),
	  \dur, 0.1,
	  \freq, 10,
	      \b1, Pseq([-0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, ], inf),
	      \b2, Pseq([-4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, ], inf),
	      \b3, Pseq([-8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, ], inf),
	      \b4, Pseq([-12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, ], inf),
	      \b5, Pseq([-16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, ], inf),
	      \b6, Pseq([-21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, ], inf),
	      \b7, Pseq([-25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, ], inf),
	      \b8, Pseq([-29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, ], inf),
	      \b9, Pseq([-33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, ], inf),
	      \b10, Pseq([-37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, ], inf),
	      \b11, Pseq([-42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, ], inf),
	      \b12, Pseq([-46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, ], inf),
	      \b13, Pseq([-50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, ], inf),
	      \b14, Pseq([-54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, ], inf),
	      \b15, Pseq([-58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, ], inf),
	      \b16, Pseq([-63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, ], inf),
      ).play;
    #+end_src

    #+begin_src sclang :results none
		  a = Pbind(\instrument, \isnare_filter_mod,
		  \dur, 0.001,
		  \freq, 5,
		  \freq_mod, 0.09,
		  \del_mod, 0.1,
		  \b1, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
		  \b2, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
		  \b3, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
		  \b4, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
		  \b5, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
		  \b6, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
		  \b7, Pseq([-76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, ], inf),
		  \b8, Pseq([-64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, ], inf),
		  \b9, Pseq([-47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, ], inf),
		  \b10, Pseq([-24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, ], inf),
		  \b11, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
		  \b12, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
		  \b13, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
		  \b14, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
		  \b15, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
		  \b16, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
		  );

		  b = Pbind(\instrument, \isnare_filter_mod,
		  \dur, 0.005,
		  \freq, 1,
		  \freq_mod, 2,
		  \del_mod, 5,
		  \b1, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
		  \b2, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
		  \b3, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
		  \b4, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
		  \b5, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
		  \b6, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
		  \b7, Prand([-11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, ], inf),
		  \b8, Prand([-10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, ], inf),
		  \b9, Prand([-8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, ], inf),
		  \b10, Prand([-8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, ], inf),
		  \b11, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
		  \b12, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
		  \b13, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
		  \b14, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
		  \b15, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
		  \b16, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
		  );
      Ptpar([0, a, 0.5, b]).play;
    #+end_src

    Controlling the filters
    #+begin_src sclang :results none :noweb eval
      ~init_durs.value
      (     
      ~player1 = Pbind(
	  \instrument, \isnare,
	  \dur, Pseq(~init_durs.value, inf),
	  \freq, Prand([0, 0, 20], inf),
	  \osc1, Pgauss(330, 10, inf),
	  \osc2, Pgauss(180, 10, inf),
	  \tri, Pgauss(110, 30, inf),
	  \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
	  \noise, Pgauss(0.3, 0.1, inf)
      ).play;
      )
    #+end_src

    Stop playback
    #+begin_src sclang :results none
      ~player1.stop;
    #+end_src
*** bass snare 1
Used in the drum loop among other places.
**** synthdef
     #+name: bsnare
     #+begin_src sclang :results none
       (
       ~bass_snare = SynthDef(\bsnare, {
           var snd;
           var impfreq = \impfreq.kr(1),
           osc1 = \osc1.kr(50),
           osc2 = \osc2.kr(70),
           trifreq = \trifreq.kr(10),
           fltq = \fltq.kr(1),
           fltfreq = \fltfrq.kr(100),
           fltgain = \fltgain.kr(1),
           modfreq = \modfreq.kr(0),
           attack = \attack.kr(0.0000001),
           rel = \release.kr(0.1),
           noise_attack = \nattack.kr(1e-08),
           noise_sustain = \nsustain.kr(0.016),
           noise_rel = \nrel.kr(0.1),
           noise_vol = \nvol.kr(0.073),
           dur = \length.ir(0.5),
           gain = \gain.ir(1.0),
           env = Env.new(levels: [0, 1, 0], times: [0.000001, dur]);
           snd = OBassSnare.ar(Impulse.ar(impfreq),
                       osc_1_freq: osc1,
                       osc_2_freq: osc2, 
                       triangle_freq: trifreq,
                       flt_frq: fltfreq,
                       flt_q: fltq,
                       flt_gain: fltgain,
                       modulation_freq: modfreq,
                       noise_sustain: 0.2,
                       noise_vol: 0.05,
                       noise_rel: 0.01) * EnvGen.kr(env, doneAction: Done.freeSelf);
           Out.ar(0, snd * gain);
       }).add
       )
     #+end_src

#+name: bsnare_play
     #+begin_src sclang :results none
       ~bsnare = Synth.new("bsnare", [\impfreq, 0, \mod_freq, 0]);
     #+end_src

     #+begin_src sclang :results none
       SynthDef(\odisp_snare, {
	   var impfreq = \impfreq.kr(1), position = \pos.kr(0), disperse = \disperse.kr(1), attack = \attack.kr(1e-08),
	   noise_attack = \nattack.kr(1e-08), noise_lvl = \nlevel.kr(0.1), noise_rel = \nrel.kr(0.1),
	   osc1 = \osc1freq.kr(330), osc2 = \osc2freq.kr(180), rel = \rel.kr(0.1),
	   trifreq = \trifreq.kr(111);
	   var snd;
	   var modulator = SinOsc.kr([1!16],[0.1!16]);
	   snd = ODispersedSnare.ar(Impulse.ar(impfreq),
	       osc_1_freq: osc1, osc_2_freq: osc2,
	       triangle_freq: trifreq);
	   Out.ar(position, snd);
       }).add;
     #+end_src

     #+begin_src sclang :results none
       ~snare = Synth.new("odisp_snare", [\impfreq, 30, \disperse, 0]);
       s.meter;
     #+end_src

**** pbind for bsnare
     #+begin_src sclang :results none
       (
       ~bsnare_player = Pbind(
	   \instrument, \bsnare,
	   \dur, 0.5,
	   \impfreq, Pwhite(1, 4, inf),
	   \mod_freq, 0,
	   \fltfrq, Pwhite(100, 200, inf),
	   \fltq, Pseq((1..60) / 60, inf),
	   \fltgain, Pseq(1 / (1..10), 20),
	   \fltfreq, Pseq((100..200), 20)
       ).play;
       )
     #+end_src
*** snare 5: isnaredisp 
**** synthdef
     #+name: flt_snare_dispersed
     #+begin_src sclang :results none
       (
       ~isnaredisp = SynthDef(\isnaredisp, {
	   var snd,
	   o_offset = \offset.ir(0),
	   period = \pulse_period.kr(5000),
	   random = \random.ir(1),
	   osc1 = \osc1.kr(50),
	   osc2 = \osc2.kr(60),
	   tri = \triangle.kr(90),
	   noise_lvl = \noise_lvl.kr(0.1),
	   noise_attack = \noise_attack.kr(0.0001),
	   noise_rel = \noise_rel.kr(0.1);
	   snd = IFilteredSnareDispersed.ar(
	       offset: o_offset,
	       random: random,
	       tempo: period,
	       osc_1_freq: osc1,
	       osc_2_freq: osc2,
	       triangle_freq: tri,
	       noise_lvl: noise_lvl,
	       noise_attack: noise_attack,
	       noise_rel: noise_rel);
	   Out.ar(0, snd);
       }).add
       )
     #+end_src

     Start it up
     #+begin_src sclang :results none
       ~ifiltsnare = Synth.new("isnaredisp", [\pulse_period, 10000, \random, 0, \offset, 0]);
s.meter;
     #+end_src

     Control the speed via a slider.
    #+begin_src sclang :results none
      (
      w = Window.new.front;
      b = NumberBox(w, Rect(20, 20, 150, 20));
      a = Slider(w, Rect(20, 60, 150, 20)).action_({
	  b.value_(a.value);
	  ~ifiltsnare.set(\pulse_period, (a.value * 48000));
      });
      a.action.value;
      )     
    #+end_src

*** snare 6: ambisonics
**** synthdef
     Simple instance of a snare synth

     #+begin_src sclang :results none :noweb yes
       <<boot_jack>>
     #+end_src

     #+name: original_snare_two
     #+begin_src sclang :results none
       (
       ~snare_one = SynthDef(\snare, { | gain=1, freq=2000, vol=4, q=1, out=0 |
	   var snd;
	   var env = Env([0, 1, 0], [0.0001, 0.5]);
	   snd = IGenericSnarefs.ar(freq) * EnvGen.kr(env, doneAction: Done.freeSelf);
	   snd = snd * 0.2;
	   Out.ar(out, snd);
       }).add;
       )
     #+end_src

     #+begin_src sclang :results none
       ~snare_one.free;
     #+end_src

**** player
     Play one hit on the snare above.
     #+name: reg_snare_load
     #+begin_src sclang :results none
       ~reg_snare = Synth.new("snare", [\freq, 2000, \out, 0, \q, 6] );
     #+end_src
     
     Pbind for ambisonics
     #+name: player
     #+begin_src sclang :results none
       Pbind(\instrument, \snare,
	   \freq, 3000,
	   \out, 0,
	   \dur, Prand([0.1, 0.2], inf)
       ).play;
       s.meter;
     #+end_src
     
     #+call: play()

     Double player
     #+name: play
     #+begin_src sclang :results none
       ~a_player = Pbind(\instrument, \snare,
	       \freq, 3000,
	       \out, 31,
	       \dur, 0.1,
	       \freq, 300
       ); 
       ~b_player = Pbind(\instrument, \snare,
	       \freq, 1000,
	       \out, 33,
	       \dur, 0.2
       );
       ~a_player.play;
       ~b_player.play;
       s.meter;
     #+end_src

     #+begin_src sclang :results none
       ~a_player.stop;
       ~b_player.stop;
     #+end_src
     
     #+call: connect()

**** ambisonics
     
***** 1D114 3rd order
      Set the environment variables, then, create the encoder and the decoder.
      Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
      #+name: encode
      #+begin_src sclang :results none
	(
	// Settings
	~order = 3;
	~hoaNumChannels = (~order+1).pow(2);
	~decoderNumChannels = 16;
	s.scope(~hoaNumChannels);

	// Create the input bus and the encoder
	~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);

	// hoaSignal.source och hoaSignal.add verkar fungera lika bra.
	~hoaSignal.put(0, {HOAEncoder.ar(~order, In.ar(17, 1), \azpana.kr(3.14), \elpana.kr(3.14))});
	~hoaSignal.put(1, ({HOAEncoder.ar(~order, In.ar(19, 1), \azpanb.kr(3.14), \elpanb.kr(3.14))}));
	~hoaSignal.fadeTime = 1;

	// Decoder
	~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
	~decoder.source = {
	    var in; in = \in.ar(0!~hoaNumChannels);
	    in.add(0);
	    KMH114AEC3h3pFull6.ar(*in);
	};
	~decoder.fadeTime = 1;
	)
      #+end_src

      Print the possible control keys for this NodeProxy
      #+begin_src sclang :results none
	~hoaSignal.controlKeys;
      #+end_src
      
      Clear the instances
      #+begin_src sclang :results none
	~hoaSignal.clear;
	~azimuthA.clear;
	~decoder.clear;
      #+end_src
***** 1D108 3rd order
      Start the player
      #+call: play()
      Start the encoder
      #+call: encode()
      Connect the encoder with the decoder
      #+call: connect()


      Set the environment variables, then, create the encoder and the decoder.
      Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
      See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
      #+name: encode
      #+begin_src sclang :results none :noweb yes
	(
	 // Settings
	 ~order = 3;
	 ~hoaNumChannels = (~order+1).pow(2);
	 ~decoderNumChannels = 8;
	 //s.scope(~hoaNumChannels);

	 // Create the input bus and the encoder
	 ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
	 //~hoaSignal.play;

	 // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
	 ~hoaSignal[0] = { HOAEncoder.ar(~order, In.ar(17, 1), \azpana.kr(-3.14), \elpana.kr(0), \gaina.kr(0), plane_spherical:1) };
	 ~hoaSignal[1] = { HOAEncoder.ar(~order, In.ar(19, 1), \azpanb.kr(-3.14), \elpanb.kr(0),  plane_spherical:1) };
	 ~hoaSignal.fadeTime = 0.1;

	 // Panning automation
	 // Create a new panner NodeProxy
	 ~azimuthA = NodeProxy.control(s, 1);
	 ~azimuthB = NodeProxy.control(s, 1);

	 // Set its source to a control signal 
	 ~azimuthA.source = { MouseX.kr(-pi, pi); };
//	 ~azimuthA.source = { SinOsc.kr(0.1, 0, 0.7pi, 0); };
	 ~azimuthB.source = { SinOsc.kr(0.2, 0, 0.5pi, 0); };

	 // Call .set on the object you want to control given the parameter and the control proxy as arguments

	 ~hoaSignal.set(\azpana, ~azimuthA);
//	 ~hoaSignal.set(\azpanb, ~azimuthB);
//	 ~azimuthA.play;
//	 ~azimuthB.play;

	 // Decoder
	 ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
	 ~decoder.source = {
	     var in; in = \in.ar(0!~hoaNumChannels);
	     in.add(0);
	     KMH108AE3h3pNormal6.ar(*in);
	 };
	 ~decoder.fadeTime = 1;
	 )
      #+end_src
      
      Clear the instances
      #+begin_src sclang :results none
	~hoaSignal.clear;
	~azimuthA.clear;
	~decoder.clear;
      #+end_src

      Control the panning position A
      #+begin_src sclang :results none
	~hoaSignal.set(\azpana, 3.14);
	~hoaSignal.set(\elpana, 3.14);
	~hoaSignal.set(\azpanb, 3.14);
	~hoaSignal.set(\elpanb, 3.14);
      #+end_src

      Control the panning position B
      #+begin_src sclang :results none
	~hoaSignal.set(\azpana, 0);
	~hoaSignal.set(\elpana, 0);
	~hoaSignal.set(\azpanb, 0);
	~hoaSignal.set(\elpanb, 0);
      #+end_src

     Control the panning position B
      #+begin_src sclang :results none
	~hoaSignal.set(\azpana, -3.14);
	~hoaSignal.set(\elpana, -3.14);
	~hoaSignal.set(\azpanb, -3.14);
	~hoaSignal.set(\elpanb, -3.14);
      #+end_src

     Control the panning position B
      #+begin_src sclang :results none
	~hoaSignal.set(\azpana, 1.25);
	~hoaSignal.set(\elpana, 1.25);
	~hoaSignal.set(\azpanb, 1.25);
	~hoaSignal.set(\elpanb, 1.25);
      #+end_src

***** Lilla salen 3rd order
      Start server
      #+call: boot_jack()
      Start the player
      #+call: play()
      Start the encoder
      #+call: l_encode()
      Connect the encoder with the decoder
      #+call: connect()

      #+begin_src sclang :results none

      #+end_src
      Set the environment variables, then, create the encoder and the decoder.
      Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
      See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
      #+name: l_encode
      #+begin_src sclang :results none :noweb yes
	(
	// Settings
	var trig;
	~order = 3;
	~hoaNumChannels = (~order+1).pow(2);
	~decoderNumChannels = 29;
	//s.scope(~hoaNumChannels);

	// Create the input bus and the encoder
	~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
	//~hoaSignal.play;

	// hoaSignal.source och hoaSignal.add verkar fungera lika bra.
	~hoaSignal[0] = { HOAEncoder13.ar(In.ar(31, 1), \gaina.kr(0), \rad.kr(2), \azpana.kr(-3.14), \elpana.kr(0)) };
	~hoaSignal[1] = { HOAEncoder13.ar(In.ar(33, 1), \gaina.kr(0), \rad.kr(2), \azpanb.kr(-3.14), \elpanb.kr(0)) };
	~hoaSignal.fadeTime = 0.1;

	// Panning automation
	// Create a new panner NodeProxy
	~azimuthA = NodeProxy.control(s, 1);
	~azimuthB = NodeProxy.control(s, 1);
	~elevationA = NodeProxy.control(s, 1);
	~elevationB = NodeProxy.control(s, 1);
	~radiusA = NodeProxy.control(s, 1);

	// Set its source to a control signal 
	// The HOAencoder used above has 0 deg in front moving counter 
	// clockwise to 360 deg at front again.
	// 90 deg Y-axis is top and -90 is bottom

	// ~azimuthA.source = { MouseX.kr(0, 360); };
	// ~azimuthB.source = { MouseX.kr(0, 360); };
	// ~elevationA.source = { MouseY.kr(-90, 90); };
	// ~elevationB.source = { MouseY.kr(-90, 90); };
		trig = Impulse.kr(0.01);
	~azimuthA.source = { LinLin.kr(Phasor.kr(Impulse.kr(0.5), 0.5/ControlRate.ir), 0, 1, 0, 360); };
	~azimuthB.source = { LinLin.kr(Phasor.kr(Impulse.kr(0.5), 0.5/ControlRate.ir), 0, 1, 0, 360); };
	//~radiusA.source = { MouseX.kr(360, 1); };

	// Call .set on the object you want to control given the parameter and the control proxy as arguments
	~hoaSignal.set(\azpana, ~azimuthA);
	~hoaSignal.set(\azpanb, ~azimuthB);
	~hoaSignal.set(\elpana, ~elevationA);
	~hoaSignal.set(\elpanb, ~elevationB);
	~hoaSignal.set(\rad, ~radiusA);

	// Decoder
	~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
	~decoder.source = {
	    var in; in = \in.ar(0!~hoaNumChannels);
	    in.add(-10);
	    KMHLSDome3h3pNormal6.ar(*in);
	};
	~decoder.fadeTime = 1;
	)
      #+end_src
      
      Clear the instances
      #+begin_src sclang :results none
	~hoaSignal.clear;
	~azimuthA.clear;
	~decoder.clear;
      #+end_src
***** panning
      Panning instrument
      #+name: snare_panner
      #+begin_src sclang :results none
	~hoaSignal.set(\azpana, In.kr();
      #+end_src

***** Connect
      Signal, encoded and decoded, but not mapped. Use this.
      #+name: connect
      #+begin_src sclang :results none
	(
	~decoder.play(0, ~decoderNumChannels, vol: 16.0);
	~hoaSignal <>> ~decoder;
	)
      #+end_src

***** Disconnect
      #+begin_src sclang :results none
	~decoder.clear;
	~hoaSignal.clear;
	~hoaSignalA.clear;
	~hoaSignalB.clear;
      #+end_src

*** snare 7: convolution
**** synthdef
     #+begin_src sclang :results none
       (
       SynthDef(\isnare, { | outBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, pulse=200, dur=1, distance=0 |
	   var snd, rev;
	   var env = Env([0, 1, 0], [0.0001, 0.5]);
	   snd = IDispersedSnare.ar(position, disperse, pulse) * EnvGen.kr(env, timeScale: dur, doneAction: Done.freeSelf);
	   rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
	   Out.ar(outBus, snd);
       }).add;
       )
     #+end_src

     Named controls
     #+begin_src sclang :results none
	      (
	      SynthDef(\isnarenc, {
		  var snd;
		  var env = Env([0, 1, 0], [0.0001, 0.5]);
		  snd = ODispersedSnare.ar(Impulse.ar(\pulse.ar(440)), \position.kr(0), \disperse.kr(0)) * EnvGen.kr(env, timeScale: \dur.kr(1), doneAction: Done.freeSelf);
       //	   rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
		  Out.ar(\outBus.ir, snd);
	      }).add;
	      )
     #+end_src
     
**** player
     #+begin_src sclang :results none
       (
       a = Array.fill(16, { arg i; (i + 1) / 16 });
       Pbind (\instrument, \isnarenc,
	   //	   \position, Pseq((0..29), inf),
	   \position, 0,
	   \outBus, 0,
	   \disperse, 0.0,
	   \pulse, 10000,
	   \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
	   \gain, Pseq(a, inf),
	   \distance, Pseq(a.reverse, inf),
	   \dur, 2
       ).play;
       )
//       s.meter;
     #+end_src

     #+begin_src sclang :results none
       (
       a = Array.fill(16, { arg i; (i + 1) / 16 });
       Pbind (\instrument, \isnare,
	   \position, Pseq((0..29), inf),
	   \disperse, 0.0,
	   \impf, 80000, //Pfunc({30.rand2}),
	   \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
	   \gain, Pseq(a, 16),
	   \distance, Pseq(a.reverse, 16),
	   \dur, 1
       ).play;
       )

       (
       Pbind (\instrument, \isnare,
	   \position, 1,
	   \distance, Pseq([0, 0.1, 0.2, 0.3, 0.4, 0.5], 10),
	   \disperse, 0,
	   \impf, 10000,
	   \dur, 1,
	   \delta, 0
       ).play;
       )
     #+end_src

**** convolution
       preparation; essentially, allocate an impulse response buffer, then
        follow a special buffer preparation step to set up the data the plugin needs.
        Different options are provided commented out for loading impulse responses from soundfiles.
 

     #+begin_src sclang :results none

       (
       â
       // also 4096 works on my machine; 1024 too often and amortisation too pushed, 8192 more high load FFT
       ~fftsize = 4096;
       â
       s.waitForBoot {
	       â
	       {
		       var ir, irbuffer, bufsize;
		       â
		       // // MONO ONLY
		       // pre-existing impulse response sound files
		       // (could also use any general soundfile too for cross-synthesis effects)
		       // irbuffer = Buffer.read(s, "/Volumes/data/audio/ir/ir2.wav");
		       â
		       // synthesise the honourable 'Dan Stowell' impulse response
		       â
		       ir = [1] ++ 0.dup(100) ++ (
			       (1, 0.99998 .. 0)
			       .collect {|f|
				       f = f.squared.squared;
				       f = if(f.coin) { 0 }{ f.squared };
				       f = if(0.5.coin) { 0 - f } { f }
			       } * 0.1
		       );
		       ir = ir.normalizeSum;
		       â
		       irbuffer = Buffer.loadCollection(s, ir);
		       â
		       s.sync;
		       â
		       bufsize = PartConv.calcBufSize(~fftsize, irbuffer);
		       â
		       // ~numpartitions= PartConv.calcNumPartitions(~fftsize, irbuffer);
		       â
		       ~irspectrum = Buffer.alloc(s, bufsize, 1);
		       ~irspectrum.preparePartConv(irbuffer, ~fftsize);
		       â
		       s.sync;
		       â
		       irbuffer.free; // don't need time domain data anymore, just needed spectral version
	       }.fork;
	       â
       }
       )
       â
       ~target = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

       (
       {
	       var input = PlayBuf.ar(1, ~target, loop:1);
	       var rev = PartConv.ar(input, ~fftsize, ~irspectrum.bufnum, 0.5);
	       var mix = (input * 0) + (rev * 1);
	       Out.ar(0, mix);
       }.play
       )

       (
       {
	       PlayBuf.ar(1, ~target, loop:1);
       }).play

     #+end_src
     
*** snare 8: polyrhythmic
**** synthdef
     #+begin_src sclang :results none
       (
       SynthDef(\isnarePoly, { arg busA, busB;
	       var snd, env, envelope, duration=1, pulse, nlvl;
	       /* Envelope and duration */
	       envelope = Env.new(levels: [0, 1, 0.9, 0], times: [0.1, 0.5, 0.01], curve:[-5, 0, -5]);
	       b = 0;
	       envelope.times.do({ arg i; b = b + i; });
	       duration = \dur.ir / b;
	       env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);
	       /* Parameter: pulse */
	       pulse = In.kr(busA) + \pulse.kr(0);
	       /*
		       Parameter: noislevel.
		       Scale it to pulse
	       ,*/
	       nlvl = LinExp.kr(pulse, 1, 200, 2, 0.000001);
	       snd = ISnarePhaseDisp.ar(\pos.kr(0),
		       \disperse.kr(0),
		       pulse,
		       \amp.kr(0.2),
		       \attack.kr(0.0001),
		       \fsweep.kr(0),
		       \nattack.kr(0.0001),
		       nlvl,
		       \nrel.kr(0.01),
		       \osc1.kr(300),
		       \osc2.kr(140),
		       \rel.kr(0.01),
		       \tri.kr(130));
	       Out.ar(\outBus.ir, snd*env);
       }).add;
       )
     #+end_src

     #+begin_src sclang :results none
       (
       SynthDef(\controlSnare, { arg out;
	   var trig, x, sr, rt;
	   Out.kr(out, Line.kr(\start.kr(1), \end.ir(100), \dur.ir(1), doneAction: Done.freeSelf));
       }).add;
       )
     #+end_src

     #+begin_src sclang :results none
       { Poll.kr(Impulse.kr(10), LinExp.kr(Line.kr(1, 100, 5, doneAction: Done.freeSelf), 1, 200, 0.9, 0.00001)) }.play;
     #+end_src
**** player

     To play the ISnarePhaseDisp:
     #+begin_src sclang :results none
       (
       a =Synth.new(\controlSnare, [\out, 1]
       );
       //a = Synth.new(\isnarePoly, [\pulse, 440, \dur, 4]);
       //       b = Env.new(levels: [0, 1, 0], times: [0.5, 0.5]);
       //       e = EnvGen.kr(b, doneAction: Done.freeSelf);
       )
     #+end_src
     #+begin_src sclang :results none
       a.free;
     #+end_src
     #+begin_src sclang :results none
       s.reboot; // this will restart the server and thus reset the bus allocators
     #+end_src

     #+begin_src sclang :results none
       (
       var busA, busB, dur;
       dur = 24;
       busA = Bus.control(s, 1);
       busB = Bus.control(s, 1);
       y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.1, \end, 300]);
       x = Synth.after(y, \isnarePoly, [\pos, 2,\pulse, 1, \dur, dur, \busA, busA.index]);
       )
     #+end_src

         #+begin_src sclang :results none
       (
       var busA, busB, dur;
       dur = 24;
       busA = Bus.control(s, 1);
       busB = Bus.control(s, 1);
       y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.00001, \end, 200]);
       x = Synth.after(y, \isnarePoly, [\pos, 14, \pulse, 0, \dur, dur, \busA, busA.index]);
       )
     #+end_src
     
     #+begin_src sclang :results none
       (
       f = {
	       Task ({
		       loop {
			       100.do({ |val|
				       a.set(\pulse, 5 * val);
				       val.postln;
				       0.1.wait;
			       });
		       }
	       });
       };
       u = f.value.play;
       )

     #+end_src
** pbind for accelerando
   This is the pbind for the acc defined here: [[*accelerando, fixed tempo][accelerando, fixed tempo]]
   The Synthdef is here: [[*synthdef][snare]]
   #+name: accelerando_accent
   #+begin_src sclang :results none :noweb yes
     (
     var seq = { |length=4|
	 { |x=0| x+1; if(x==0, {1.0}, {0.01})} ! length;
     };

     ~accent = Pbind(
	 \instrument, \snare,
	 \gain, Pdefn(\accents),
	 \dur, Pdefn(\duration),
	\out, 0
     );
     Pdefn(\accents, Pseq(seq.value(4), 1));
     Pdefn(\duration, 1);
     )
   #+end_src

   Second instance
   #+name: accelerando_accent_two
   #+begin_src sclang :results none :noweb yes
     (
     var seq = { |length=4|
	 { |x=0| x+1; if(x==0, {1.0}, {0.01})} ! length;
     };

     ~accenti = Pbind(
	 \instrument, \snare,
	 \gain, Pdefn(\accents),
	 \dur, Pdefn(\duration),
	\out, 1
     );
     Pdefn(\accents, Pseq(seq.value(4), 1));
     Pdefn(\duration, 1);
     )
   #+end_src
** beat
*** drumloop
#+begin_src sclang :results none
p = Plambda(
    Pbind(
        \a, Plet(\z, Pseries(0, 1, inf), Pseries(100, -1, inf)),
        \b, Pget(\z, 0, inf) * 2
    ).trace(key: \eventScope, prefix: "\nscope: ")
).asStream;

p.next(());
#+end_src

#+begin_src sclang :results none
(
var a, b, c, t;
a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
c = Ppar([a, b]);
t = c.asStream;
20.do({ t.next(Event.default).postln; });
)
#+end_src

#+call: bsnare()
#+call: original_snare()
#+call: i_snare_phase_2()
#+call: bsnare_play()

#+begin_src sclang :results none
  Synth.new("snare_phase", [\pulse, 1, \nlevel, 0]);
#+end_src

Bass drum pulse with variation
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
          \instrument, \bsnare,
          \impfreq, 0,
          \length, 0.2,
          \osc1, 80,
          \osc2, 50,
          \trifreq, 70,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \release, 0.9,
          \dur, beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / originalTempo }
  ).play;
#+end_src

Snare drum beat
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
          \instrument, \snare,
	\impf, 10,
          \freq, 400,
          \trifreq, 100,
          \length, 0.2,
          \out, 1,
          \gain, 1,
          \dur, beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / originalTempo}
  ).play;
#+end_src

Global variables
#+name: global_tempo
#+begin_src sclang :results none
  ~beatsInLoop = 8;
  ~originalTempo = 90 / 60;
  TempoClock.tempo = ~originalTempo;
#+end_src

First bass drum pattern
#+name: b_drum_1
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_1  = Pbind (
          \instrument, \bsnare,
          \impfreq, 100,
          \osc1, 80,
          \osc2, 70,
          \trifreq, 70,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \gain, 4,
          \release, 0.9,
          \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.3,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  );
#+end_src

First bass drum pattern
#+name: b_drum_2
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_2  = Pbind (
          \instrument, \bsnare,
          \impfreq, 1,
          \osc1, 70,
          \osc2, 50,
          \trifreq, 75,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \gain, 4,
          \release, 0.9,
          \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.5,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  ).play;
#+end_src

First snare drum
#+name: s_drum_1
#+begin_src sclang :results none
  ~loop_snare_1 = Pbind (
          \instrument, \snare,
          \impf, Prand([~originalTempo, ~originalTempo*7, ~originalTempo*9], inf),
          \freq, Pseq([100, 200], inf),
          \trifreq, 500,
          \length, Prand((40..80), inf) * 0.01,
          \out, 0,
          \gain, 0.05,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_2
#+begin_src sclang :results none
  ~loop_snare_2 = Pbind(
          \instrument, \snare,
          \impf, Prand([~originalTempo, ~originalTempo*2, ~originalTempo*3, ~originalTempo*4], inf),
          \freq, Pseq([500, 520, 530], inf),
          \trifreq, 50,
          \length, Prand((80..150), inf) * 0.01,
          \out, 1,
          \gain, 0.2,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_3
#+begin_src sclang :results none
  ~loop_snare_3 = Pbind(
          \instrument, \snare_phase_2,
          \freq, Pseq([400, 500], inf),
          \freq2, Pseq([400, 550], inf),	
          \length, Prand((70..100), inf) * 0.01,
          \out, 1,
          \gain, 0.4,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+begin_src sclang :results none
s.meter;
#+end_src
Attempt to make a complete beat with variation.
#+begin_src sclang :results none :noweb yes
  (
  <<global_tempo()>>;
  <<b_drum_1()>>;
  <<b_drum_2()>>;
  <<s_drum_1()>>;
  <<s_drum_2()>>;
  <<s_drum_3()>>;
  p = Ptpar([
          0, ~loop_bass_dr_1,
          0.5, ~loop_bass_dr_2,
          0.75, Pn(
                  ~loop_snare_1	
          ),
          1, Pn(
                  Plazy {
                          ~loop_snare_2	
                  }	
          ),
          2, ~loop_bass_dr_1,
          2.75, ~loop_bass_dr_2,
          3, Pn(
                  ~loop_snare_3
          ),
          4.5, ~loop_bass_dr_1,
          4.75, ~loop_bass_dr_2,
          5, Pn(
                  Plazy {
                          ~loop_snare_2	
                  }	
          ),
          6, ~loop_bass_dr_1,
          6, ~loop_bass_dr_2,
          7, Pn(
                  ~loop_snare_3
          )
  ], 1).play;
  )

#+end_src
** accelerando, fixed tempo
   This actually works in a weird way.
   - Why are the beats sometimes doubled?

   Uses the original snare in this instance
   #+call: original_snare()
   
   Use this Pbind: [[*pbind for accelerando][pbind for accelerando]]
   #+call: accelerando_accent()
   #+call: accelerando_accent_two()

   Play one segment
   #+begin_src sclang :results none
     var seq = { |length=4|
	     { |x=0| x+1; if(x==0, {1.0}, {rrand(0.17, 0.3)})} ! length;
     };
     ~accent.play(quant: 0, clock: TempoClock(4));
     Pdefn(\accents, Pseq(seq.value(6), 1))
   #+end_src

   Create a accent array
   #+begin_src sclang :results none
     (
     var seq = { |length=4|
	     { |x=0| x+1; if(x==0, {1.0}, {rrand(0.1, 0.2)})} ! length;
     };
     seq.value(4).postln;
     )
   #+end_src
   
   Call the function
   #+begin_src sclang :results none
     f.value(1.2, 1, ~accenti);
   #+end_src

   Call two praces going in opposite tempo directions
   #+begin_src sclang :results none
     (
     f.value(0.8, 32, ~accent);
     f.value(1.2, 1, ~accenti);
     )
   #+end_src

   Main routine that creates arrays of snare hits 
   #+begin_src sclang :results none :noweb yes :tangle yes
     f = { arg mul=1, tpo=1, player=~accent;
	     var multiplier = mul; //the multiplier, lower than one for deaccelerando
	     var tClock, beatsPB=2;
	     var seq = { |length=4|
		     { |x=0| x+1; if(x==0, {1.0}, {rrand(0.2, 0.27)})} ! length;
	     };

	     tClock = TempoClock(tpo); //start time is 1
	     player.play(quant: 0, clock: tClock);
	     fork {
		     loop {
			     var barDur = 4; // Duration in seconds
			     var beatsPerBar = ~beatsPerBar;
			     tClock.tempo = tClock.tempo * multiplier;
			     "Tempo:".postln;
			     tClock.tempo.postln;
			     if((tClock.beatDur*(beatsPerBar+1)) < barDur,
				     {
					     var beatsToAdd = 1;
					     "Length of bar + 1 beat".postln;
					     (tClock.beatDur*(beatsPerBar+1)).postln;
					     (
						     i = 1;
						     while( {(tClock.beatDur*(beatsPerBar+i)) < barDur }, {i = i+1; beatsToAdd = i});
					     );
					     beatsToAdd.postln;
					     beatsPerBar = beatsPerBar + beatsToAdd;
					     Pdefn(\accents, Pseq(seq.value(beatsPerBar), 1))
				     },
				     {
					     "Length of bar".postln;
					     (tClock.beatDur*beatsPerBar).postln;
					     ((tClock.beatDur*beatsPerBar)/tClock.beatDur).postln
				     });
			     (tClock.beatDur*beatsPerBar).wait;
			     player.play(quant: 0, clock: tClock);
		     }
	     };
     }
   #+end_src
   
** poly rhythm
   #+begin_src sclang :results none
     (
     ~task = {
	     ~clock = TempoClock(600);
	     ~denom = Pbind(
		     \instrument, \snare,
		     \dur, 7,
		     \freq, 400,
		     \noiselvl, 0.01,
		     \rel, 0.1,
		     \gain, 2
	     );
	     ~nom = Pbind(
		     \instrument, \snare,
		     \dur, 8,
		     \freq, 400,
		     \noiselvl, 0.01,
		     \rel, 0.5,
		     \gain, 2,
		     \trifrq, 400,
		     \freq, 400
	     );
	     ~poly = Ppar([~nom, ~denom]).play(quant: 0, clock: ~clock);
     }
     )
   #+end_src

   #+begin_src sclang :results none
     ~task.value;
     ~clock.stop;
     ~clock.tempo = 50;
     ~clock.tempo = 500;
     ~clock.beatsPerBar = 9
   #+end_src

** osc
*** set netaddress to 'b'
    #+name: set_netaddress
    #+begin_src sclang :results none
      b = NetAddr.new("127.0.0.1", 5510);
    #+end_src
*** routine to play 10 hits
    #+begin_src sclang :results none :noweb yes
      <<set_netaddress()>>
      // the value can also be a stream or a function
      (
      r = Routine {
	  10.do( { 
	      b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	      0.01.wait;
	      b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	      0.1.wait;
	  });
      }.play;
      );
    #+end_src
*** task in loop
    #+begin_src sclang :results none
      b = NetAddr.new("127.0.0.1", 5510);
      t = Task({ { 
	  b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	  0.01.wait;
	  b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	  1.wait;
      }.loop });
      t.start;
    #+end_src
    #+begin_src sclang :results none
      t.stop;
    #+end_src
*** pbind for osc
    Sending OSC messages from a Pbind.
    #+begin_src sclang :results none
      (
      ~play = Pbind(
	  \dur, 1,
	  \odur, Pfunc {|ev| b.sendMsg("/o_dispersed_snare/impulse/play", 1)},
	  \sdur, Pfunc {|ev| b.sendMsg("//o_dispersed_snare/impulse/play", 0)}
      ));

      ~play.play;
    #+end_src
*** definition of ~play
    This is made to deal with the faust 'gate' not resetting itself.
    Set the netaddress and register the routine.
    #+name: set_play
    #+begin_src sclang :results none
      (
      ~play = {
	  1.do{
	      b.sendMsg("/o_dispersed_snare/impulse/play", 1);
	      0.01.wait;
	      b.sendMsg("/o_dispersed_snare/impulse/play", 0);
	  }
      }
      )
    #+end_src
    Play the routine above:
    #+begin_src sclang :results none
      ~play.fork
    #+end_src
    #+name: set_play_dep
    #+begin_src shell :results none :noweb yes
      <<set_netaddress()>>
      <<set_play()>>
    #+end_src
*** play routine 1
    Depends on [[*deal with faust 'gate'][deal with faust 'gate']]
    #+begin_src sclang :results none
      (
      r = Routine {
	  0.5.idle(2);
	  0.25.idle(2);
	  0.125.idle(2);
	  0.0625.idle(2);
      };
      fork {
	  loop {
	      var rest = r.value;
	      rest.postln;
	      ~play.fork;
	      rest.wait;
	  }
      }
      );
    #+end_src
*** play routine 2
    Parameters are:
    1. a scaling factor (default to one)
    2. the number of notes to play.
    Depends on the definition of ~~play~      
    #+begin_src sclang :results none :noweb yes
      <<set_play()>>
      <<p_random_rhythm_rout()>>
      <<p_random_rhythm()>>
    #+end_src
    #+name: p_random_rhythm_rout
    #+begin_src sclang :results none :noweb yes
      (
      l = Routine { arg in=1, reps=10;
	  var length = 1;
	  p = Prand([0.5, 0.25, 0.125, 1], inf);
	  q = p.asStream;
	  50.do { |i=0|
	      q.next.postln;
	      length = q.next * in;
	      b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [200, 300, 400].choose);
	      b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [210, 320, 440].choose);
	      ~play.fork;
	      q.next.wait;
	  }
      }
      )
    #+end_src
    #+name: p_random_rhythm 
    #+begin_src sclang :results none
      l.play.value(1, 100);
    #+end_src
*** play routine 3
    #+begin_src sclang :results none
      (
      var osc1freq = Array.fill(10, { (100.rand*2)+100 });
      ~playme = Pbind(
	  \dur, Prand([0.1, 0.15, 0.05, 0.2, 0.25, 0.3], inf),
	  \play, Pfunc({[~play.fork, ~play.fork]}),
	  \osc1f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [ 190, 174, 178, 204, 138, 218, 232, 222, 276, 158 ].choose)}),
	  \osc2f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [200, 300, 400, 500, 450, 350, 250, 150].choose)}),
	  \noise_rel, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_rel", 0.1.linrand + 0.012 )}),
	  \noise_lvl, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_lvl", 0.5.linrand + 0.012 )}),
	  \noise_attack, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_attack", 0.1.linrand )}),
      ).play;
      )
    #+end_src

*** play routine 4
    #+begin_src sclang :results none
      (
      var durs = Array.new(64);
      a = (1!4);
      b = (0.5!8);
      c = (0.25!16);
      d = (0.125!32);
      durs = a ++ b;
      durs = durs ++ c;
      durs = durs ++ d;
      ~playme = Pbind(
	  \dur, Pseq(durs, inf),
	  \play, Pn(Pfunc({~play.fork}), inf)
      ).play;
      )
    #+end_src
** archive
   Synth that is driven by an Impulse pulse generator.
   Load first the two SynthDefs below and use a global variable of ~isnare for the snare synth:
   #+begin_src sclang :results none
     (
     // Here is where the bus object is created in a global variable:
     ~controlBus_1 = Bus.control(s, 1);
     SynthDef(\isnare, { | outBus=0, inBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0 |
	 var snd;
	 var trig = In.ar(~impBus.index, 1);
	 snd = IDispersedSnare.ar(trig, position, disperse, osc_1_freq: osc1, osc_2_freq: osc2, triangle_freq: tri) * gain;
	 Out.ar(outBus, snd);
     }).add;

     SynthDef(\impulseA, { | effectBus=0, freq=1 |
	 var outB;
	 // Only to automatically free each instance
	 var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
	 outB = Impulse.ar(freq);
	 Out.ar(~impBus.index, outB);
     }).add;

     SynthDef(\control_synth, { | bus |
	 Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
     }).send(s);
     )
   #+end_src

   ... and then instantiate the main synth:
   #+name: isnare_load
   #+begin_src sclang :results none
     ~sisnare = Synth.new("isnare", [\cBus, ~controlBus_1.index, \disperse, 0] );
   #+end_src

   Play one single shot:
   #+begin_src sclang :results none
     ~impulse = Synth.before(~sisnare, "impulseA", [\freq, 0]);
     ~c_synth = Synth.before(~sisnare, "control_synth", [\bus, ~controlBus_1.index]);
     //s.meter;
   #+end_src

   Set parameters
   #+begin_src sclang :results none
     ~impulse.set(\freq, 0);
     ~sisnare.set(\position, {In.kr(~controlBus_1.index)});
   #+end_src

*** routine loop
    #+begin_src sclang :results none
      (
      r = Routine({
	  var delta = 0;
	  loop {
	      delta = delta + 1;
	      "Will wait ".post; delta.postln;
	      0.5.yield;
	  }
      });
      )
    #+end_src
    #+begin_src sclang :results none
      r.next;

      TempoClock.default.sched(0, r);
    #+end_src
    #+begin_src sclang :results none
      r.stop;
    #+end_src

    


    
