#+STARTUP: indent overview hidestars

* Snare snippets
** audio init
Query interfaces
#+begin_src sclang :results none
  ServerOptions.devices;
  s.boot;
#+end_src

Set JackRouter to be the interface on Linux
#+name: boot_jack
#+begin_src sclang :results none
  (
  o = Server.local.options; // Get the local server's options
  o.numOutputBusChannels = 64;
  o.numWireBufs = 128;
  o.memSize = 65536;
  //     s.makeWindow;
  s.makeGui(p);
  s.boot;
  )
#+end_src

Query for node tree:
#+begin_src sclang :results none
  // in post window
  s.queryAllNodes(queryControls: false)
  // in a gui window
  //     s.plotTree(interval: 0.5);
#+end_src

#+begin_src sclang :results none
  s.quit;
#+end_src
** jack
*** status
#+begin_src shell
  jcon -c
#+end_src

*** startup
Load library async for these.
plain two channel interface, start asynchronous
#+begin_src shell :async
  startjack -r 48000 -c 2
#+end_src

Edirol
#+begin_src shell :async
  startjack -r 48000 -c 2 -d jp_co_roland_RDUSB00E6Dev_AudioEngine:14500000:0
#+end_src

#+begin_src shell
  startjack -l
#+end_src

*** jconvolver
Remember to load the library ob-async prior to testing these:

~M-x load-library ob-async~

On osx the directory should be: "~/Library/mcfx/convolver_presets/kmh_lilla_salen_29/"

To start jconvolver:
#+name: jconvolver
#+begin_src shell :async :dir /home/henrikfr/Music/spatialization/klangkupolen/gerhard/convolution_config/kmh_lilla_salen_29
  echo "Starting up jconvolver"
  jconvolver KMH_LILLA_SALEN.conf &
#+end_src

#+RESULTS: jconvolver
: 81168f108377c0471c3a01d4197f5c74

disconnect supercollider from main out$
#+begin_src shell
  for i in {1..2}; do
      jdis -d scsynth out$i system playback_$i
  done
#+end_src

connect supercollider to jconvolver
#+begin_src shell :results replace
  jcon scsyn out jcon in 16
  jcon jcon out system play 2
#+end_src

#+RESULTS:

connect only jconvolver to jack
#+begin_src shell 
  jcon jcon out sys play 2
#+end_src

*** connect multi to stereo
  - Odd multi output to left out
  - Even to right output
    #+begin_src shell
      for i in {2..16}; do
          if ((i % 2 == 0)); then
              jcon scsynth out$i sys playback_2 1;
          else 
              jcon scsynth out$i sys playback_1 1;
          fi
      done
    #+end_src

    specific version of the above.
    #+begin_src shell :results replace
      for i in 1 3 5 7 9 11 13 15; do 
          echo $i
          jcon scsynth out$i sys playback_1 1; 
      done
      for i in 2 4 6 8 10 12 14 16; do 
          echo $i
          jcon scsynth out$i sys playback_2 1; 
      done
    #+end_src

    Connect scsynth to jconvolver 
    #+begin_src shell :results replace
      for i in {1..16}; do
          echo $i
          jcon scsynth out$i jcon in_$i
      done
    #+end_src

    Disconnect scsynth from jconvolver 
    #+begin_src shell :results replace
      for i in {1..16}; do
          echo $i
          jdis -d scsynth out$i jcon in_$i
      done
      jdis -d scsynth out1 jcon in_1
    #+end_src

    Disconnect scsynth from jconvolver 
    #+begin_src shell :results replace
      for i in {1..16}; do
          jdis -d scsynth "out$i" jcon "in_$i";
      done
    #+end_src

    disconnect it
    #+begin_src shell :results replace
      for i in 1 3 5 7 9 11 13 15; do 
          echo $i
          jdis -d scsynth out$i sys playback_1;
      done
      for i in 2 4 6 8 10 12 14 16; do 
          echo $i
          jdis -d scsynth out$i sys playback_2;
      done
    #+end_src

*** disconnect stereo
#+begin_src shell :results replace
  for i in {1..2}; do
      echo "$i"
  done
#+end_src

#+begin_src shell :results replace
  array=(1 2 8 6 10 9 5 7)
  for i in {1..8}; do
      echo "$array[$i]"
  done
#+end_src

*** jack for i_dispersed_snare in 1D118
#+begin_src shell :results replace
  jdis -a
  for i in 1 3 5 7 9 11 13 15; do 
      echo $i
      jcon scsynth out$i sys playback_1 1; 
  done
  for i in 2 4 6 8 10 12 14 16; do 
      echo $i
      jcon scsynth out$i sys playback_2 1; 
  done
#+end_src
*** jack for i_dispersed_snare in 1D114, 8 channels
#+begin_src shell :results replace
  declare -a outs=(1 2 3 4 5 6 7 8)
  declare -a ins=(1 2 8 6 10 9 5 7)
  for i in {0..7}; do
      ##	 echo ${outs[$i]} ${ins[i]}
      jcon scsynth out${outs[$i]} sys playback_${ins[i]}
  done
#+end_src
*** jack for lilla salen
#+begin_src shell :results replace
  for i in {1..16}; do
      jcon scsynth out$i sys playback_$i
  done
#+end_src
    
** recorder
#+property: header-args:shell :var dir="/Users/henrik_frisk/Music/pieces/snares/audio/"

#+name: record_me
#+begin_src sclang :results none
  s.prepareForRecord("~/Music/single.wav", numChannels: 16);
  s.record;
#+end_src
#+name: rename_file
#+begin_src shell :var fname="isnare_filter_routine.wav"
  file="/Users/henrik_frisk/Music/single.wav"
  mv "$file" "$dir$fname"
  echo "Moved $file to $dir and renamed it $fname"
#+end_src

#+begin_src sclang :results none
  s.pauseRecording;
#+end_src
   
#+name: stop_record
#+begin_src sclang :results none
  s.stopRecording;
#+end_src

#+name: print_files
#+begin_src shell
  ls "$dir"
#+end_src

** play routines
Routine recorded on July 24
#+begin_src shell :noweb yes :results none
  echo "<<isnare_filter_mod()>>"
  echo "<<isnare_filter_routine()>>"
#+end_src
** test tone
#+name: ssingle
#+begin_src sclang :results none
  {Out.ar(0, SinOsc.ar(440, 0, 0.1))}.play;
  s.meter;
#+end_src

GUI
#+begin_src sclang :results none
  (
  SynthDef(\pluck, { |out, freq=55|
      Out.ar(out,
                  Pluck.ar(WhiteNoise.ar(0.06),
                          EnvGen.kr(Env.perc(0,4), 1.0, doneAction: Done.freeSelf),
                          freq.reciprocal,
                          freq.reciprocal,
                          10,
                          coef:0.1)
      );
  }).add;

  w = Window.new("Hold arrow keys to trigger sound",
      Rect(300, Window.screenBounds.height - 300, 400, 100)).front;
  a = Slider(w, Rect(50, 20, 300, 40)).value_(0.5).step_(0.05).focus
  .action_({
      // trigger a synth with varying frequencies
      Synth(\pluck, [\freq, 55 + (1100 * a.value)]);
      w.view.background_(Gradient(Color.rand,Color.rand));
  })
  )
#+end_src
** snare synths
*** snare 1
**** synthdef
Simple instance of a snare synth played by an impulse.

This may be used for polyrhythmic snare using [[generic_snare][generic_snare]] below.

Used by a variety of snippets:
- [[*pbind for accelerando][pbind for accelerando]]
  #+name: original_snare
  #+begin_src sclang :results none
    (
    ~snare_simple = SynthDef(\snare, {
        var snd;
        var env = Env([0, 1, 0], [0.0001, \length.ir(0.5)], \sine);
        var imp = Impulse.ar(\impf.kr(1), 0.0, 0.5, 0);
        var frq1=\freq.kr(300), frq2=frq1-100;
        snd = OGenericSnarefs.ar(imp, 0.00001, 0.001, \noiselvl.kr(0.1), \nrel.ir(0.1), frq1, frq2, \rel.ir(0.1), \trifrq.kr(111)) * EnvGen.kr(env, doneAction: Done.freeSelf);
        Out.ar(\out.ir(0), snd*\gain.ir(1));
    }).add;
    )
  #+end_src
#+begin_src sclang :results none
  Synth.new("snare", [\impf, 100]);
#+end_src
***** Gesture one
Similar to the above, but with modulation of Impulse tempo
#+name: extended_snare
#+begin_src sclang :results none
  (
  ~snare_simple = SynthDef(\snare_imp_mod, { 
          var snd,
          crv = \curve.ir(0),
          lngth = \length.ir(1),
          sstrt = \speedStart.ir(1),
          send = \speedEnd.ir(1),
          frq1 = \freq.kr(300),
          frq2 = \freq2.kr(200),
          nlvl = \noiselvl.kr(0.1),
          nrel = \nrel.ir(0.1),
          rel = \rel.ir(0.1),
          trifrq = \trifrq.kr(111),
          out = \out.ir(0),
          gain = \gain.ir(1),
      envcrv = \envCurve.ir(6);
          var mod_env = Env(
                  levels: [sstrt, send],
                  times: [lngth],
                  curve: crv,
                  releaseNode: 0,
                  loopNode: 1,
          );
          var env = Env(
                  levels: [0, 1, 0.7, 0],
                  times: [0.0001, lngth*0.8, lngth*0.2],
                  curve: \squared);
          var imp = Impulse.ar(EnvGen.ar(mod_env, gate: Impulse.ar(0.001), levelScale: 1, levelBias: 0.0, timeScale: 1, doneAction: 0));
          snd = OGenericSnarefs.ar(imp, 0.000001, 0.0001, nlvl, nrel, frq1, frq2, rel, trifrq) * EnvGen.kr(env, doneAction: Done.freeSelf);
          Out.ar(out, snd*gain);
  }).add;
  )
#+end_src

#+begin_src sclang :results none

  Env(
          levels: [0, 1, 0.9, 0],
          times: [1, 10-5, 10-4],
          curve: \squared,
  ).plot;

#+end_src
#+name: acc_long_640
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 640, \speedEnd, 640 , \freq1, 200, \freq2, 210, \trifrq, 100, \noiselvl, 0.001, \nrel, 0.01, \lngth, 0.1, \length, 15, \rel, 0.005, \out, [0,1], \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_long_400
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 400, \speedEnd, 400 , \freq1, 200, \freq2, 210, \trifrq, 100, \noiselvl, 0.001, \nrel, 0.01, \lngth, 0.1, \length, 15, \rel, 0.005, \out, 1, \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_snare
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 4,  \speedStart, 1, \speedEnd, 25, \freq, 400, \trifrq, 100, \length, 5, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+name: acc_deep
#+begin_src sclang :results none :noweb yes
  ~reg_snare = Synth.new("snare_imp_mod", [\curve, 2,  \speedStart, 2, \speedEnd, 40, \freq, 200, \trifrq, 420, \length, 1, \out, 1, \gain, 0.2, \envCurve, 40] );
#+end_src

#+name: snare_single
#+begin_src sclang :results none :noweb yes
  ~test = Synth.new("snare_imp_mod", [\freq, 400, \freq2, 300, \trifrq, 80, \length, 5, \out, 0, \gain, 1.3, \envCurve, 10, \noiselvl, 0.4, \nrel, 0.04, \curve, 4,  \speedStart, 0.01, \speedEnd, 0.01] );
#+end_src

#+name: snare_bass
#+begin_src sclang :results none :noweb yes
  ~test2 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 100, \speedEnd, 100, \freq, 80, \freq2, 90, \trifrq, 60, \noiselvl, 0.001, \length, 20, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+name: snare_bass
#+begin_src sclang :results none :noweb yes
  ~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, 60, \speedEnd, 70, \freq, 100, \freq2, 110, \trifrq, 85, \noiselvl, 0.01, \length, 10, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10] );
#+end_src

#+begin_src sclang :results none
  ~play_snares = { |start, end, frq, time, out|
          var frq2, tri;
          frq2 = frq * 2;
          tri = frq / 2;
          ~test3 = Synth.new("snare_imp_mod", [\curve, 1,  \speedStart, start, \speedEnd, end, \freq, frq, \freq2, frq2, \trifrq, tri, \noiselvl, 0.01, \length, time, \rel, 0.08, \nrel, 0.05, \out, 0, \gain, 1, \envCurve, 10, \out, out] );
  }; 
  ~play_snares.value(2, 60, 100, 10, 0);
  ~play_snares.value(3, 40, 180, 10, 1);
#+end_src

#+begin_src sclang :results none
  ~test3.set(\freq, 600);
#+end_src
#+begin_src sclang :results none :noweb yes
  {<<acc_snare>>}.defer(0);
  {<<acc_deep>>}.defer(3.95);
  {<<snare_single>>}.defer(4.88);
#+end_src

***** Stuff
Example routine, as a looping gesture
#+name: looping_gesture
#+begin_src sclang :results none :tangle testme.sc :noweb yes
  ~intro_gesture = Routine ({
          var delta;
          loop {
                  delta = 1;
                  <<acc_snare>>
                  delta.yield;
          }
  });
#+end_src

Another simple routine (not good for time critical events.
#+begin_src sclang :results none :noweb yes
  { 20.do({ <<snare_single>> 0.1.wait;}) }.fork;
#+end_src
     
#+begin_src sclang :results none :noweb yes
  <<looping_gesture>>
  ~intro_gesture.play;
  //	~intro_gesture.stop;
#+end_src

#+name: dacc_snare
#+begin_src sclang :noweb yes
  <<acc_snare>>
  ~reg_snare = Synth.new("snare_imp_mod", [\envCurve, 1, \curve, -4, \speedStart, 20, \speedEnd, 1, \freq, 400, \trifrq, 100, \length, 5, \out, 1, \gain, 1, \vol, 1] );
#+end_src

A feedback snare
#+begin_src sclang :results none
  (
  ~snare_fb = SynthDef(\snarefb, { | gain=4, freq=200, vol=2, q=1, out=0 |
      var snd;
      var env = Env([0, 1, 0], [0.0001, 0.5]);
      snd = SnaresFb.ar(gain: gain, vol: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
      Out.ar(out, snd);
  }).add;
  )
#+end_src

A dispersed snare over many channels
#+begin_src sclang :results none
  (
  ~snare_disp = SynthDef(\snaredisp, { | freq=200, q=1, out=0, pos=0, disp=1, impf=0, attack=0.0001, noiselvl=0.1, noiserel=0.1, osc1f=330, osc2f=180, trianglef=111, mainlvl=0.5, length=1 |
      var snd;
      var env = Env([0, 1, 0], [0.0001, length]);
      var imp = Impulse.ar(impf, 0.0, 0.5, 0);
      snd = ODispersedSnare.ar(imp, pos, disperse: disp, attack: attack, noise_lvl: noiselvl, noise_rel: noiserel, osc_1_freq: osc1f, osc_2_freq: osc2f, triangle_freq: trianglef);// * EnvGen.kr(env, doneAction: Done.freeSelf);
      Out.ar(out, snd * mainlvl);
  }).add;
  )
#+end_src

A second version of the dispersed snare above
#+begin_src sclang :results none
  (
  ~snare_disp = SynthDef(\snaredisp2, { | out=0, length=2 |
      var snd;
      var env = Env([0, 1, 0], [0.0001, length]);
      var imp = Impulse.ar(10, 0.0, 0.5, 0);
      snd = ODispersedSnare.ar(imp);
      Out.ar(out, snd);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  ~snare_simple.free;
  ~snare_fb.free;
  ~snare_disp.free;
#+end_src

**** player
Play one hit on the snare above.
#+name: reg_snare_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snare", [\freq, 400, \trifrq, 100, \length, 0.09, \out, 25, \gain, 1, \vol, 1] );
#+end_src

Play a series of hits for the duration of ~\length~.
#+name: generic_snare
#+begin_src sclang :results none
  ~snare_simple = Synth.new("snare", [\impf, 0.1, \freq, 300, \nrel, 0.05, \length, 0.1, \out, 0] );
  //       s.meter;
#+end_src

Exaple of speeding up hits using a ~Routine~
#+begin_src sclang :results none :noweb yes
  (
  <<generic_snare>>

  Routine({
          x=1;
          0.2.wait;
          100.do({
                  ~snare_simple.set(\impf, x);
                  x.postln;
                  x = x + 1;
                  0.1.wait
          })
  }).play;
  )
#+end_src
     
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
      \out, 0,
      \impf, 0.1,
      \freq, Pseq((150..600), 100),
      \nrel, Pseq((0.005..0.4), 100),
      \length, 0.15,
      \dur, Pseries((0.5..0.01), 10),
  ).play;
#+end_src

#+begin_src sclang :results none
  ~fb_snare = Synth.new("snarefb", [\out, 1, \gain, 2, \vol, 2] );
#+end_src

Snygga effekter genom att panorera dessa två ljud med Radius och Elevation.
#+begin_src sclang :results none
  ~disp_snare1 = Synth.new("snaredisp", [\out, 1, \impf, 3000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 20] );
  ~disp_snare1 = Synth.new("snaredisp", [\out, 0, \impf, 2000, \pos, 0, \disp, 0, \noiserel, 0, \noiselvl, 0.0001, \length, 25] );
  s.meter;
#+end_src

#+begin_src sclang :results none
  Pbind(\instrument, \snaredisp,
      \out, 0,
      \impf, 10,
      \dur, 0.5,
      \pos, 6,
  ).play
#+end_src

#+begin_src sclang :results none
  ~dist_snare = Synth.new("snaredisp", [\out, 0, \impf, 0, \pos, 0, \disp, 1, \noiserel, 0, \noiselvl, 0.01] );
#+end_src

Closer and closer.
#+begin_src sclang :results none
  ~range = [(1..10)].do({ arg item, i; [item/20]; });
  Pbind(\instrument, \snaredisp,
          \out, Pseq((31..31), 16), // This is for feeding the signal to the ambisonics engine
          \noiserel, Pseq([0.0, 0.001, 0.002, 0.003, 0.005, 0.007, 0.01, 0.02, 0.03, 0.04, 0.045, 0.050, 0.055, 0.06, 0.065, 0.07], 16),
          \nopiselvl, 0.0,
          \osc1f, Pseq((150..2000), 16),
          \osc2f, 180,
          \mainlvl, Pseq([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16], 16),
          \dur, 1
  ).play;
  //s.meter;
#+end_src
     
For testing
#+begin_src sclang :results none
  a = Array.fill(16, {arg i; i * 0.001; });
  b = Array.fill(32, { arg i; i / 32 + 0.05 }).reverse;
  Pbind(\instrument, \snaredisp,
          \out, 0,
          \noiserel, Pseq(a, 32),
          \ nopiselvl, 0.0,
          \osc1f, Pseq((150..2000), 32),
          \osc2f, Pseq((400..170), 32),
          \mainlvl, 0.5,
          \dur, Pseq(b, 32)
  ).play
#+end_src
**** pbind: fast irregular, no snare.
Very nice sounding pattern
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
      \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
      \dur, Prand([0.1, 0.2], inf),
      \q, Prand([0.001, 5, 2], inf),
      \out, Prand((0..1), inf) //([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], inf)
  ).play;
#+end_src
     

#+begin_src sclang :results none
  Pbind(\instrument, \snarefb,
      \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
      \dur, Prand([0.1, 0.2, 0.4], inf),
      \q, Prand([0.001, 5, 2], inf),
      \out, Prand( (0 .. 16), inf)
  ).play;
#+end_src

Ptpar running two Pbinds
#+begin_src sclang :results none
  a = Pbind(\instrument, \snare,
          \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
          \dur, Pseq([0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
          \q, Prand([0.001, 5, 2], inf)
  );
  b = Pbind(\instrument, \snare,
          \freq, Prand([100,110,140, 180, 260, 320, 640, 80, 200], 64),
          \dur, Pseq([0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.23529411764705882, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.29411764705882354, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.35294117647058826, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.4117647058823529, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.47058823529411764, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5294117647058824, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.5882352941176471, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.6470588235294118, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7058823529411765, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.7647058823529411, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8235294117647058, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.8823529411764706, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 0.9411764705882353, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], inf),
  );
  Ptpar([0.0, a, 1, b, 2, a]).play;
#+end_src
*** snare phase (polyrhythmic harmony)
**** synthdef
Four hits per pulse. Min speed is 1/2 sec. These synths play severl hits for each impuls to allow for high frequencies. ~ISnarePhase~ in this version has an accent on every four hits, which may not be desireable in all cases. Plays until stopped.
#+name: i_snare_phase_1
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\snare_phase, {
          var snd, pulse = \pulse.kr(10);
          var frq1 = \freq.kr(300),
          frq2 = \freq2.kr(300);
          snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111));
          Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add
#+end_src

~i_snare_phase_2~ differs from the above ([[i_snare_phase_1][i_snare_phase_1]]) only by the addition of an envelope over the ~\length~ of the instance. 
#+name: i_snare_phase_2
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\snare_phase_2, {
          var snd, pulse = \pulse.kr(10);
          var frq1 = \freq.kr(300),
          frq2 = \freq2.kr(300),
          env = Env.new(levels: [0, 1, 0], times: [0.2, \length.ir(0.1)], curve: \sin);
          snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), \nlevel.kr(0.2), \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), \trifreq.kr(111)) * EnvGen.kr(env, timeScale: \length.ir(0.1), doneAction: Done.freeSelf);
          Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add
#+end_src

**** player
Simple example, of a snare with no snare.
#+name: single
#+begin_src sclang :results none :noweb yes
  <<i_snare_phase_1>>;
  ~singletest = Synth.new("snare_phase", [\pulse, 4000, \length, 1, \freq, 10, \nlevel, 0, \out, 0, \gain, 0.5]);
#+end_src

Make a series of notes up the harmonic series. Works very nicely. The variables for the function are:
1. ~mode~: which mode to run the function in (0: harmonic rising, 1: inharmonic falling, 2: experimental
2. ~fund~: fundamental frequency for the modes.
3. ~reps~: how many rrepetitions of the function.
4. ~delta~: delta time bwetween the notes.
#+name: play_snare_phase
#+begin_src sclang :results none :noweb yes
  <<i_snare_phase_2>>;
  ~play_chord = { |mode, fund, reps, delta, out|
          var freq, len, osc1, osc2, tri, nlvl, gain;

          switch(mode,
                  /* mode == 0 */	
                  0, 	{
                          /* Starting from frequency x going down */
                          freq = Array.fill(reps, {arg i; fund * (i + 1)});
                          osc1 = Array.fill(reps, {arg i; 200 * (i + 1)});
                          osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
                          tri =  Array.fill(reps, {arg i; 410 * (i + 1)});

                  },
                  /* mode == 1 */	
                  1,  {
                          /* Starting from the fundamental, going up */
//                          freq = Array.fill(reps, {arg i; fund - (100 * i)});
                          freq = Array.fill(reps, {arg i; fund /  (1 + i)});	
                          osc1 = Array.fill(reps, {arg i; 250 * (i + 1)});
                          osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
                          tri =  Array.fill(reps, {arg i; 410 * (i + 1)});

                  },
                  2,  {
                          /* Inharmonic */
                          freq = Array.fill(reps, {arg i; fund * ((i * 1) + 1)});
                          osc1 = Array.fill(reps, {arg i; 200 * (i + 1)});
                          osc2 = Array.fill(reps, {arg i; 100 * (i + 1)});
                          tri =  Array.fill(reps, {arg i; 310 * (i + 1)});
                  });
          len = Array.exprand(reps, 8, 12);
          gain = Array.fill(reps, {arg i; 1 / (i + 1) * 0.8;});
          nlvl = Array.rand(reps, 0, 0);

          fork {
                  [\pulse, freq, \length, len, \freq, osc1, \freq2, osc2, \trifreq, tri, \nlevel, nlvl, \gain, gain, \out, out].flop.do { |args|
                          args.postln;
                          Synth("snare_phase_2", args);
                          delta.wait;
                  }
          };
  };
#+end_src

Play a chord according to [[play_snare_phase][play_snare_phase]] with the synth [[i_snare_phase_2][i_snare_phase_2]]. 
#+begin_src sclang :results none
  ~play_chord.value(1, 1, 2, 2, 0);
  ~play_chord.value(1, 3, 2, 2, 1);
  ~play_chord.value(1, 5, 2, 2, 1);
#+end_src

***** Polyrhythmic functions (works)
Polyrhythmic function with two synths (in the array ~synths~) at different speeds. 
#+name: poly_rythm
#+begin_src sclang :results none
  ~polyr = { | nom, denom, f, osc1, osc2 |
          var f1, f2, phase1, phase2, synths;
          postf("freq is %\n", f);
          f1 = nom * f;
          "f1 is ".post; f1.postln;
          f2 = denom * f;
          "f2 is ".post; f2.postln;
          synths = [
                  Synth.new("snare_phase", [\pulse, f1, \freq, 100, \freq2, 130, \nlevel, 0.3, \nrel, 0.1, \gain, 0.4, \out, 1] ),
                  Synth.new("snare_phase", [\pulse, f2, \freq, 50, \freq2, 230, \nlevel, 0.3, \nrel, 0.1, \gain, 0.4, \out, 0] )
          ];
  };
#+end_src

Start the polyrhythmic structure above
#+begin_src sclang :results none
  k = ~polyr.value(3, 5, 1);
#+end_src

Adjust values in the polyrhythmic structure above.
#+begin_src sclang :results none
  k[0].set(\nlevel, 0);
  //k[0].set(\pulse, 1, \nlevel, 0.0, \freq, 400, \freq2, 200, \trifreq, 300);
#+end_src

Function setting the values relative to the pulse. This relies on ~poly_rhythm~ above that delivers the synths.
#+name: phased_set_values
#+begin_src sclang :results none :noweb yes
  <<poly_rythm>>
  ~phased_set_values = { |frequency=10, nom, denom, synth|
          var freq = frequency, nlevel, f1, f2, t3, normalizedf, maxf = 2000;
          normalizedf = freq / maxf;
          c = ControlSpec(1, 2000, \lin, 0.0001);
          freq = c.unmap(freq);
          //d = [0.05, 0.00001, -40].asSpec;
          d = ControlSpec(0.005, 0.00001, -40, 0.00001);
          nlevel = d.map(freq);
          f1 = freq * 2 + 50;
          f2 = freq * 3 + 50;
          t3 = freq * 4 + 50;
          synth[0].set(\pulse, frequency*nom, \nlevel, nlevel, \freq, f1*nom, \freq2, f2*nom, \trifreq, 300);
          synth[1].set(\pulse, frequency*denom, \nlevel, nlevel, \freq, f1*denom, \freq2, f2*denom, \trifreq, 300);
  };
  ~polyr_synth = ~polyr.value(1, 2, 3);
  ~phased_set_values.value(1, 2,  3, k);
#+end_src

Change values in the synth
#+begin_src sclang :results none
  ~phased_set_values.value(1, 5, 3, k);
  ~phased_set_values.value(2, 5, 4, l);
#+end_src

Loop to do a accelerando. Uncomment the first two lines to also load the other patches.
#+begin_src sclang :results none :noweb yes
  <<phased_set_values>>
  (
  t = Task({
          (1..500).do({ |pulse|
                  ~phased_set_values.value(pulse*1, 3, 4, ~polyr_synth);
                  ~polyr_synth[0].set(\nlevel, 1/pulse);
                  ~polyr_synth[1].set(\nlevel, 1/pulse);
                  ~polyr_synth[0].set(\freq, 100 + (pulse / 100));
                  ~polyr_synth[1].set(\freq, 100 - (pulse / 250));
                  if(pulse % 10 == 1,
                          { "Current nlevel: ".post;		
                                  (1/pulse).postln;
                          }, { });
                  0.2.wait;
          });
  }).play;
  )
#+end_src

GUI for controling the speed.
#+begin_src sclang :results none
  (
  var mapped;
  w = Window.new.front;
  c = ControlSpec(1, 1000, \linear, 0.01); // min, max, mapping, step
  b = NumberBox(w, Rect(20, 20, 150, 20));
  d = NumberBox(w, Rect(20, 120, 150, 20));

  a = Slider(w, Rect(20, 60, 150, 20)).action_({
          mapped = c.map(a.value);
          b.value_(mapped);
          k[0].set(\pulse, mapped);
  });

  e = Slider(w, Rect(20, 160, 150, 20)).action_({
          mapped = c.map(e.value);
          d.value_(mapped);
          k[1].set(\pulse, mapped);
  });
  a.action.value;
  e.action.value;
  )     
#+end_src

Polyrhythmic object with two synths at different speeds. (Doesn't work)
#+name: poly_rhythm_ii
#+begin_src sclang :results none
  PolyRhythm = {
      var f=1, f1, f2, nom=1, denom=1, phase_1, phase_2;
          f1 = nom * f;
          f2 = denom * f;
      phase_1 = Synth.new("snare_phase", [\pulse, f1, \freq, 100, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 0] );
      phase_2 = Synth.new("snare_phase", [\pulse, f2, \freq, 50, \nlevel, 0.5, \nrel, 0.2, \gain, 0.4, \out, 1] );
  };
  a = PolyRhythm.new;
  a.f_(2);
  a.nom_(2);
  a.denom_(3);
#+end_src

*** snare dispersed
This is very nice with a few patterns to it at the bottom under control signals
**** synth
define the synth
#+name: snare_disp_4
#+begin_src sclang :results none
  ~disp_snare = SynthDef(\snaredisp4, { | dur=60, out=33, pos=0, disp=0, pulse=2000, att=0.00001, n_attack=0.01, n_level=0.2, n_rel=0.1, osc1_f=100, osc2_f=130, release=0.01, tri_f=300 |
          var snd, env;
          env = Env.new(levels: [0, 1, 1, 0], times: [0.01, dur, 0.01]);
          snd = IDispersedSnare.ar(pos, disp, pulse, att, n_attack, n_level, n_rel, osc1_f, osc2_f, release, tri_f) * EnvGen.kr(env, doneAction: Done.freeSelf);
          Out.ar(out, snd);
  }).play(s);
  //s.plotTree;
#+end_src
     
define the busses
#+name: snare_disp_4_bus
#+begin_src sclang :results none
  ~busses = Array.new(4);
  ~duration = 20;

  b = Bus.control(s, 1);
  ~disp_snare.map(\pos, b);
  c = Bus.control(s, 1);
  c.set(4000);
  ~disp_snare.map(\pulse, c);
  d = Bus.control(s, 1);
  d.set(0.1);
  ~disp_snare.map(\n_rel, d);
  e = Bus.control(s, 1);
  e.set(0.2);
  ~disp_snare.map(\n_level, e);

  //      {Out.kr(b, Line.kr(0, 29, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(4000, 200, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.1, 0.005, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
  {Out.kr(c, Line.kr(0.2, 0.001, ~duration, doneAction: Done.freeSelf))}.play(addAction: \addToHead);
#+end_src

#+begin_src sclang :results none
  s.makeGui(p);
#+end_src
**** player
#+name: play_disp_snare_4
#+begin_src sclang :results none
  ~reg_snare = Swynth.new("snaredisp4", [\dur, 30, \out, 0, \pos, 2, \disp, 0, \pulse, 500, \gain, 20, \vol, 5] );
  //       ~reg_snare.free;
#+end_src

**** control signals
Various tasks that alter the parameters of the synth
This takes the positions parameter
#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~pos_task = Task({
          loop {
                  (0..28).do({ |position|
                          position.postln;
                          ~reg_snare.set(\pos, position);
                          0.5.wait;
                  });
          }
  }).play;
#+end_src

Slowly increaseing disperse parameter
#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~disp_task = Task({
      loop {
                  (0..100).do({ |disperse|
                          var disp;
                          disp = disperse/100;
                          ~reg_snare.set(\disp, disp);
                          0.1.wait;
                  });
      }
  }).play;
#+end_src

#+begin_src sclang :results none :noweb yes
  <<snare_disp_4>>
  <<snare_disp_4_bus>>
  <<play_disp_snare_4>>
  ~pulse_task = Task({
          loop {
                  (5000..100).do({ |pulse_time|
                          var pulse, disp;
                          pulse = pulse_time;
                          disp = 1 / pulse_time;
                          ~reg_snare.set(\pulse, pulse);
                          ~reg_snare.set(\disp, pulse);	
                          0.01.wait;
                  });
          }
  }).play;
#+end_src

Control the speed via a slider.
#+begin_src sclang :results none
  (
  w = Window.new.front;
  b = NumberBox(w, Rect(20, 20, 150, 20));
  a = Slider(w, Rect(20, 60, 150, 20)).action_({
      b.value_(a.value);
      ~reg_snare.set(\pos, (a.value * 10));
  });
  a.action.value;
  )     
#+end_src

*** snare 2 (osx)
Simple instance of a snare synth with more noise
#+begin_src sclang :results none
  (
  SynthDef(\snares, { | gain=2, freq=200, vol=2, q=10 |
      var snd;
      var env = Env([0, 1, 0], [0.0001, 0.5]);
      snd = Snares.ar(attack: 0.00001, freq: freq, gain: gain, q: q, rel: 0.01, vol_0: vol) * EnvGen.kr(env, doneAction: Done.freeSelf);
      Out.ar(0, snd);
  }).add;
  )
#+end_src
**** player
Play one hit on the snare above.
#+name: snares_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snares", [\freq, 100] );
#+end_src
*** snare 3 (isnare2)
**** Example without groups
Synth that is driven by an Impulse pulse generator.
Load first the SynthDefs below.
#+name: isnare_def
#+begin_src sclang :results none
  (
  // Main snare synth
  SynthDef(\isnare, { | inBus1=0, inBus2=1, inBus3=2, inBus4=3, outBus=0, freq=2, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, dur=1 |
      var snd;
      var env;
      var envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]);
      b = 0;
      envelope.times.do({ arg i; b = b + i; });
      c = dur / b;
      env = EnvGen.kr(
                  envelope,
                  timeScale: c,
                  doneAction: Done.freeSelf);
      snd = IDispersedSnare.ar(Impulse.ar(freq), position, disperse, osc_1_freq: In.kr(inBus2), osc_2_freq: In.kr(inBus2) - 50, triangle_freq: In.kr(inBus3), noise_lvl: In.kr(inBus4)) * gain * env;
      Out.ar(outBus, snd);
  }).add;

  // Control synth 1, modulated oscillator
  SynthDef(\control_osc, {
      Out.kr(\bus.ir,
                  SinOsc.kr(
                          // modulate the frequency of the modulator
                          Line.kr(\start.ir(0.1),
                                  \end.ir(2),
                                  \dur.ir(10),
                                  \lmult.ir(1),
                                  \ladd.ir(0)),
                          \phase.kr(0),
                          \mult.ir(1),
                          \add.ir(0)));
  }).send(s);

  // Control synth 2, line
  SynthDef(\control_line, {
      Out.kr(\bus.ir, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(10), \mult.kr(1), \add.kr(0)));
  }).send(s);

  // Control synth 3, saw-tooth
  SynthDef(\control_saw, {
      Out.kr(\bus.ir, Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
  }).send(s);

  ~osc_control_1_bus = Bus.control(s, 1);
  ~osc_control_2_bus = Bus.control(s, 1);
  ~line_control_1_bus = Bus.control(s, 1);
  ~line_control_2_bus = Bus.control(s, 1);
  ~saw_control_1_bus = Bus.control(s, 1);
  )
#+end_src

Instantiate the synths. 
#+name: isnare_load
#+begin_src sclang :results none
  (
  ~osc_control_1 = Synth.new(\control_osc, [
      \bus, ~osc_control_1_bus.index,
      \add, 7,
      \dur, 2,
      \start, 10,
      \end, 0.0001,
      \mult, 5
  ]);
  ~rising_line_1 = Synth.after(~osc_control_1, \control_line, [
      \bus, ~line_control_1_bus.index,
      \mult, 500,
      \add, 50,
      \dur, 2]);
  ~falling_line_1 = Synth.after(~osc_control_1, \control_line, [
      \bus, ~line_control_2_bus.index,
      \start, 200,
      \end, 40,
      \dur, 2]);
  ~isnare_synth = Synth.after(~saw_control_1, \isnare, [
      \inBus1, ~saw_control_1_bus.index,
      \inBus2, ~line_control_1_bus.index,
      \inBus3, ~line_control_2_bus.index,
      \freq, 10,
      \dur, 2]);
  )
#+end_src

Example note with decaying hits.
#+begin_src sclang :results none
  Pbind(
      \instrument, \isnare,
      \dur, 1,
      \freq, 10
  ).play;
#+end_src

**** Example using groups
***** Synth and modulator (1)
#+name: isnare2_def
#+begin_src sclang :results none
  (
  // Main snare synth
  ~isnare_def = SynthDef(\isnare2, { | position=0, disperse=0 |
      var snd, env, envelope, duration;
      envelope = Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1], [-5, 0, -5]);
      b = 0;
      envelope.times.do({ arg i; b = b + i; });
      duration = \dur.ir / b;
      env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);
      snd = IDispersedSnare.ar(Impulse.ar(\freq.kr(1) * In.kr(\inBus3.kr)),
                  position,
                  disperse,
                  osc_1_freq: (\osc1.kr(330) * In.kr(\inBus1.kr)) + 100,
                  osc_2_freq: (\osc2.kr(180) * In.kr(\inBus2.kr)) + 120,
                  triangle_freq: (\tri.kr * In.kr(\inBus3.kr) + 200),
                  noise_lvl: \noise.kr(0.1)) * \gain.kr(0.5) * env;
      Out.ar(\outBus.ir, snd);
  }).add;

  // Control synth saw-tooth
  SynthDef(\control_saw2, {
      Out.kr(\bus.ir(0), Saw.kr(\freq.kr(1), \mult.kr(1), \add.kr(0)));
  }).send(s);

  // Busses
  ~saw_control_bus_1 = Bus.control(s, 1);
  ~saw_control_bus_2 = Bus.control(s, 1);
  ~saw_control_bus_3 = Bus.control(s, 1);
  )
#+end_src

One hit
#+begin_src sclang :results none
  a = Synth(\isnare2, [ \position, 0, \disperse, 0, \noise, 0.5, \dur, 0.03, \freq, 1]);
#+end_src
#+begin_src sclang :results none
  s.plotTree;
#+end_src

***** Create group and add control instrument (2)
Instantiate all control instruments. This could be integrated into the main routine above: [[*Synth and modulator (1)][Synth and modulator (1)]] thus not needed to be loaded separately.
#+name: start_controls
#+begin_src sclang :results none
  ~group = Group.new;
  ~freq_ctrl = Synth(\control_saw2, [
      \bus, ~saw_control_bus_1.index,
      \freq, 1,
      \mult, 1,
      \add, 1], ~group, \addToHead);
  ~freq_ctrl2 = Synth(\control_saw2, [
      \bus, ~saw_control_bus_2.index,
      \freq, 1, 
      \mult, 1, 
      \add, 1], ~group, \addToHead);
  ~impulse_ctrl = Synth(\control_saw2, [
      \bus, ~saw_control_bus_3.index, 
      \freq, 0.5, 
      \mult, 1, 
      \add, 1], ~group, \addToHead);
  // ~group.group.inspect;
#+end_src

Function to set attributes for ~impulse_ctrl~. Use ~~group.set(\freq, 10)~ to set all ~\freq~ attributes in one go.
#+name: load_presets
#+begin_src sclang :results none
  ~param_update = { | range1=1, freq1=0.01, range2=1, freq2=1, range3=1, freq3=1 |
      ~impulse_ctrl.set(\mult, range1);
      ~impulse_ctrl.set(\add, range1);
      ~impulse_ctrl.set(\freq, freq1);

      ~freq_ctrl.set(\freq, freq2);
      ~freq_ctrl.set(\mult, range2);
      ~freq_ctrl.set(\add, range2);

      ~freq_ctrl2.set(\freq, freq3);
      ~freq_ctrl2.set(\mult, range3);
      ~freq_ctrl2.set(\add, range3);
  };
  "loaded".postln;
#+end_src

***** Presets
Nice and noisy
#+name: isnare_preset_1
#+begin_src sclang :results none :noweb yes
  <<load_presets>>
  ~param_update.value(10, 1, 10, 1, 11, 1);
#+end_src

Dark and bassy
#+name: isnare_preset_2
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(1, 1, 0, 1, 0, 1);
#+end_src

Heavily modulated
#+name: isnare_preset_3
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(4, 5, 1.1, 100, 2, 110);
#+end_src

Medium dark
#+name: isnare_preset_3
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(6, 100, 0.01, 0.002, 1.3, 0.001);
#+end_src

Inharmonic
#+name: isnare_preset_4
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(1, 52, 1, 50, 1, 100);
#+end_src

Shady
#+name: isnare_preset_4
#+begin_src sclang :results none :noweb yes :var mark="hoo"
  <<load_presets>>
  ~param_update.value(10, 23, 10, 24, 10, 200);
#+end_src

Poll a bus:
#+begin_src sclang :results none
  {Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_3.index))}.play;
#+end_src
***** Updating values in a routine
Nice and noisy, lots of variation.
#+begin_src sclang :results none
  (
  ~routine = Routine({
      var delta;
      loop {
                  delta = rrand(1, 10);
                  "Will wait ".post; delta.postln;
                  ~impulse_ctrl.set(\add, delta);
                  ~freq_ctrl.set(\add, delta * 0.5);
                  ~freq_ctrl2.set(\mult, delta);
                  1.yield;
      }
  });
  ~routine.play;
  )
#+end_src

#+begin_src sclang :results none
  ~routine.stop;
#+end_src
***** Add and play the main instrument, depends on [[*Create group and add control instrument][Create group...]] and [[*Synth and modulator][Synth and modulator]] (3)
Play it:
#+name: play_isnare2
#+begin_src sclang :results none :noweb yes
  <<start_controls>>
  ~isnarce_synth = Synth.after(~group, \isnare2, [
      <<bus_assignment>>
      \freq, 10,
      \dur, 20]);
  ~tempo_update.value(20, 0.01);
#+end_src

***** Play with a Pbind (4)
These work really well!

Now including [[*Create group and add control instrument (2)][Create group ...]] with a noweb link. This can be tangled to self contained sclang code (test.sc in this example)
#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_4>>
  ~event_str = Pbind(\instrument, \isnare2,
      <<bus_assignment>>
      \group, ~group,
      \addAction, 1,
      \position, 0,
      \disperse, 1,
      \noise, 0.0001,
      \freq, 10,
      \dur, 0.1
  ).play;
#+end_src

#+begin_src sclang :results none :tangle test.sc :noweb yes
  <<start_controls>>
  <<isnare_preset_1>>
  ~event_str = Pbind(\instrument, \isnare2,
          <<bus_assignment>>
          \group, ~group,
          \position, 12,
          \disperse, 0,
          \noise, 0.01,
          \freq, 1,
          \dur, 0.1,
  ).play;
#+end_src

Move repeated stuff out for cleaner Pbind
#+name: bus_assignment
#+begin_src sclang :results none
  \inBus1, ~saw_control_bus_1.index,
  \inBus2, ~saw_control_bus_2.index,
  \inBus3, ~saw_control_bus_3.index,
#+end_src

To play from the variable.
#+begin_src sclang :results none
  ~event_str.play;
  ~event_str.reset;
#+end_src

Free the group
#+name: free_group
#+begin_src sclang :results none
  ~group.freeAll;
  ~group.free;
#+end_src
**** Stuff
Plot a control bus
#+begin_src sclang :results none
  {In.kr(~saw_control_bus_3.index)}.plot;
#+end_src

Inspect a control bus:
#+begin_src sclang :results none
  {Poll.kr(Impulse.kr(10), In.kr(~saw_control_bus_2.index))}.play;
#+end_src

#+begin_src sclang :results none :noweb eval
  //~init_durs.value
  (     
  ~player1 = Pbind(
      \instrument, \isnare,
      \dur, Pseq(~init_durs.value, inf),
      \freq, Prand([0, 0, 20], inf),
      \osc1, Pgauss(330, 10, inf),
      \osc2, Pgauss(180, 10, inf),
      \tri, Pgauss(110, 30, inf),
      \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
      \noise, Pgauss(0.3, 0.1, inf)
  ).play;
  )
#+end_src

Test the Pbind ~~player1~
#+begin_src sclang :results none
  //     ~player1.next(());
  ~player1.stop;
#+end_src
#+begin_src sclang :results none :noweb eval
  (     
  ~player1 = Pbind(
      \instrument, \impulseA,
      \dur, Pseq(~init_durs.value, 1),
      \freq, Prand([0, 0], inf)
  ).play;
  ) 
#+end_src

**** Method generation and manipulation
Test method to generate the array.
#+begin_src sclang :results none
  ~init_durs.value;
#+end_src
   
Create duration array
#+name: create_durs
#+begin_src sclang :results none
  (
  ~create_durs = { |arr=0, div=1, elem=4|
      var ldiv = 1/div;
      var lelem = elem * div;
      arr ++ Array.fill(lelem, {ldiv;});
  }
  )
#+end_src
   
Load create_durs first (if not loaded silently through the fake variable x)
#+name: init_durs
#+begin_src sclang :results none :noweb yes
  (
  ~init_durs = {
      (
                  ~times = Array.new();
                  for(1, 3, {arg i; ~times = ~create_durs.value(~times, (2**i), 4);});
                  ~times.postln;
      )
  }
  )
#+end_src

Alternative function for creating an array of durations.
#+name: durations_array
#+begin_src sclang
  ~durations = {
      var durs = Array.new(64);
      a = (1!4);
      b = (0.5!8);
      c = (0.25!16);
      d = (0.125!32);
      durs = a ++ b;
      durs = durs ++ c;
      durs = durs ++ d;
  };
#+end_src

*** snare 4 filtered
Synth that is driven by an Impulse pulse generator.
#+name: isnare_filter_def
#+begin_src sclang :results none
  (
  ~controlBus_1 = Bus.control(s, 1);
  SynthDef(\isnare_filter, { | outBus=0, freq=0, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16 |
      var snd;
      var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
      var modulator = SinOsc.kr([1!16],[0.1!16]);
      var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
      par = par * modulator;
      snd = IFilteredSnare.ar(Impulse.ar(freq),
                  band_1: b1, band_2: b2, band_3: b3,
                  band_4: b4, band_5: b5, band_6: b6,
                  band_7: b7, band_8: b8, band_9: b9,
                  band10: b10, band11: b11, band12: b12,
                  band13: b13, band14: b14, band15: b15,
                  band16: b16,  osc_1_freq: osc1, osc_2_freq: osc2,
                  triangle_freq: tri) * gain * env;
      Out.ar(outBus, snd);
  }).add;

  SynthDef(\control_synth, { | bus |
      Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
  }).send(s);
  )
#+end_src

#+begin_src shell :results none :noweb yes
  echo <<record_me()>>
#+end_src
#+begin_src shell :results none :noweb yes
  echo <<stop_record()>>

#+end_src
#+begin_src shell :noweb yes
  <<rename_file("isnare_filter_routine_b.wav")>>
#+end_src

SynthDef for a modulating snare drum synth. Parameters are:
- ~freq~: The frequency of the impulse playing the snare.
- ~gain~: General gain (0-1)
- ~osc1/2~: The frequecy of the two osccilators in the synth.
- ~tri~: The triangle wave frequecy
- ~noise~: The noise level (0-1)
- ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
- ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
- ~dur~: The duration of the note.
- ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
- ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
  #+name: isnare_filter_mod
  #+begin_src sclang :results none
    (
    SynthDef(\isnare_filter_mod_8, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, del, del_mod=0, dur, mod_freq_stretch |
        var snd, modulator_pf;
        var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
        var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
        modulator_pf = Select.kr(freq_mod + 1, [
                (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
                    freq, 
                (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
        snd = IFilteredSnare8.ar(Impulse.ar(modulator_pf),
                    band_1: b1, band_2: b2, band_3: b3,
                    band_4: b4, band_5: b5, band_6: b6,
                    band_7: b7, band_8: b8, delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
                    triangle_freq: tri) * gain * env;
        Out.ar(out, snd);
    }).add;
    )
  #+end_src

  #+begin_src sclang :results none
    p = Pbind(\instrument, \isnare_filter_mod_8,
            \dur, 0.1,
            \out, 0,
            \freq, 1,
            \freq_mod, 0,
            \del_mod, 0,
            \b1, Pshuf([-0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, ], inf),
            \b2, Pshuf([-5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, ], inf),
            \b3, Pshuf([-10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, ], inf),
            \b4, Pshuf([-14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, ], inf),
            \b5, Pshuf([-19.89519097573123, -24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, ], inf),
            \b6, Pshuf([-24.721359553116837, -29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, ], inf),
            \b7, Pshuf([-29.44996421843568, -34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, ], inf),
            \b8, Pshuf([-34.062343329362875, -38.5402939327384, -42.86614360330715, -47.02282018870768, -50.99391918545801, -54.763768480036426, -58.31749019955368, -61.6410594279202, -64.72135955578251, -67.54623404578808, -70.10453440888432, -72.38616420231169, -74.38211887565073, -76.08452130766864, -77.48665289371817, -78.58298006100074, -79.36917610705021, -79.8421382752508, -80.0, -79.84213827319023, -79.3691761029372, -78.58298005485153, -77.48665288555702, -76.08452129752777, -74.38211886357016, -72.3861641883391, -70.10453439307483, -67.5462340282041, -64.72135953649345, -61.64105940700216, -58.317490177089226, -54.763768456114185, -50.9939191601724, -47.02282016215851, -42.86614357559923, -38.54029390398104, -34.06234329966957, -29.44996418792362, -24.721359521906425, -19.895190943945654, -14.990505136556822, -10.026658653888878, -5.023241530248318, -0.0, -5.023241563000106, -10.02665868644665, -14.990505168792087, -19.89519097573123, -24.721359553116837, -29.44996421843568, ], inf),
    ).play;

    b = Pbind(\instrument, \isnare_filter_mod_8,
            \dur, 1,
            \out, 8, 
            \freq, 10,
            \freq_mod, 0,
            \del_mod, 0,
            \b1, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b2, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b3, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b4, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b5, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b6, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b7, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
            \b8, Pseq([-0.0, -2.7586206896551726, -5.517241379310345, -8.275862068965518, -11.03448275862069, -13.793103448275863, -16.551724137931036, -19.310344827586206, -22.06896551724138, -24.82758620689655, -27.586206896551726, -30.344827586206897, -33.10344827586207, -35.86206896551724, -38.62068965517241, -41.37931034482759, -44.13793103448276, -46.89655172413793, -49.6551724137931, -52.41379310344827, -55.17241379310345, -57.93103448275862, -60.689655172413794, -63.44827586206897, -66.20689655172414, -68.9655172413793, -71.72413793103448, -74.48275862068965, -77.24137931034483, -80.0, ], inf),
    );

    Ptpar([0, p, 0.66666, b]).play
    //      b.play;
  #+end_src

  SynthDef for a modulating snare drum synth. Parameters are:
  - ~freq~: The frequency of the impulse playing the snare.
  - ~gain~: General gain (0-1)
  - ~osc1/2~: The frequecy of the two osccilators in the synth.
  - ~tri~: The triangle wave frequecy
  - ~noise~: The noise level (0-1)
  - ~b1-16~: The level of each of the 16 bands of the filterbank in dB (-70 - 10)
  - ~del~: The delay of each successive band (0 - 1024). If set to 100, b0 will be delayed 100 samples, b1 200 samples, etc.
  - ~dur~: The duration of the note.
  - ~mod_freq_stretch~: The difference in frequency of the modulating SinOsc on the level of each band. If set to 0.1 b0 will have frequency 1 Hz, b1 1.1 Hz, b2 1.2 Hz, etc.
  - ~freq_mod~: If 0, the Impulse freq is not modulated, if 1, it is speeding up, if -1 it is slowing down.
    #+name: isnare_filter_mod
    #+begin_src sclang :results none
      (
      SynthDef(\isnare_filter_mod, { | out=0, freq=0, freq_mod, cBus1=1, gain=0.5, osc1=330, osc2=180, tri=111, noise=0.1, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, del, del_mod=0, dur, mod_freq_stretch |
              var snd, modulator_pf;
              var env = EnvGen.kr(Env.new([0, 1, 0.9, 0], [0.0, 0.85, 0.15],[-5, 0, -5]), doneAction: Done.freeSelf, timeScale: dur);
              var modulator_d = (EnvGen.kr(Env.new([0,0.1,1], [0,1], [0, -5]), timeScale: dur) * del_mod);
              var mod_f = Array.series(16, 1, mod_freq_stretch);
              var mod_p = Array.series(16, 0, 0.4);
              var modulator_f = SinOsc.kr(mod_f, mod_p, add: 0);
              var unused = Array.series(16, 0.1, 0.05);
              var par = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16];
              modulator_pf = Select.kr(freq_mod + 1, [
                      (EnvGen.kr(Env.new([0, 1, 0], [0,1], [-5, -5]), timeScale: dur) * freq),
                      freq, 
                      (EnvGen.kr(Env.new([0, 1, 0], [1,0], [-5, -5]), timeScale: dur) * freq)]);
              par = par * modulator_f;
              snd = IFilteredSnare.ar(Impulse.ar(modulator_pf),
                      band_1: par[0], band_2: par[1], band_3: par[2],
                      band_4: par[3], band_5: par[4], band_6: par[5],
                      band_7: par[6], band_8: par[7], band_9: par[8],
                      band10: par[9], band11: par[10], band12: par[11],
                      band13: par[12], band14: par[13], band15: par[14],
                      band16: par[15], delay: (modulator_d * 1024), osc_1_freq: osc1, osc_2_freq: osc2,
                      //band16: par[15], delay: del, osc_1_freq: osc1, osc_2_freq: osc2,	
                      triangle_freq: tri) * gain * env;
              Out.ar(out, snd);
      }).add;
      )
    #+end_src

    #+begin_src sclang :results none
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 0, \freq, 0.1, \freq_mod, 00, \mod_freq_stretch, 1, \dur, 10, \osc1, 200, \osc2, 330, \tri, 340, \noise, 1, \del_mod, 2, \del, 2000] );
      ~sisnare_flt = Synth.new("isnare_filter_mod", [\out, 1, \freq, 10, \freq_mod, 2, \dur, 12, \osc1, 120, \osc2, 235, \tri, 140, \del_mod, 0.5] );
      // s.meter;
    #+end_src

    #+name: isnare_filter_routine
    #+begin_src sclang :results none
      Pbind(
          \instrument, \isnare_filter_mod,
          \dur, 5,
          \freq, Pgauss(8, 3, inf),
          \freq_mod, Prand([0,1], inf),
          \del_mod, Pgauss(0.5, 0.5, inf),
          \b1, -120,
          \b2, -120,
          \b3, -120,
          \b4, -120,
          \b5, -120,
          \b6, -120,
          \b7, -120,
          \b8, -120,
          \b9, -120,
          \b10, -120,
          \b11, -120,
          \b12, -120,
          \b13, -120,
          \b14, -120,
          \b15, -120,
          \b16, -120,
          \osc1, Pgauss(230, 50, inf),
          \osc2, Pgauss(180, 50, inf),
          \tri, Pgauss(110, 30, inf),
          \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
          \noise, Pgauss(0.0, 0.1, inf),
          \mod_freq_stretch, Prand([0.1, 0.3, 0.5], inf)
      ).play;
    #+end_src

    Example of spatialization with filtering, no delay.
    #+begin_src sclang :results none
      Pbind(
          \out, 0,
          \instrument, \isnare_filter_mod,
          \del_mod, 0,
          \freq_mod, Prand([-0.2, 0, 1], inf),
          \dur, 10,
          \freq, Pgauss(10, 8, inf),
          \b1, Pgauss(-70, 20, inf),
          \b2, Pgauss(-70, 20, inf),
          \b3, Pgauss(-70, 20, inf),
          \b4, Pgauss(-70, 20, inf),
          \b5, Pgauss(-70, 20, inf),
          \b6, Pgauss(-70, 20, inf),
          \b7, Pgauss(-70, 20, inf),
          \b8, Pgauss(-70, 20, inf),
          \b9, Pgauss(-70, 20, inf),
          \b10, Pgauss(-70, 20, inf),
          \b11, Pgauss(-70, 20, inf),
          \b12, Pgauss(-70, 20, inf),
          \b13, Pgauss(-70, 20, inf),
          \b14, Pgauss(-70, 20, inf),
          \b15, Pgauss(-70, 20, inf),
          \b16, Pgauss(-70, 20, inf)
      ).play;
    #+end_src

    #+begin_src sclang :results none
      Pbind(
          \instrument, \isnare_filter_mod,
          \out, 0,
          \del_mod, 0,
          \freq_mod, Prand([0, 0], inf),
          \dur, 0.1,
          \freq, 10,
              \b1, Pseq([-0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, ], inf),
              \b2, Pseq([-4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, ], inf),
              \b3, Pseq([-8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, ], inf),
              \b4, Pseq([-12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, ], inf),
              \b5, Pseq([-16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, ], inf),
              \b6, Pseq([-21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, ], inf),
              \b7, Pseq([-25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, ], inf),
              \b8, Pseq([-29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, ], inf),
              \b9, Pseq([-33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, ], inf),
              \b10, Pseq([-37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, ], inf),
              \b11, Pseq([-42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, ], inf),
              \b12, Pseq([-46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, ], inf),
              \b13, Pseq([-50.526315789473685, -54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, ], inf),
              \b14, Pseq([-54.73684210526316, -58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, ], inf),
              \b15, Pseq([-58.94736842105263, -63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, ], inf),
              \b16, Pseq([-63.15789473684211, -67.36842105263158, -71.57894736842105, -75.78947368421052, -80.0, -0.0, -4.2105263157894735, -8.421052631578947, -12.631578947368421, -16.842105263157894, -21.052631578947366, -25.263157894736842, -29.473684210526315, -33.68421052631579, -37.89473684210526, -42.10526315789473, -46.31578947368421, -50.526315789473685, -54.73684210526316, -58.94736842105263, ], inf),
      ).play;
    #+end_src

    #+begin_src sclang :results none
      a = Pbind(\instrument, \isnare_filter_mod,
              \dur, 0.001,
              \freq, 5,
              \freq_mod, 0.09,
              \del_mod, 0.1,
              \b1, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
              \b2, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
              \b3, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
              \b4, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
              \b5, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
              \b6, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
              \b7, Pseq([-76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, ], inf),
              \b8, Pseq([-64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, ], inf),
              \b9, Pseq([-47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, ], inf),
              \b10, Pseq([-24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, ], inf),
              \b11, Pseq([-0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, ], inf),
              \b12, Pseq([-24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, ], inf),
              \b13, Pseq([-47.02282018870768, -64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, ], inf),
              \b14, Pseq([-64.72135955578251, -76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, ], inf),
              \b15, Pseq([-76.08452130766864, -80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, ], inf),
              \b16, Pseq([-80.0, -76.08452129752777, -64.72135953649345, -47.02282016215851, -24.721359521906425, -0.0, -24.721359553116837, -47.02282018870768, -64.72135955578251, -76.08452130766864, ], inf),
      );

      b = Pbind(\instrument, \isnare_filter_mod,
              \dur, 0.005,
              \freq, 1,
              \freq_mod, 2,
              \del_mod, 5,
              \b1, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
              \b2, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
              \b3, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
              \b4, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
              \b5, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
              \b6, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
              \b7, Prand([-11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, ], inf),
              \b8, Prand([-10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, ], inf),
              \b9, Prand([-8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, ], inf),
              \b10, Prand([-8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, ], inf),
              \b11, Prand([-80.0, -40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, ], inf),
              \b12, Prand([-40.0, -26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, ], inf),
              \b13, Prand([-26.666666666666664, -20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, ], inf),
              \b14, Prand([-20.0, -16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, ], inf),
              \b15, Prand([-16.0, -13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, ], inf),
              \b16, Prand([-13.333333333333332, -11.428571428571427, -10.0, -8.88888888888889, -8.0, -80.0, -40.0, -26.666666666666664, -20.0, -16.0, ], inf),
      );
      Ptpar([0, a, 0.5, b]).play;
    #+end_src

    Controlling the filters
    #+begin_src sclang :results none :noweb eval
      ~init_durs.value
      (     
      ~player1 = Pbind(
          \instrument, \isnare,
          \dur, Pseq(~init_durs.value, inf),
          \freq, Prand([0, 0, 20], inf),
          \osc1, Pgauss(330, 10, inf),
          \osc2, Pgauss(180, 10, inf),
          \tri, Pgauss(110, 30, inf),
          \gain, Prand([0.5, 0.3, 0.45, 0.35], inf),
          \noise, Pgauss(0.3, 0.1, inf)
      ).play;
      )
    #+end_src

    Stop playback
    #+begin_src sclang :results none
      ~player1.stop;
    #+end_src
*** bass snare 1
Used in the drum loop among other places.
**** synthdef
#+name: bsnare
#+begin_src sclang :results none
  (
  ~bass_snare = SynthDef(\bsnare, {
      var snd;
      var impfreq = \impfreq.kr(1),
      osc1 = \osc1.kr(50),
      osc2 = \osc2.kr(70),
      trifreq = \trifreq.kr(10),
      fltq = \fltq.kr(1),
      fltfreq = \fltfrq.kr(100),
      fltgain = \fltgain.kr(1),
      modfreq = \modfreq.kr(0),
      attack = \attack.kr(0.0000001),
      rel = \release.kr(0.1),
      noise_attack = \nattack.kr(1e-08),
      noise_sustain = \nsustain.kr(0.016),
      noise_rel = \nrel.kr(0.1),
      noise_vol = \nvol.kr(0.073),
      dur = \length.ir(0.5),
      gain = \gain.ir(1.0),
      env = Env.new(levels: [0, 1, 0], times: [0.000001, dur]);
      snd = OBassSnare.ar(Impulse.ar(impfreq),
                  osc_1_freq: osc1,
                  osc_2_freq: osc2, 
                  triangle_freq: trifreq,
                  flt_frq: fltfreq,
                  flt_q: fltq,
                  flt_gain: fltgain,
                  modulation_freq: modfreq,
                  noise_sustain: 0.2,
                  noise_vol: 0.05,
                  noise_rel: 0.01) * EnvGen.kr(env, doneAction: Done.freeSelf);
      Out.ar(0, snd * gain);
  }).add
  )
#+end_src

#+name: bsnare_play
#+begin_src sclang :results none
  ~bsnare = Synth.new("bsnare", [\impfreq, 0, \mod_freq, 0]);
#+end_src

#+begin_src sclang :results none
  ~bsnare = Synth.new("bsnare", [\impfreq, 1, \mod_freq, 0, \trifreq, 150, \osc1, 130, \osc2, 70, \nvol, 0.5, \nrel, 0.9, \release, 0.001, \fltfrq, 400, \fltq, Kms0.1, \gain, 4]);
#+end_src

#+begin_src sclang :results none
  SynthDef(\odisp_snare, {
      var impfreq = \impfreq.kr(1), position = \pos.kr(0), disperse = \disperse.kr(1), attack = \attack.kr(1e-08),
      noise_attack = \nattack.kr(1e-08), noise_lvl = \nlevel.kr(0.1), noise_rel = \nrel.kr(0.1),
      osc1 = \osc1freq.kr(330), osc2 = \osc2freq.kr(180), rel = \rel.kr(0.1),
      trifreq = \trifreq.kr(111);
      var snd;
      var modulator = SinOsc.kr([1!16],[0.1!16]);
      snd = ODispersedSnare.ar(Impulse.ar(impfreq),
                  osc_1_freq: osc1, osc_2_freq: osc2,
                  triangle_freq: trifreq);
      Out.ar(position, snd);
  }).add;
#+end_src

#+begin_src sclang :results none
  ~snare = Synth.new("odisp_snare", [\impfreq, 30, \disperse, 0]);
  s.meter;
#+end_src

**** pbind for bsnare
#+begin_src sclang :results none
  (
  ~bsnare_player = Pbind(
      \instrument, \bsnare,
      \dur, 0.5,
      \impfreq, Pwhite(1, 4, inf),
      \mod_freq, 0,
      \fltfrq, Pwhite(100, 200, inf),
      \fltq, Pseq((1..60) / 60, inf),
      \fltgain, Pseq(1 / (1..10), 20),
      \fltfreq, Pseq((100..200), 20)
  ).play;
  )
#+end_src
*** snare 5: isnaredisp 
**** synthdef
#+name: flt_snare_dispersed
#+begin_src sclang :results none
  (
  ~isnaredisp = SynthDef(\isnaredisp, {
      var snd,
      o_offset = \offset.ir(0),cd
      period = \pulse_period.kr(5000),
      random = \random.ir(1),
      osc1 = \osc1.kr(50),
      osc2 = \osc2.kr(60),
      tri = \triangle.kr(90),
      noise_lvl = \noise_lvl.kr(0.1),
      noise_attack = \noise_attack.kr(0.0001),
      noise_rel = \noise_rel.kr(0.1);
      snd = IFilteredSnareDispersed.ar(
                  offset: o_offset,
                  random: random,
                  tempo: period,
                  osc_1_freq: osc1,
                  osc_2_freq: osc2,
                  triangle_freq: tri,
                  noise_lvl: noise_lvl,
                  noise_attack: noise_attack,
                  noise_rel: noise_rel);
      Out.ar(0, snd);
  }).add
  )
#+end_src

Start it up
#+begin_src sclang :results none
  ~ifiltsnare = Synth.new("isnaredisp", [\pulse_period, 10000, \random, 0, \offset, 0]);
  s.meter;
#+end_src

Control the speed via a slider.
#+begin_src sclang :results none
  (
  w = Window.new.front;
  b = NumberBox(w, Rect(20, 20, 150, 20));
  a = Slider(w, Rect(20, 60, 150, 20)).action_({
      b.value_(a.value);
      ~ifiltsnare.set(\pulse_period, (a.value * 48000));
  });
  a.action.value;
  )     
#+end_src

*** snare 6: ambisonics
**** synthdef
Simple instance of a snare synth

#+begin_src sclang :results none :noweb yes
  <<boot_jack>>
#+end_src

#+name: original_snare_two
#+begin_src sclang :results none
  (
  ~snare_one = SynthDef(\snare, { | gain=1, freq=2000, vol=4, q=1, out=0, length=0.5 |
      var snd;
      var env = Env([0, 1, 0], [0.0001, length]);
      snd = IGenericSnarefs.ar(freq,
                  \attack.kr(0.000001),
                  \noiseattack.kr(0.000001),
                  \noiselvl.kr(0.1),
                  \noiserel.kr(0.01),
                  \osc1.kr(300),
                  \osc2.kr(200),
                  \release.ir(0.1),
                  \tri.kr(400)) * EnvGen.kr(env, doneAction: Done.freeSelf);
      snd = snd * 0.5;
      Out.ar(out, snd);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  ~snare_one.free;
#+end_src

**** player
Play one hit on the snare above.
#+name: reg_snare_load
#+begin_src sclang :results none
  ~reg_snare = Synth.new("snare", [\freq, 5000, \noiselvl, 0.1, \out, 0, \length, 0.1] );
#+end_src
     
Pbind for ambisonics
#+name: player
#+begin_src sclang :results none
  Pbind(\instrument, \snare,
      \freq, 3000,
      \out, 0,
      \dur, Prand([0.1, 0.2], inf)
  ).play;
  s.meter;
#+end_src
     
#+call: play()

Double player
#+name: play
#+begin_src sclang :results none
  ~a_player = Pbind(\instrument, \snare,
          \freq, 3000,
          \out, 31,
          \dur, 0.1,
          \freq, 300
  ); 
  ~b_player = Pbind(\instrument, \snare,
          \freq, 1000,
          \out, 33,
          \dur, 0.2
  );
  ~a_player.play;
  ~b_player.play;
  s.meter;
#+end_src

#+begin_src sclang :results none
  ~a_player.stop;
  ~b_player.stop;
#+end_src
     
#+call: connect()

**** ambisonics
     
***** 1D114 3rd order
Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
#+name: encode
#+begin_src sclang :results none
  (
  // Settings
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 16;
  s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal.put(0, {HOAEncoder.ar(~order, In.ar(17, 1), \azpana.kr(3.14), \elpana.kr(3.14))});
  ~hoaSignal.put(1, ({HOAEncoder.ar(~order, In.ar(19, 1), \azpanb.kr(3.14), \elpanb.kr(3.14))}));
  ~hoaSignal.fadeTime = 1;

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
      var in; in = \in.ar(0!~hoaNumChannels);
      in.add(0);
      KMH114AEC3h3pFull6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src

Print the possible control keys for this NodeProxy
#+begin_src sclang :results none
  ~hoaSignal.controlKeys;
#+end_src
      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src
***** 1D108 3rd order
Start the player
#+call: play()
Start the encoder
#+call: encode()
Connect the encoder with the decoder
#+call: connect()


Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
#+name: encode
#+begin_src sclang :results none :noweb yes
  (
  // Settings
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 8;
  //s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
  //~hoaSignal.play;

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal[0] = { HOAEncoder.ar(~order, In.ar(17, 1), \azpana.kr(-3.14), \elpana.kr(0), \gaina.kr(0), plane_spherical:1) };
  ~hoaSignal[1] = { HOAEncoder.ar(~order, In.ar(19, 1), \azpanb.kr(-3.14), \elpanb.kr(0),  plane_spherical:1) };
  ~hoaSignal.fadeTime = 0.1;

  // Panning automation
  // Create a new panner NodeProxy
  ~azimuthA = NodeProxy.control(s, 1);
  ~azimuthB = NodeProxy.control(s, 1);

  // Set its source to a control signal 
  ~azimuthA.source = { MouseX.kr(-pi, pi); };
  //	 ~azimuthA.source = { SinOsc.kr(0.1, 0, 0.7pi, 0); };
  ~azimuthB.source = { SinOsc.kr(0.2, 0, 0.5pi, 0); };

  // Call .set on the object you want to control given the parameter and the control proxy as arguments

  ~hoaSignal.set(\azpana, ~azimuthA);
  //	 ~hoaSignal.set(\azpanb, ~azimuthB);
  //	 ~azimuthA.play;
  //	 ~azimuthB.play;

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
          var in; in = \in.ar(0!~hoaNumChannels);
          in.add(0);
          KMH108AE3h3pNormal6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src
      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src

Control the panning position A
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 3.14);
  ~hoaSignal.set(\elpana, 3.14);
  ~hoaSignal.set(\azpanb, 3.14);
  ~hoaSignal.set(\elpanb, 3.14);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 0);
  ~hoaSignal.set(\elpana, 0);
  ~hoaSignal.set(\azpanb, 0);
  ~hoaSignal.set(\elpanb, 0);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, -3.14);
  ~hoaSignal.set(\elpana, -3.14);
  ~hoaSignal.set(\azpanb, -3.14);
  ~hoaSignal.set(\elpanb, -3.14);
#+end_src

Control the panning position B
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, 1.25);
  ~hoaSignal.set(\elpana, 1.25);
  ~hoaSignal.set(\azpanb, 1.25);
  ~hoaSignal.set(\elpanb, 1.25);
#+end_src

***** Lilla salen 3rd order
Start server
#+call: boot_jack()
Start the player
#+call: play()
Start the encoder
#+call: l_encode()
Connect the encoder with the decoder
#+call: connect()

#+begin_src sclang :results none

#+end_src
Set the environment variables, then, create the encoder and the decoder.
Two encoders in parallel feeding to the same decoder (see [[*Connect][Connect]] below)
See also the demo in [[file:~/org/babel/sc_snippets.org::*Example%20with%20control][Example with control]]
#+name: l_encode
#+begin_src sclang :results none :noweb yes
  (
  // Settings
  var trig;
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 29;
  //s.scope(~hoaNumChannels);

  // Create the input bus and the encoder
  ~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
  //~hoaSignal.play;

  // hoaSignal.source och hoaSignal.add verkar fungera lika bra.
  ~hoaSignal[0] = { HOAEncoder13.ar(In.ar(31, 1), \gaina.kr(0), \rad.kr(2), \azpana.kr(-3.14), \elpana.kr(0)) };
  ~hoaSignal[1] = { HOAEncoder13.ar(In.ar(33, 1), \gaina.kr(0), \rad.kr(2), \azpanb.kr(-3.14), \elpanb.kr(0)) };
  ~hoaSignal.fadeTime = 0.1;

  // Panning automation
  // Create a new panner NodeProxy
  ~azimuthA = NodeProxy.control(s, 1);
  ~azimuthB = NodeProxy.control(s, 1);
  ~elevationA = NodeProxy.control(s, 1);
  ~elevationB = NodeProxy.control(s, 1);
  ~radiusA = NodeProxy.control(s, 1);

  // Set its source to a control signal 
  // The HOAencoder used above has 0 deg in front moving counter 
  // clockwise to 360 deg at front again.
  // 90 deg Y-axis is top and -90 is bottom

  // ~azimuthA.source = { MouseX.kr(0, 360); };
  // ~azimuthB.source = { MouseX.kr(0, 360); };
  // ~elevationA.source = { MouseY.kr(-90, 90); };
  // ~elevationB.source = { MouseY.kr(-90, 90); };
  trig = Impulse.kr(0.01);
  ~azimuthA.source = { LinLin.kr(Phasor.kr(Impulse.kr(0.5), 0.5/ControlRate.ir), 0, 1, 0, 360); };
  ~azimuthB.source = { LinLin.kr(Phasor.kr(Impulse.kr(0.5), 0.5/ControlRate.ir), 0, 1, 0, 360); };
  //~radiusA.source = { MouseX.kr(360, 1); };

  // Call .set on the object you want to control given the parameter and the control proxy as arguments
  ~hoaSignal.set(\azpana, ~azimuthA);
  ~hoaSignal.set(\azpanb, ~azimuthB);
  ~hoaSignal.set(\elpana, ~elevationA);
  ~hoaSignal.set(\elpanb, ~elevationB);
  ~hoaSignal.set(\rad, ~radiusA);

  // Decoder
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
      var in; in = \in.ar(0!~hoaNumChannels);
      in.add(-10);
      KMHLSDome3h3pNormal6.ar(*in);
  };
  ~decoder.fadeTime = 1;
  )
#+end_src
      
Clear the instances
#+begin_src sclang :results none
  ~hoaSignal.clear;
  ~azimuthA.clear;
  ~decoder.clear;
#+end_src
***** panning
Panning instrument
#+name: snare_panner
#+begin_src sclang :results none
  ~hoaSignal.set(\azpana, In.kr();
#+end_src

***** Connect
Signal, encoded and decoded, but not mapped. Use this.
#+name: connect
#+begin_src sclang :results none
  (
  ~decoder.play(0, ~decoderNumChannels, vol: 16.0);
  ~hoaSignal <>> ~decoder;
  )
#+end_src

***** Disconnect
#+begin_src sclang :results none
  ~decoder.clear;
  ~hoaSignal.clear;
  ~hoaSignalA.clear;
  ~hoaSignalB.clear;
#+end_src

*** snare 7: convolution
**** synthdef
#+begin_src sclang :results none
  (
  SynthDef(\isnare, { | outBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0, pulse=200, dur=1, distance=0 |
      var snd, rev;
      var env = Env([0, 1, 0], [0.0001, 0.5]);
      snd = IDispersedSnare.ar(position, disperse, pulse) * EnvGen.kr(env, timeScale: dur, doneAction: Done.freeSelf);
      rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
      Out.ar(outBus, snd);
  }).add;
  )
#+end_src

Named controls
#+begin_src sclang :results none
  (
  SynthDef(\isnarenc, {
          var snd;
          var env = Env([0, 1, 0], [0.0001, 0.5]);
          snd = ODispersedSnare.ar(Impulse.ar(\pulse.ar(440)), \position.kr(0), \disperse.kr(0)) * EnvGen.kr(env, timeScale: \dur.kr(1), doneAction: Done.freeSelf);
          //	   rev = FreeVerb.ar(snd * gain, mix: distance, room: 1, damp: 0.5);
          Out.ar(\outBus.ir, snd);
  }).add;
  )
#+end_src
     
**** player
#+begin_src sclang :results none
  (
  a = Array.fill(16, { arg i; (i + 1) / 16 });
  Pbind (\instrument, \isnarenc,
          //	   \position, Pseq((0..29), inf),
          \position, 0,
          \outBus, 0,
          \disperse, 0.0,
          \pulse, 10000,
          \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
          \gain, Pseq(a, inf),
          \distance, Pseq(a.reverse, inf),
          \dur, 2
  ).play;
  )
  //       s.meter;
#+end_src

#+begin_src sclang :results none
  (
  a = Array.fill(16, { arg i; (i + 1) / 16 });
  Pbind (\instrument, \isnare,
      \position, Pseq((0..29), inf),
      \disperse, 0.0,
      \impf, 80000, //Pfunc({30.rand2}),
      \osc1, Pseq([330,320,310,300,290,250,220,250,280,300,320], inf),
      \gain, Pseq(a, 16),
      \distance, Pseq(a.reverse, 16),
      \dur, 1
  ).play;
  )

  (
  Pbind (\instrument, \isnare,
      \position, 1,
      \distance, Pseq([0, 0.1, 0.2, 0.3, 0.4, 0.5], 10),
      \disperse, 0,
      \impf, 10000,
      \dur, 1,
      \delta, 0
  ).play;
  )
#+end_src

**** convolution
preparation; essentially, allocate an impulse response buffer, then
follow a special buffer preparation step to set up the data the plugin needs.
Different options are provided commented out for loading impulse responses from soundfiles.
 

#+begin_src sclang :results none

  (
  ​
  // also 4096 works on my machine; 1024 too often and amortisation too pushed, 8192 more high load FFT
  ~fftsize = 4096;
  ​
  s.waitForBoot {
          ​
          {
                  var ir, irbuffer, bufsize;
                  ​
                  // // MONO ONLY
                  // pre-existing impulse response sound files
                  // (could also use any general soundfile too for cross-synthesis effects)
                  // irbuffer = Buffer.read(s, "/Volumes/data/audio/ir/ir2.wav");
                  ​
                  // synthesise the honourable 'Dan Stowell' impulse response
                  ​
                  ir = [1] ++ 0.dup(100) ++ (
                          (1, 0.99998 .. 0)
                          .collect {|f|
                                  f = f.squared.squared;
                                  f = if(f.coin) { 0 }{ f.squared };
                                  f = if(0.5.coin) { 0 - f } { f }
                          } * 0.1
                  );
                  ir = ir.normalizeSum;
                  ​
                  irbuffer = Buffer.loadCollection(s, ir);
                  ​
                  s.sync;
                  ​
                  bufsize = PartConv.calcBufSize(~fftsize, irbuffer);
                  ​
                  // ~numpartitions= PartConv.calcNumPartitions(~fftsize, irbuffer);
                  ​
                  ~irspectrum = Buffer.alloc(s, bufsize, 1);
                  ~irspectrum.preparePartConv(irbuffer, ~fftsize);
                  ​
                  s.sync;
                  ​
                  irbuffer.free; // don't need time domain data anymore, just needed spectral version
          }.fork;
          ​
  }
  )
  ​
  ~target = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

  (
  {
          var input = PlayBuf.ar(1, ~target, loop:1);
          var rev = PartConv.ar(input, ~fftsize, ~irspectrum.bufnum, 0.5);
          var mix = (input * 0) + (rev * 1);
          Out.ar(0, mix);
  }.play
  )

  (
  {
          PlayBuf.ar(1, ~target, loop:1);
  }).play

#+end_src
     
*** snare 8: polyrhythmic
**** synthdef
#+name: i_snare_poly
#+begin_src sclang :results none
  (
  ~isnarePoly = SynthDef(\isnarePoly, {
          var snd, env, envelope, duration=1, pulse, nlvl, nr;
          /* Envelope and duration */
          envelope = Env.new(
                  levels: [0, 1, 0.7, 0],
                  times: [0.2, 0.2, 0.6],
                  curve: \sine
          );
          b = 0;
          envelope.times.do({ arg i; b = b + i; });
          duration = \dur.ir / b;
          env = EnvGen.kr(envelope, timeScale: duration, doneAction: Done.freeSelf);

          /* Parameter: pulse */
          pulse = \pulse.kr(40) * \pulseMod.kr(1);
          /*
                  Parameter: noislevel.
                  Scale it to pulse
          ,*/
          nlvl = LinExp.kr(pulse, 1, 800, 0.5, 0.000001);
          nr = LinExp.kr(pulse, 1, 800, 1.5, 0.00001);
          snd = ISnarePhaseDisp.ar(\pos.kr(0),
                  \disperse.kr(0),
                  pulse,
                  \amp.kr(0.2),
                  \attack.kr(0.0001),
                  \fsweep.kr(0),
                  \nattack.kr(0.0001),
                  nlvl,
                  //\nrel.kr(0.01),
                  nr,	
                  \osc1.kr(300),
                  \osc2.kr(140),
                  \rel.kr(0.01),
                  \tri.kr(130));
          Out.ar(\outBus.ir, snd * env);
  }).add;
  )
#+end_src

#+begin_src sclang :results none
  a = Synth.new(\isnarePoly, [\pulse, 4, \dur, 10], addAction: \addToTail);
#+end_src
#+begin_src sclang :results none
  (
  SynthDef(\controlSnare, { arg bus;
      Out.kr(bus, Line.kr(\start.kr(0), \end.kr(1), \dur.kr(1), doneAction: Done.freeSelf));
  }).add;
  )
#+end_src

Free busses and instances
#+begin_src sclang :results none
  ~speedControl.numChannels;
  ~speedControl.free;
#+end_src

#+begin_src sclang :results none
  { Poll.kr(Impulse.kr(10), LinExp.kr(Line.kr(1, 100, 5, doneAction: Done.freeSelf), 1, 200, 0.9, 0.00001)) }.play;
#+end_src

#+begin_src sclang :results none
  { Poll.kr(Line.kr(1, 100, 5, doneAction: Done.freeSelf)) }.play;
#+end_src
**** player
Load synth def:
#+call: i_snare_poly()

To play the ISnarePhaseDisp with modulation:
#+begin_src sclang :results none :noweb yes
  //  ~speedControl = Bus.control(s, 1);
<<i_snare_poly()>>;
  a = Synth.new(\isnarePoly, [\pulse, 5, \rel, 0.01, \dur, 2], addAction: \addToTail);
  //  a.map(\pulseMod, ~speedControl);
  //  y = {Out.kr(~speedControl, Line.kr(\start.kr(0.001), \end.kr(1), \dur.kr(10), doneAction: Done.freeSelf)) }.play(addAction: \addToHead);
  //       y = {Out.kr(~speedControl, SinOsc.kr(1, 0, 1, 1))}.play(addAction: \addToHead);
  //       b = Synth.new(\controlSnare, [~speedControl, \dur, 1, \start, 10, \end, 1], addAction: \addToHead);
#+end_src

#+begin_src sclang :results none
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \dur, 2,
          \rel, 0.01,
          \outBus, 1,
  ).trace.play;
#+end_src

Harmnony from integer multiples of freq 100 and 200 Hz
#+begin_src sclang :results none
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Prand([1,2,3,4], 10) * 200,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \dur, 13,
          \rel, 0.01,
          \outBus, 1,
  ).trace.play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Prand([1,2,3,4,5,6], 10) * 200,
          \dur, 21,
          \amp, 0.01,
          \rel, 0.01,
          \outBus, 0
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \dur, 13,
          \rel, 0.01,
          \outBus, 1,
  ).trace.play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
          \dur, 8,
          \amp, 0.01,
          \rel, 0.01,
          \outBus, 0
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 100,
          \dur, 5,
          \amp, 0.01,
          \rel, 0.01,
          \outBus, 1
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse,  Pfunc(1+ 10.rand2.abs * 100),
          \dur, 3,
          \amp, 0.01,
          \rel, 0.01,
          \outBus, 0
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse,  Pfunc(1+ 10.rand2.abs * 100),
          \dur, 2,
          \amp, 0.01,
          \rel, 0.01,
          \outBus, 1
  ).play;
#+end_src

Corresponding polyrhythms from the above harmony (at a slower rate)
#+begin_src sclang :results none
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5], 10) * 2,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ),
          \rel, 0.04,
          \dur, 34,
          \outBus, 1,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5], 10) * 2,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ), 
          \rel, 0.045,
          \dur, 21,
          \amp, 0.01,
          \outBus, 0,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ),
          \rel, 0.04,
          \dur, 13,
          \outBus, 1,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ), 
          \rel, 0.04,
          \dur, 8,
          \amp, 0.01,
          \outBus, 0,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ), 
          \rel, 0.04,
          \dur, 5,
          \amp, 0.01,
          \outBus, 1,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ), 
          \rel, 0.04,
          \dur, 3,
          \amp, 0.01,
          \outBus, 0,
  ).play;
  Pbind(
          \instrument, \isnarePoly,
          \pulse, Pxrand([1,2,3,4,5,6,7,8,9], 10) * 1,
          \amp, Pfunc( 1 / Pkey(\pulse) * 0.9),
          \tri, Pfunc( Pkey(\pulse) * 50),
          \osc1, Pfunc({1.0.rand} * 400 ),
          \osc2, Pfunc({1.0.rand} * 300 ),
          \rel, 0.04,
          \dur, 2,
          \amp, 0.01,
          \outBus, 1,
  ).play;
#+end_src

#+begin_src sclang :results none
  s.reboot; // this will restart the server and thus reset the bus allocators
#+end_src

#+begin_src sclang :results none :noweb yes
  <<first_acc()>>
  <<second_acc()>>
#+end_src
#+name: first_acc
#+begin_src sclang :results none
  (
  var busA, busB, dur;
  dur = 24;
  busA = Bus.control(s, 1);
  busB = Bus.control(s, 1);
  y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.1, \end, 300]);
  x = Synth.after(y, \isnarePoly, [\pos, 1,\pulse, 1, \dur, dur, \busA, busA.index]);
  )
#+end_src

#+name: second_acc
#+begin_src sclang :results none
  (
  var busA, busB, dur;
  dur = 24;
  busA = Bus.control(s, 1);
  busB = Bus.control(s, 1);
  y = Synth.tail(s, \controlSnare, [ \out, busA.index, \dur, dur, \start, 0.00001, \end, 200]);
  x = Synth.after(y, \isnarePoly, [\pos, 0, \pulse, 0, \dur, dur, \busA, busA.index]);
  )
#+end_src
     
#+begin_src sclang :results none
  (
  f = {
          Task ({
                  loop {
                          100.do({ |val|
                                  a.set(\pulse, 5 * val);
                                  val.postln;
                                  0.1.wait;
                          });
                  }
          });
  };
  u = f.value.play;
  )

#+end_src
** pbind for accelerando
This is the pbind for the acc defined here: [[*accelerando, fixed tempo][accelerando, fixed tempo]]
The Synthdef is here: [[*synthdef][snare]]
#+name: accelerando_accent
#+begin_src sclang :results none :noweb yes
  (
  ~accent = Pbind(
          \instrument, \snare,
          \gain, Pdefn(\accents),
          \dur, Pdefn(\duration),
          \out, 0
  );
  )
  //     Pdefn(\accents, Pseq(seq.value(4), 1));
  //     Pdefn(\accents, Pfunc({{|x=0| x+1; if(x==0, {1.0}, {rrand(0.2, 0.15)})} ! 4 }, 1));
  //     Pdefn(\duration, 1);
#+end_src

Second instance
#+name: accelerando_accent_two
#+begin_src sclang :results none :noweb yes
  // var seq = { |length=4|
  //         { |x=0| x+1; if(x==0, {1.0}, {0.01})} ! length;
  // };
(
  ~accent_two = Pbind(
          \instrument, \snare,
          \gain, Pdefn(\accents),
          \dur, Pdefn(\duration),
          \out, 1
  );
  // Pdefn(\accents, Pseq(seq.value(4), 1));
  // Pdefn(\duration, 1);
  )
#+end_src

#+begin_src sclang :results none
  ~accenti.play;
#+end_src
** beat
*** drumloop
#+begin_src sclang :results none
  p = Plambda(
      Pbind(
          \a, Plet(\z, Pseries(0, 1, inf), Pseries(100, -1, inf)),
          \b, Pget(\z, 0, inf) * 2
      ).trace(key: \eventScope, prefix: "\nscope: ")
  ).asStream;

  p.next(());
#+end_src

#+begin_src sclang :results none
  (
  var a, b, c, t;
  a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
  b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
  c = Ppar([a, b]);
  t = c.asStream;
  20.do({ t.next(Event.default).postln; });
  )
#+end_src

Load SynthDefs:
#+call: bsnare()
#+call: original_snare()
#+call: i_snare_phase_2()
#+call: bsnare_play()

#+begin_src sclang :results none
  Synth.new("snare_phase", [\pulse, 1, \nlevel, 0]);
#+end_src

Bass drum pulse with variation
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
          \instrument, \bsnare,
          \impfreq, 0,
          \length, 0.2,
          \osc1, 80,
          \osc2, 50,
          \trifreq, 70,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \release, 0.9,
          \dur, beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / originalTempo }
  ).play;
#+end_src

Snare drum beat
#+begin_src sclang :results none
  var beatsInLoop = 4,
  originalTempo = 110 / 60 * beatsInLoop;

  TempoClock.tempo = originalTempo;

  Pbind(
          \instrument, \snare,
          \impf, 10,
          \freq, 300,
          \trifreq, 100,
          \length, 0.2,
          \out, 1,
          \gain, 1,
          \dur, beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / originalTempo}
  ).play;
#+end_src

Global variables
#+name: global_tempo
#+begin_src sclang :results none
  ~beatsInLoop = 8;
  ~originalTempo = 90 / 60;
  TempoClock.tempo = ~originalTempo;
#+end_src

First bass drum pattern
#+name: b_drum_1
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_1  = Pbind (
          \instrument, \bsnare,
          \impfreq, 100,
          \osc1, 80,
          \osc2, 70,
          \trifreq, 70,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \gain, 4,
          \release, 0.9,
          \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.3,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  );
#+end_src

First bass drum pattern
#+name: b_drum_2
#+begin_src sclang :results none :noweb yes
  ~loop_bass_dr_2  = Pbind (
          \instrument, \bsnare,
          \impfreq, 1,
          \osc1, 70,
          \osc2, 50,
          \trifreq, 75,
          \fltfrq, Pseq([100, 200, 300, 400, 500, 600, 700, 800], inf) + 200,
          \fltq, Pseq((1..7), inf),
          \gain, 4,
          \release, 0.9,
          \length, Prand([0.2, 0.4, 0.5, 0.6, 0.9], inf) * 0.5,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc { thisThread.clock.tempo },
          \rate, Pfunc { thisThread.clock.tempo / ~originalTempo }
  ).play;
#+end_src

First snare drum
#+name: s_drum_1
#+begin_src sclang :results none
  ~loop_snare_1 = Pbind (
          \instrument, \snare,
          \impf, Prand([~originalTempo, ~originalTempo*7, ~originalTempo*9], inf),
          \freq, Pseq([100, 200], inf),
          \trifreq, 500,
          \length, Prand((40..80), inf) * 0.01,
          \out, 0,
          \gain, 0.05,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_2
#+begin_src sclang :results none
  ~loop_snare_2 = Pbind(
          \instrument, \snare,
          \impf, Prand([~originalTempo, ~originalTempo*2, ~originalTempo*3, ~originalTempo*4], inf),
          \freq, Pseq([500, 520, 530], inf),
          \trifreq, 50,
          \length, Prand((80..150), inf) * 0.01,
          \out, 1,
          \gain, 0.2,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+name: s_drum_3
#+begin_src sclang :results none
  ~loop_snare_3 = Pbind(
          \instrument, \snare_phase_2,
          \freq, Pseq([400, 500], inf),
          \freq2, Pseq([400, 550], inf),	
          \length, Prand((70..100), inf) * 0.01,
          \out, 1,
          \gain, 0.4,
          \dur, ~beatsInLoop,
          \time, Pkey(\dur) / Pfunc {thisThread.clock.tempo},
          \rate, Pfunc {thisThread.clock.tempo / ~originalTempo}
  )
#+end_src

#+begin_src sclang :results none
  s.meter;
#+end_src
Attempt to make a complete beat with variation.
#+begin_src sclang :results none :noweb yes
  (
  <<bsnare()>>;
  <<original_snare()>>;
  <<i_snare_phase_2()>>;
  <<bsnare_play()>>;

  <<global_tempo()>>;
  <<b_drum_1()>>;
  <<b_drum_2()>>;
  <<s_drum_1()>>;
  <<s_drum_2()>>;
  <<s_drum_3()>>;
  p = Ptpar([
          0, ~loop_bass_dr_1,
          0.5, ~loop_bass_dr_2,
          0.75, Pn(
                  ~loop_snare_1	
          ),
          1, Pn(
                  Plazy {
                          ~loop_snare_2	
                  }	
          ),
          2, ~loop_bass_dr_1,
          2.75, ~loop_bass_dr_2,
          3, Pn(
                  ~loop_snare_3
          ),
          4.5, ~loop_bass_dr_1,
          4.75, ~loop_bass_dr_2,
          5, Pn(
                  Plazy {
                          ~loop_snare_2	
                  }	
          ),
          6, ~loop_bass_dr_1,
          6, ~loop_bass_dr_2,
          7, Pn(
                  ~loop_snare_3
          )
  ], 1).play;
  )

#+end_src
** panning
*** testing
:PROPERTIES:
:NOTER_DOCUMENT: /home/henrikfr/org/textnotes.org
:END:
Generalized example module for stereo panning.
#+begin_src sclang :results none :noweb yes
  ~panner = SynthDef(\stereo_panner, { |in, out=0, pan=0|
          var sig, output, direction;
          sig = In.ar(in, 1);
          direction = pan;
          Out.ar(out, Pan2.ar(sig, pan));
  }).add;
#+end_src

#+begin_src sclang :results none
  ~panner.free; 
#+end_src

#+begin_src sclang :results none :noweb yes
  var synth;
  ~synth = Synth.after(~snare_phase_2, \stereo_panner, [in: 25, pan: 0, out: 0]);
  <<ssingle>>
  //  s.meter;
#+end_src

Pan the signal in ~\~synth~.
#+begin_src sclang :results none
  ~synth.set(\pan, -1);
#+end_src

#+begin_src sclang :results none
  s.meter;
#+end_src

An example NodeProxy ~\~stereo_panner~ that pans the signal in ~\~player~. This shoule be altered to take a signal as argument. 
#+begin_src sclang :results none
  ~player = NodeProxy.new(s, \audio, 2);
  ~player.fadeTime = 1;
  ~player.source = { SinOsc.ar(440, 0, 0.1); };

  ~stereo_panner = NodeProxy.new.play;
  ~stereo_panner.fadeTime = 1;
  ~stereo_panner.source = {
          var in;
          in = \in.ar(0);
          Pan2.ar(in, \pan.kr(0););
  };

  ~player <>> ~stereo_panner;
#+end_src

Pan the above signal through ~\~stereo_panner~.
#+begin_src sclang :results none
  ~stereo_panner.set(\pan, 1);
#+end_src

*** pan factory
#+call: boot_jack()

Set up a factory method that creates a new NodeProxy and returns it.
#+name: pan_source_factory
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~pan_source_factory = { |synth|
          n = NodeProxy.new(s, \audio, 2);
          n.fadeTime= 1;
          n.source = synth;
      n;
  };
#+end_src

A panner factory that instantiates a NodeProxy for stereo panning.
#+name: panner_factory
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner_factory = { |panf|
          p = NodeProxy.new.play(0, 16);
          p.fadeTime = 1;
          p.source = panf;
          p;
  };
#+end_src

Instantiate a new ~\~pan_source_factory~ instance by name of ~\~sounder~.
#+name: sounder
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder = ~pan_source_factory.value({ SinOsc.ar(440, 0, 0.1); });
#+end_src

Instantiate a new ~\~panner_factory~ instance by name of ~\~panner~. This is how one assigns a pan function to a connection.
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner = ~panner_factory.value({
          var in;
          in = \in.ar(0);
          Pan2.ar(in, \pan.kr(0););
  });
#+end_src

Assign a new panning function to the ~\~panner~:
#+begin_src sclang :results none
  ~panner.source = {
      var in;
      in = \in.ar(0);
      PanAz.ar(
          numChans: 5,
          in: in,
          pos: LFSaw.kr(MouseX.kr(0.2, 8, 'exponential')),
          level: 0.5,
          width: 3,
          orientation: 0.5
      );
  };
#+end_src

Get back the old panner
#+begin_src sclang :results none
  ~panner.source = {
          var in;
          in = \in.ar(0);
          Pan2.ar(in, \pan.kr(0););
  };
#+end_src

#+begin_src sclang
  s.meter;
#+end_src
Instantiate a new ~\~pan_source_factory~ and a ~\~panner_factory~ at the same time:
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder2 = ~pan_source_factory.value({ SinOsc.ar(600, 0, 0.1); });
  ~panner2 = ~panner_factory.value({
          var in;
          in = \in.ar(0);
          Pan2.ar(in, \pan.kr(-1););
  });
#+end_src

Connect the two and start the process
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~sounder2 <>> ~panner2;
  ~sounder <>> ~panner;
#+end_src

Send messages to the instance:
#+begin_src sclang :results none :tangle "test_factory.sc"
  ~panner.set(\pan, 1);
#+end_src

** accelerando, fixed tempo
This actually works in a weird way.
- Why are the beats sometimes doubled?

- Play with various tempi and distributions.

- Panning?

  Uses the original snare in this instance
  #+call: original_snare()

  Use these Pbinds: [[*pbind for accelerando][pbind for accelerando]]
  #+call: accelerando_accent()
  #+call: accelerando_accent_two()

  Main function:
  #+call: bar_stretching_acc()

  Prepare all fuinctions, then call either of the two functions below.
  #+begin_src sclang :results none :noweb yes :tangle acc.sc
    <<original_snare>>
    <<accelerando_accent>>
    <<accelerando_accent_two>>
    <<bar_stretching_acc>>
  #+end_src

Call the function
#+begin_src sclang :results none
  ~break_function.value(1.2, 1, ~accent);
#+end_src

Call two praces going in opposite tempo directions
#+begin_src sclang :results none
  (
  ~break_function.value(0.8, 32, ~accent);
  ~break_function.value(1.2, 1, ~accenti);
  )
#+end_src

Main routine that creates arrays of snare hits. For each bar the tempo is increased as well as the number of hits. The functions attempts to keep the length of the bar intact while raising the tempo.
#+name: bar_stretching_acc
#+begin_src sclang :results none :noweb yes :tangle yes
  ~beats_per_bar = 4;
  ~break_function = { arg mul=1, tpo=1, player=~accent;	
          var multiplier = mul; //the multiplier, lower than one for deaccelerando
          var tClock, beatsPB=2;
          var seq = { |length=4|
                  { |x=0| x+1; if(x==0, {1.0}, {rrand(0.1, 0.07)})} ! length;
          };

          tClock = TempoClock(tpo); //start time is 1
          player.play(quant: 0, clock: tClock);
          fork {
                  loop {
                          var barDur = 4; // Duration in seconds
                          var beatsPerBar = ~beatsPerBar;
                          tClock.tempo = tClock.tempo * multiplier;
                          "Tempo:".postln;
                          tClock.tempo.postln;
                          if((tClock.beatDur*(beatsPerBar+1)) < barDur,
                                  {
                                          var beatsToAdd = 1;
                                          "Length of bar + 1 beat".postln;
                                          (tClock.beatDur*(beatsPerBar+1)).postln;
                                          (
                                                  i = 1;
                                                  while( {(tClock.beatDur*(beatsPerBar+i)) < barDur }, {i = i+1; beatsToAdd = i});
                                          );
                                          beatsToAdd.postln;
                                          beatsPerBar = beatsPerBar + beatsToAdd;
                                          Pdefn(\accents, Pseq(seq.value(beatsPerBar), 1))
                                  },
                                  {
                                          "Length of bar".postln;
                                          (tClock.beatDur*beatsPerBar).postln;
                                          ((tClock.beatDur*beatsPerBar)/tClock.beatDur).postln
                                  });
                          (tClock.beatDur*beatsPerBar).wait;
                          player.play(quant: 0, clock: tClock);
                  }
          };
  }
#+end_src
   
Example: play one segment
#+begin_src sclang :results none
  var seq = { |length=4|
          { |x=0| x+1; if(x==0, {1.0}, {rrand(0.17, 0.3)})} ! length;
  };
  ~accent.play(quant: 0, clock: TempoClock(200));
  Pdefn(\accents, Pseq(seq.value(30), 1))
#+end_src

Example: Create a accent array and print it.
#+begin_src sclang :results none
  (
  var seq = { |length=4|
          { |x=0| x+1; if(x==0, {1.0}, {rrand(0.1, 0.2)})} ! length;
  };
  seq.value(4).postln;
  )
#+end_src
  
** poly rhythm
#+call: original_snare_two

#+begin_src sclang :results none
  ~task = { |init_tempo=10, nom=3, denom=4|
          ~clock = TempoClock(init_tempo);
          ~denom = Pbind(
                  \instrument, \snare,
                  \dur, denom,
                  \freq, Prand((5000..4000), inf),	
                  \noiseattack, 0.0001,	
                  \noiselvl, 0.01,
                  \noiserel, 0.0005,
                  \release, 0.001,
                  \gain, 2,
                  \osc1, 120,
                  \osc2, 200,	
                  \tri, 100,
                  \length, Prand((10..50)*0.01, inf),		
                  \out, 0,		
          ).trace;
          ~nom = Pbind(
                  \instrument, \snare,
                  \dur, nom,
                  \freq, Prand((5000..4000), inf),
                  \noiseattack, 0.0001,	
                  \noiselvl, 0.01,
                  \noiserel, 0.0005,	
                  \release, 0.001,
                  \gain, 2,
                  \osc1, 100,
                  \osc2, 200,	
                  \tri, 200,
                  \length, Prand((10..50)*0.01, inf),	
                  \out, 1,	
          );
          ~poly = Ppar([~nom, ~denom]).play(quant: 0, clock: ~clock);
  }
#+end_src

#+begin_src sclang :results none
  ~task.value(10, 7, 8);
#+end_src

#+begin_src sclang :results none
  ~clock.stop;
#+end_src
#+begin_src sclang :results none
  ~task.value;
  ~clock.stop;
  ~clock.tempo = 50;
  ~clock.tempo = 440;
  ~clock.beatsPerBar = 9
#+end_src

** harmony
*** harmonic spat synth
**** boot audio
#+begin_src sclang :results none :noweb yes
<<boot_jack>>;
#+end_src

**** simple synth
#+name: harmonic_synth
#+begin_src sclang :results none
  (
  SynthDef("test", { arg freq = 440, out = 10, amp = 0.2;
      Out.ar(out, SinOsc.ar(freq, 0, amp));
  }).add;
  )
#+end_src

Global variables and semaphhores
#+name: global_variables
#+begin_src sclang :results none
  ~logging = 2; /* The general level of loggging */
#+end_src

**** harmonics function
Initialize the arrays for freq/amp for the first 32 harmonics and create audio busses for each Synth that matches the sel array. Loads the synth [[*simple synth][harmonic_synth]].

- sel: Array of partials to play
- fund: Fundamental
- delta: time between notes (only init time)
#+name: harmonics
#+begin_src sclang :results none :noweb yes
  <<harmonic_synth>>;
  <<i_snare_phase_1>>;
  f = { arg fund=200, sel = [1,2,3], delta = 0.05, amp_mode = \full, synth_mode = \sin;

          var harmonics, amp, index = 0, noise_level = 0;

          /* Fill arrays for pitches */
          harmonics = Array.fill(32, { arg i; i*fund; });
          switch(amp_mode, 
                  \default, {amp = Array.fill(32, { arg i; 1/(i+1); }); },
                  /* All harmonics with the same amplitude */	
                  \full, {amp = Array.fill(32, { arg i; 0.3; });  },
                  \linear, {amp = Array.series(32, 1, -0.03125)},
                  \reverse, {amp = Array.series(32, 0.03125, 0.3125)}
          );	

          /* Map frequency to noise level */
          g = ControlSpec(0.1, 0.0, \linear, 0.001, 0);
          g.clipHi(0.1);  g.clipLo(0.0);

          /* Run the loop */
          t = Task({
                  (0..31).do({ |i|
                          var bus, synth;
                          if(i == sel[index],
                                  { 
                                          bus = Bus.audio(s, 1);
                                          ~audioBusses.add(bus);
                                          ~originalFrequencies.add(harmonics[i]);
                                          noise_level = g.map(harmonics[i] / 120);
                                          "Noise level: ".post; noise_level.postln;
                                          switch(synth_mode,
                                                  \sin, {			
                                                          synth = Synth("test", [\freq, harmonics[i], \amp, amp[i], \out, bus]);
                                                  },
                                                  \snare, {
                                                          synth = Synth.new("snare_phase", [\pulse, harmonics[i],
                                                                  \length, 1,
                                                                  \freq, harmonics[i]/10,
                                                                  \freq2, harmonics[i]/2,
                                                                  \trifreq, harmonics[i] /20,
                                                                  \nlevel, noise_level,
                                                                  \out, bus,
                                                                  \gain, amp[i]]);
                                                  }); //switch

                                          if(~logging > 0,
                                                  {			
                                                          Post << "Harmonic " <<< i << ": " <<< harmonics[i] <<  ", " <<< amp[i] << " at Audio bus " <<< bus.index << Char.nl;
                                                          index = index + 1; i.postln;
                                                  },
                                                  { }); //if
                                          ~synths.add( synth ); // synths.add

                                  }, //if true
                                  {  }); // false, end
                          delta.wait;
                  });
          });
          /* Return the task */
          t;
  };
#+end_src

#+begin_src sclang :results none :noweb yes
  <<free_busses>>
#+end_src
#+begin_src sclang :results none
Array.series(32, 1, -0.03125).postln;
#+end_src
**** generate harmonics
Initialize global variable ~~allRings~. Loads and calls the function defined in [[*harmonics function][harmonics function]] and plays it. The ~sel~ array defines the partials to be played. If this is three items long, the array of corresponding synths initatilzed in [[*harmonics function][harmonics function]] will be three.

After calling this, call [[*spatialisation][spatialisation]]: make_vbap to play the busses on the speakers.

- ~select~: The harmonics to play
- ~spat_positions~: The angles for each audio bus (needs to be of equal length to ~sel~)

_1. Load this_
#+name: generate_harmonics
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  (
  var select, spat_positions, task, mode = \full;
  <<global_variables>>
  <<all_rings>>
  <<harmonics>>

  switch(mode,
          \full, {
                  select = [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31];
                  spat_positions = [0,1,5,6,3,2,7,4,9,11,8,10,12,13,14];
          },
          \test, {
                  select = [3,5];
                  spat_positions = [0,1];
          }); // switch(mode
  if(~logging > 1,
          {
                  "Select array is ".post; select.size.postln;
                  "Spat array is ".post; spat_positions.size.postln; },
          { }); //if clause

  /* Holds the busses */
  ~audioBusses = Array.new(select.size);
  /* Holds the synths */
  ~synths = Array.new(select.size);
  /* Holds the original frequency for each bin */
  ~originalFrequencies = Array.new(select.size);
  ~spatializations = Array.new(spat_positions.size);

  if(select.size == spat_positions.size,
          {
                  if(~allRings.size >= spat_positions.size,
                          {	
                                  i = 0;	
                                  while( {i < spat_positions.size},
                                          { ~spatializations.add(~allRings[spat_positions[i]]);
                                                  if(~logging > 1,
                                                          { "Loading spat position ".post; i.post; ":".post; ~allRings[spat_positions[i]].postln; }, { }); // if clause
                                                  i = i + 1;
                                          }); // while clause
                          }, { }); // if clause
          },
          { "'sel' and 'spat' have unequal number of elements".postln; }); // if clause

  /* Call the harmonics function and play it.*/
  task = f.value(150, select, 0.1, \full, \snare);
  task.play;
  )
#+end_src

**** spatialisation
Spatialisation angles for three rings in triangles.
#+name: all_rings
#+begin_src sclang :results none :tangle harmony.sc
  ~allRings = [[-24.036688, 23.800417], [21.279257, 23.800417], [55.741675, 23.800417], [101.49442, 23.800417], [147.91193, 23.800417], [-167.82013, 23.800417], [ -123.784, 23.800417], [-79.887731, 23.800417], [ 0.247203, 56.476405], [69.013292, 56.476405], [158.89992, 56.476405], [-114.65354, 56.476405], [-90, 86.424489], [90, 86.424489], [0, 90]];
#+end_src

_1. Load this_
#+call: generate_harmonics()

_2. Load this_
Call this after running [[*generate harmonics][generate harmonics]] to start the spatialisation of the harmonics.
#+name: make_vbap
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  <<vbap_speaker_array>>

  ~spatChannels = Array.new(~audioBusses.size);
  ~spatNdefs = Array.new(~audioBusses.size);
  ~controlBus = Array.new(~audioBusses.size);
  ~audioBusses.do({ arg bus, i;
          m = "ch" ++ i.asString.asSymbol;
          n = Bus.control(s, 2);
          ~controlBus.add(n);
          ~spatNdefs.add(
                  Ndef.new(m, { arg azi = 0, ele = 0, spr = 0.1;
                          azi = In.kr(n);
                          ele = In.kr(n.index + 1);	
                          VBAP.ar(29, In.ar(bus), ~spkrBuffer.bufnum, In.kr(n), In.kr(n.index + 1), spr)}););
          Ndef(m).fadeTime(1);
          Ndef(m).play(addAction: \addToTail);
  });
  <<inter_pan>>
  <<update_panning>>
#+end_src

Control individual synths pulse.
#+begin_src sclang :results none
  ~synths[0].set(\freq, 10);
#+end_src

#+begin_src sclang :results none
  var changeAll = ~synths.do({ arg item, i;
          ~synths[i].set(\trifreq, 200);	
  });	
#+end_src
Gradually increase pulse speed in one synth.
#+begin_src sclang :results none
  var speeder;
  speeder = { arg instance = 0, range = (3..200), delta = 0.5, param = \pulse;
          var interpolate;
          interpolate = Task({
                  range.do({ arg index;
                          ~synths[1].set(param, index);
                          delta.wait;	
                  });
          });
          interpolate.play;
  };
  speeder.value(0, (150..5), 0.8, \pulse);
#+end_src

#+begin_src sclang :results none
  var ind = 1;
  ~synths[ind].set(\pulse, ~originalFrequencies[ind]);
#+end_src

#+begin_src sclang :results none
~originalFrequencies[0].postln;
#+end_src

Function for generating the lines for the panning modulation.
#+name: inter_pan
#+begin_src sclang :results none  :tangle harmony.sc
  ~interPan = { arg int, bus, astart, aend, estart, eend, dur;
          {Out.kr(bus.index, Line.kr(astart, aend, dur, doneAction: 2))}.play(addAction: \addToHead);
          {Out.kr(bus.index + 1, Line.kr(estart, eend, dur, doneAction: 2))}.play(addAction: \addToHead);
          if(~logging > 1,
                  {
                          "Azimuth from ".post; astart.post; " to ".post; aend.postln;
                          "Elevation from ".post; estart.post; " to ".post; eend.postln;
                  }, { });
  };
#+end_src

~update_panning~ is called to update panning positions in the ~spatNdefs~ arrays. The actual modulation happens in [[inter_pan][inter_pan]].
#+name: update_panning
#+begin_src sclang :results none :tangle harmony.sc
  ~updatePanning = { arg duration;
          ~spatNdefs.do({ arg channel, i;
                  ~interPan.value(i, ~controlBus[i],
                          ~controlBus[i].getnSynchronous(2)[0], ~spatializations[i][0],
                          ~controlBus[i].getnSynchronous(2)[1], ~spatializations[i][1], duration);
          });
  };
#+end_src

_3 Setting spatialization_
#+begin_src sclang :results none :noweb yes  :tangle harmony.sc
  <<spat_function>>
  <<update_panning>>
  ~setSpatPositions = { arg spat_array = [0, 1, 2];
          "spat size ".post;  ~spatializations.size.postln;
          ~spatializations.do({ arg item, i;
                  ~spatializations.put(i, ~allRings.wrapAt(spat_array.wrapAt(i)));       
                  if(~logging > 1,
                          {
                                  "Set panning:".postln;
                                  "Putting ".post;  spat_array.wrapAt(i).post; " at index ".post; i.postln;
                          }, { }); // if logging
          }); // spatialilzation.do
          ~updatePanning.value(10);
  };
#+end_src

Change spatialization. Spat is controlled by an arbitrary length array that points to one of the 14 (0-13) speaker positions available. Use the ~spat_function~ to create new presets.
#+begin_src sclang :results none
~setSpatialization.value(\random, 1);
#+end_src

#+name: spat_function
#+begin_src sclang :results none
  ~setSpatialization = { arg preset, time;
      switch(preset,
		\simple, { ~setSpatPositions.value([3,4]); },
                  \frontTop, { ~setSpatPositions.value([13, 12 ,13, 12,13,12,13,12,8,9,8,9,8,9]); },
                  \back, { ~setSpatPositions.value([6,5,4,3,3,4,5,6,11,10,11,10,11,10,11]); },
                  \allInOne, { ~setSpatPositions.value(Array.fill(15, { arg i; 1; })); },
                  \random, { ~setSpatPositions.value(Array.rand(~spatializations.size, 0, 14)); });
  };
#+end_src
#+begin_src sclang :results none
~allRings.size.postln;
#+end_src
_4. Free all_
Free all busses and stop execution
#+begin_src sclang :results none :noweb yes
  <<free_busses>>
  CmdPeriod.run;
#+end_src

--------------------------------

Reboot Supercollider
#+begin_src sclang :results none
s.reboot;
#+end_src
#+begin_src sclang :results none
  s.meter;
#+end_src
#+begin_src sclang :results none
  s.plotTree
#+end_src
#+begin_src sclang :results none
~audioBusses[1].scope;
#+end_src
***** spkrBuffer settings
The argument to ~VBAPSpeakerarray~ is ~3~ for 3D and an array of arrays of angle/elevation pairs:
#+name: vbap_speaker_array
#+begin_src sclang :results none :tangle harmony.sc
  ~spkrArray = VBAPSpeakerArray.new(3, [[ -34.689614 , 12.910417 ], [ -13.383763 , 12.910417 ], [ 10.440725 , 12.910417 ], [ 32.117788 , 12.910417 ],
          [ 55.741675 , 12.910417 ], [ 78.207673 , 12.910417 ], [ 101.49442 , 12.910417 ], [ 124.85167 , 12.910417 ],
          [ 147.91193 , 12.910417 ], [ 169.17789 , 12.910417 ], [ -167.82013 , 12.910417 ], [ -145.63454 , 12.910417 ],
          [ -123.784 , 12.910417 ], [ -102.64182 , 12.910417 ], [ -79.887731 , 12.910417 ], [ -57.926139 , 12.910417 ],
          [ -22.349553 , 34.696822 ], [ 22.843958 , 34.696822 ], [ 69.013292 , 34.696822 ], [ 115.56544 , 34.696822 ],
          [ 158.89992 , 34.696822 ], [ -158.89763 , 34.696822 ], [ -114.65354 , 34.696822 ], [ -68.170128 , 34.696822 ],
          [ -45 , 69.185799 ], [ 45 , 69.185799 ], [ 135 , 69.185799 ], [ -135 , 69.185799 ], [ 0 , 90 ]]);
  ~spkrArray.speakers[1].dump;
  ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
#+end_src

***** test with Synthdef
#+begin_src sclang :results none
Synth.new(\vbap_panning, [\bus, ~audioBusses[0], \spkr_buffer, ~spkrBuffer.bufnum, \azimuth, 0, \elevation, 0, \spread, 0], addAction: \addToTail);
#+end_src

#+begin_src sclang :results none
  SynthDef(\vbap_panning, { var input, snd, bus;
          bus = \bus.kr;
          input = In.ar(bus);
          snd = VBAP.ar(29,
                  input,
                  \spkr_buffer.ir,
                  \azimuth.kr(0),
                  \elevation.kr(0),
                  \spread.kr(0));
          Out.ar(0, snd);
  }).add;
#+end_src

**** free busses
#+name: free_busses
#+begin_src sclang :results none
  ~freeAllBusses = {
          var int = 0;
          if(~audioBusses.size == 0,
                  { "Array is empty".postln },
                  {
                          while({ int < ~audioBusses.size }, {
                                  if(~audioBusses[int].index == nil,
                                          { "Bus cleared already".postln; },
                                          {		
                                                  "Clearing bus ".post; ~audioBusses[int].index.postln;
                                                  ~audioBusses[int].free;
                                                  ~controlBus[int].free;
                                                  ~synths[int].free;			
                                          });		
                                  int = int + 1;
                          });
                  })
  };
  ~freeAllBusses.value();

  ~freeNdefs = {
          Ndef.clear(0);
  };
  ~freeNdefs.value();
#+end_src
**** alternative stuff
Interpolate over pan values by means of Task
#+name: interpolator
#+begin_src sclang :results none 
  ~interpolator = { arg instance = 0, range = (0..180), delta = 0.05, param = \azi;
          var interpolate;
          interpolate = Task({
                  range.do({ arg index;
                          p = index;
                          ~spatNdefs[instance].set(param, p);
                          delta.wait;	
                  });
          });
          interpolate;
  };
#+end_src

Set all channels' panning positions using the Task above.
#+begin_src sclang :results none
  ~spatNdefs.do({ arg channel, i;
          var ae, as, es = 0, ee = 1;
          as = channel.get(\azi);
          es = channel.get(\ele);
          ae = ~spatializations[i][0];
          ~interpolator.value(i, (as..ae), 0.1, \azi).play;
          ~interpolator.value(i, (es..ee), 0.1, \ele).play;
          //          "Angles are set to ".post; ae.postln;
          channel.set(\ele, ~spatializations[i][1]);
  });
#+end_src

Example calls for the ~~interpolator~ function.
#+begin_src sclang :results none
  q = ~interpolator.value(0, (0..180), 0.1).play;
  p = ~interpolator.value(1, (180..0), 0.1).play;
#+end_src

Not sure what this is.
#+begin_src sclang :results none :noweb yes
  var delta = 0.5;
  Task({
          (1..64).do({ arg index;
                  var spat_positions =  Array.rand(12, 0, 13);
                  ~spatializations.do({ arg item, i;
                          ~spatializations.put(i, ~allRings[spat_positions[i]]);
                          "Putting ".post;  spat_positions[i].post; " at index ".post; i.postln;
                  });
                  ~spatChannels.do({ arg channel, i;
                          channel.set(\ele, ~spatializations[i][0], \ele, ~spatializations[i][1]);
                  });
                  delta.wait;	
          });
  }).play;
#+end_src


** osc
*** set netaddress to 'b'
#+name: set_netaddress
#+begin_src sclang :results none
  b = NetAddr.new("127.0.0.1", 5510);
#+end_src
*** routine to play 10 hits
#+begin_src sclang :results none :noweb yes
  <<set_netaddress()>>
  // the value can also be a stream or a function
  (
  r = Routine {
      10.do( { 
                  b.sendMsg("/o_dispersed_snare/impulse/play", 1);
                  0.01.wait;
                  b.sendMsg("/o_dispersed_snare/impulse/play", 0);
                  0.1.wait;
      });
  }.play;
  );
#+end_src
*** task in loop
#+begin_src sclang :results none
  b = NetAddr.new("127.0.0.1", 5510);
  t = Task({ { 
      b.sendMsg("/o_dispersed_snare/impulse/play", 1);
      0.01.wait;
      b.sendMsg("/o_dispersed_snare/impulse/play", 0);
      1.wait;
  }.loop });
  t.start;
#+end_src
#+begin_src sclang :results none
  t.stop;
#+end_src
*** pbind for osc
Sending OSC messages from a Pbind.
#+begin_src sclang :results none
  (
  ~play = Pbind(
      \dur, 1,
      \odur, Pfunc {|ev| b.sendMsg("/o_dispersed_snare/impulse/play", 1)},
      \sdur, Pfunc {|ev| b.sendMsg("//o_dispersed_snare/impulse/play", 0)}
  ));

  ~play.play;
#+end_src
*** definition of ~play
This is made to deal with the faust 'gate' not resetting itself.
Set the netaddress and register the routine.
#+name: set_play
#+begin_src sclang :results none
  (
  ~play = {
      1.do{
                  b.sendMsg("/o_dispersed_snare/impulse/play", 1);
                  0.01.wait;
                  b.sendMsg("/o_dispersed_snare/impulse/play", 0);
      }
  }
  )
#+end_src
Play the routine above:
#+begin_src sclang :results none
  ~play.fork
#+end_src
#+name: set_play_dep
#+begin_src shell :results none :noweb yes
  <<set_netaddress()>>
  <<set_play()>>
#+end_src
*** play routine 1
Depends on [[*deal with faust 'gate'][deal with faust 'gate']]
#+begin_src sclang :results none
  (
  r = Routine {
      0.5.idle(2);
      0.25.idle(2);
      0.125.idle(2);
      0.0625.idle(2);
  };
  fork {
      loop {
                  var rest = r.value;
                  rest.postln;
                  ~play.fork;
                  rest.wait;
      }
  }
  );
#+end_src
*** play routine 2
Parameters are:
1. a scaling factor (default to one)
2. the number of notes to play.
   Depends on the definition of ~~play~      
   #+begin_src sclang :results none :noweb yes
     <<set_play()>>
     <<p_random_rhythm_rout()>>
     <<p_random_rhythm()>>
   #+end_src
   #+name: p_random_rhythm_rout
   #+begin_src sclang :results none :noweb yes
     (
     l = Routine { arg in=1, reps=10;
         var length = 1;
         p = Prand([0.5, 0.25, 0.125, 1], inf);
         q = p.asStream;
         50.do { |i=0|
                     q.next.postln;
                     length = q.next * in;
                     b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [200, 300, 400].choose);
                     b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [210, 320, 440].choose);
                     ~play.fork;
                     q.next.wait;
         }
     }
     )
   #+end_src
   #+name: p_random_rhythm 
   #+begin_src sclang :results none
     l.play.value(1, 100);
   #+end_src
*** play routine 3
#+begin_src sclang :results none
  (
  var osc1freq = Array.fill(10, { (100.rand*2)+100 });
  ~playme = Pbind(
      \dur, Prand([0.1, 0.15, 0.05, 0.2, 0.25, 0.3], inf),
      \play, Pfunc({[~play.fork, ~play.fork]}),
      \osc1f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_1_freq", [ 190, 174, 178, 204, 138, 218, 232, 222, 276, 158 ].choose)}),
      \osc2f, Pfunc({b.sendMsg("/o_dispersed_snare/snare/osc_2_freq", [200, 300, 400, 500, 450, 350, 250, 150].choose)}),
      \noise_rel, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_rel", 0.1.linrand + 0.012 )}),
      \noise_lvl, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_lvl", 0.5.linrand + 0.012 )}),
      \noise_attack, Pfunc({b.sendMsg("/o_dispersed_snare/snare/noise_attack", 0.1.linrand )}),
  ).play;
  )
#+end_src

*** play routine 4
#+begin_src sclang :results none
  (
  var durs = Array.new(64);
  a = (1!4);
  b = (0.5!8);
  c = (0.25!16);
  d = (0.125!32);
  durs = a ++ b;
  durs = durs ++ c;
  durs = durs ++ d;
  ~playme = Pbind(
      \dur, Pseq(durs, inf),
      \play, Pn(Pfunc({~play.fork}), inf)
  ).play;
  )
#+end_src
** archive
Synth that is driven by an Impulse pulse generator.
Load first the two SynthDefs below and use a global variable of ~isnare for the snare synth:
#+begin_src sclang :results none
  (
  // Here is where the bus object is created in a global variable:
  ~controlBus_1 = Bus.control(s, 1);
  SynthDef(\isnare, { | outBus=0, inBus=0, cBus1=1, gain=0.5, freq=200, osc1=330, osc2=180, tri=111, noise=0.1, position=0, disperse=0 |
      var snd;
      var trig = In.ar(~impBus.index, 1);
      snd = IDispersedSnare.ar(trig, position, disperse, osc_1_freq: osc1, osc_2_freq: osc2, triangle_freq: tri) * gain;
      Out.ar(outBus, snd);
  }).add;

  SynthDef(\impulseA, { | effectBus=0, freq=1 |
      var outB;
      // Only to automatically free each instance
      var env = EnvGen.kr(Env.perc, doneAction: Done.freeSelf);
      outB = Impulse.ar(freq);
      Out.ar(~impBus.index, outB);
  }).add;

  SynthDef(\control_synth, { | bus |
      Out.kr(bus, SinOsc.kr(2, 0, 1, 1));
  }).send(s);
  )
#+end_src

... and then instantiate the main synth:
#+name: isnare_load
#+begin_src sclang :results none
  ~sisnare = Synth.new("isnare", [\cBus, ~controlBus_1.index, \disperse, 0] );
#+end_src

Play one single shot:
#+begin_src sclang :results none
  ~impulse = Synth.before(~sisnare, "impulseA", [\freq, 0]);
  ~c_synth = Synth.before(~sisnare, "control_synth", [\bus, ~controlBus_1.index]);
  //s.meter;
#+end_src

Set parameters
#+begin_src sclang :results none
  ~impulse.set(\freq, 0);
  ~sisnare.set(\position, {In.kr(~controlBus_1.index)});
#+end_src

*** routine loop
#+begin_src sclang :results none
  (
  r = Routine({
      var delta = 0;
      loop {
                  delta = delta + 1;
                  "Will wait ".post; delta.postln;
                  0.5.yield;
      }
  });
  )
#+end_src
#+begin_src sclang :results none
  r.next;

  TempoClock.default.sched(0, r);
#+end_src
#+begin_src sclang :results none
  r.stop;
#+end_src

    


    


           
