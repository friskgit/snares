#+STARTUP: indent overview hidestars
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

* TODO Things to do
- [ ] Implement distance in panning with reverb
- [ ] Glue \nlevel to \pulse
* Settings comments
** Full slow texture
Starting the \harmonics mode with \full amplitude setting, ~~fundamental~ at 0.2 and default panning is very nice. Run
#+begin_src sclang :results none
~~interpolatePulse.value(~modulateSpeed.value(10, 40, 3, \linear));~ 
#+end_src
twice and then ~~pulsePresets.value(6);~ in <<pulse_resets>> 
* General comments
Spatialisation sectors in VBAP based on the triangles created by the speakers. In the picture an example of how the partials (speeds) can be distributed in space.
#+DOWNLOADED: file:///home/henrikfr/Downloads/DSC_1207.JPG @ 2021-10-07 14:38:38
#+ATTR_HTML: :width 400
[[file:org/images/General_comments/2021-10-07_14-38-38_DSC_1207.JPG]]

Ratios are plotted against the possible positions in space. See also [[https://en.wikipedia.org/wiki/Just_intonation][the section on pythogorean tuning.]]
#+DOWNLOADED: file:///home/henrikfr/Downloads/DSC_1208.JPG @ 2021-10-07 14:38:43
#+ATTR_HTML: :width 400
[[file:org/images/General_comments/2021-10-07_14-38-43_DSC_1208.JPG]]

* harmonic spat synth
_1. Start here_
Set the parameters in [[generate_harmonics][generate_harmonics]] for the synthesis.

#+call: boot_jack()
#+call: global_variables()
#+call: generate_harmonics()
#+call: make_vbap()
#+call: ambi_connect()
#+call: init_spatialization()
#+call: load_reverb()
#+call: show_meter()
#+call: free_all()
#+call: reboot()

** boot audio
Set JackRouter to be the interface on Linux
#+name: boot_jack
#+begin_src sclang :results none
  (
  o = Server.local.options; // Get the local server's options
  o.numOutputBusChannels = 64;
  o.numWireBufs = 128;
  o.memSize  = (65536 * 4);
  //     s.makeWindow;
  s.makeGui(p);
  s.boot;
  )
#+end_src

** global variables
Global variables and semaphhores

- ~~fundamental~  The fundamental pitch from which harmonics are built
- ~~alllRings~  General XY positions of the centerrs of the triangles.
- ~~spatializations~  List of the positions for each ~~audioBus~ that may be updated.
- ~~spatChannels~ Array of Ndefs, channels of VBAP panners  (same size as ~audioBusses~
- ~~spatNdefs~ 
- ~~controlBus~ 
- ~~frequencyBus~  The bus through which the frequency of the impulse is controlled (the \pulse)
- ~~audioBusses~ The channels that outputs audio from the synth.
- ~~spatPositions~ An array of initial spat positions, identified by a reference to the ~allRings~ array.
- ~~mode~ The mode of the synthesis:
  - \harmony
  - \odd
  - \single
  - \quart 
  - \dual
  - \rhythm
- ~~ampMode~ The amplitude setting of the partials
  - \full
  - \linear
  - \reverse
- ~~synthMode~
  - \sin
  - \break
  - \snare
#+name: global_variables
#+begin_src sclang :results none
  /* Which space? */
  ~space = 0;
  /* Fundamental frequency */
  ~fundamental = 294.3;
  //  ~fundamental = 261.1;
  /* Mode of synthesis */
  ~mode = \full;
  /* Amplitude mode */
  ~ampMode = \reverse;
  ~baseAmplitude = 0.4;
  /* The general level of loggging */
  ~logging = 2;
  /* The synthesis mode \sin, \break, \snare */
  ~synthMode = \synth;


  /* Spatialisation positions */
  ~allRings = [[335.963312, 23.800417, 1.0, 0.0], [21.279257, 23.800417, 1.0, 0.0], [55.741675, 23.800417, 1.0, 0.0], [101.49442, 23.800417, 1.0, 0.0], [147.91193, 23.800417, 1.0, 0.0], [192.17987, 23.800417, 1.0, 0.0], [ 236.216, 23.800417, 1.0, 0.0], [280.112269, 23.800417, 1.0, 0.0], [ 0.247203, 56.476405, 1.0, 0.0], [69.013292, 56.476405, 1.0, 0.0], [158.89992, 56.476405, 1.0, 0.0], [245.34646, 56.476405, 1.0, 0.0], [270, 86.424489, 1.0, 0.0], [90, 86.424489, 1.0, 0.0], [0, 90, 1.0, 0.0]];

  /* Harmonic spatialisation settings */
  ~scaleSpats = [[0.0, 0, 1.0, 0.0], [6.45, 0, 1.0, 0.0], [12.32, 0, 1.0, 0.0], [39.97, 0, 1.0, 0.0], [61.17, 0, 1.0, 0.0], [115.89, 0, 1.0, 0.0], [122.35, 0, 1.0, 0.0], [204.13, 0, 1.0, 0.0], [210.59, 0, 1.0, 0.0], [298.83, 0, 1.0, 0.0], [326.48, 0, 1.0, 0.0]];

  ~scaleIndexes = [1.0, 1.0125, 1.024, 1.08, 1.125, 1.25, 1.2656, 1.4815, 1.5, 1.7778, 1.875, 2.0 ];

  ~pitches = [261.6, 264.87, 267.87844, 282.52807, 294.3, 326.99987, 331.0875, 387.5554, 392.4, 465.06667, 490.50036, 523.2, ];

  /* setup ambisonics */
  ~order = 3;
  ~hoaNumChannels = (~order+1).pow(2);
  ~decoderNumChannels = 29;  

  /* Separator */
  ~separator = "-----------------------------------";
  "Global variables loaded.".postln;
  ~separator.postln;

  ~setRunningVariables = { |fund=2, mode=\harmony, ampMode=\default, synthMode=\snare, scaleIndex, bAmp=0.3|

    ~fundamental = fund; 
    ~mode = mode;
    ~ampMode = ampMode;
    ~synthMode = synthMode;
    ~scaleIndex = scaleIndex;
    ~baseAmplitude = bAmp;
    "Preset loaded".postln;
    "Fundamental is ".post; ~fundamental.postln;
    "Mode is ".post; ~mode.postln;
    "Amplitude mode is ".post; ~ampMode.postln;
    "Synth is ".post; ~synthMode.postln;
    "Base amplitude is ".post; ~baseAmplitude.postln;
  };
#+end_src

#+begin_src sclang :results none
  ~allRings.size.postln;
  ~scaleSpats.size.postln;
#+end_src

*** spkrBuffer settings
 The argument to ~VBAPSpeakerarray~ is ~3~ for 3D and an array of arrays of angle/elevation pairs:
 #+name: vbap_speaker_array
 #+begin_src sclang :results none :tangle harmony.sc
   if(~space == 0,
     {
           /* Lilla salen */
           "Loading Lilla salen".postln;
           ~spkrArray = VBAPSpeakerArray.new(3, [[ -34.689614 , 12.910417 ], [ -13.383763 , 12.910417 ], [ 10.440725 , 12.910417 ], [ 32.117788 , 12.910417 ],
             [ 55.741675 , 12.910417 ], [ 78.207673 , 12.910417 ], [ 101.49442 , 12.910417 ], [ 124.85167 , 12.910417 ],
             [ 147.91193 , 12.910417 ], [ 169.17789 , 12.910417 ], [ -167.82013 , 12.910417 ], [ -145.63454 , 12.910417 ],
             [ -123.784 , 12.910417 ], [ -102.64182 , 12.910417 ], [ -79.887731 , 12.910417 ], [ -57.926139 , 12.910417 ],
             [ -22.349553 , 34.696822 ], [ 22.843958 , 34.696822 ], [ 69.013292 , 34.696822 ], [ 115.56544 , 34.696822 ],
             [ 158.89992 , 34.696822 ], [ -158.89763 , 34.696822 ], [ -114.65354 , 34.696822 ], [ -68.170128 , 34.696822 ],
             [ -45 , 69.185799 ], [ 45 , 69.185799 ], [ 135 , 69.185799 ], [ -135 , 69.185799 ], [ 0 , 90 ]]);
           ~spkrArray.speakers[1].dump;
           ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
     },
     {
           /* 1D114 */
           "Loading 1D114".postln;
           ~spkArray = VBAPSpeakerArray.new(3, [[24.6, 0], [ 0, 0], [-26.34, 0], [-58.7, 0], [-106, 0], [-129.35, 0], [129.35, 0], [106, 0], [58.7, 0], [45, 18], [-45, 18], [-135, 18], [135, 18], [0, 90]]);
           ~spkArray.speakers[1].dump;
           ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
     });
 #+end_src
 
** presets
Set the runtime values for the parameters:
- fundamental
- mode of synthesis
- ampMode
- synthMode
- base amplitude
#+begin_src sclang :results none
  ~setRunningVariables.value(300, \dual, \full, \snare);
#+end_src
#+begin_src sclang :results none :noweb yes
  ~setRunningVariables.value(800, \harmony, \linear, \snare);
  //  <<synth_release_harmony>>
#+end_src
First iteration of breakBeat
#+begin_src sclang :results none
  ~currentIndex = 11;
  ~setRunningVariables.value(1, \rhythm, \full, \break, [~currentIndex], 0.5);
#+end_src

#+begin_src sclang :results none :noweb yes
  <<start_double()>>
#+end_src
#+begin_src sclang :results none
  ~doubleRoutine.stop;
#+end_src
#+begin_src sclang :results none
  ~setSpatPositions.value([ [~currentIndex, 1, 10 ] ], 1, 0);
#+end_src
#+begin_src sclang :results none
  ~setSpatPositions.value([ [1, 0, 10 ] ], 1);
#+end_src
#+begin_src sclang :results none
  ~setSpatPositions.value([ [~currentIndex, 1, 50 ] ], 90, 10);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((100..260), 0.5, \freq);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((110..331), 0.5, \freq2);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((100..10), 20, \trifrq);
#+end_src

#+begin_src sclang :results none
  ~setAllSynths.value(\freq, 282.52807);
#+end_src

#+begin_src sclang :results none
  ~setAllSynths.value(\noiseScale, 0.4);
#+end_src
** synth
#+name: harmonic_synth
#+begin_src sclang :results none
  SynthDef("test", { arg freq = 440, out = 10, amp = 0.2;
    Out.ar(out, SinOsc.ar(freq, 0, amp));
  }).add;
#+end_src

Main snare synth. The pulse parameter is controlled by the ~pulse_bus~
#+name: snare_phase_multi
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\p_snare, { arg pulse_bus;
    var snd,
    pulse = \pulse.kr(10),
    frq1 = \freq.kr(300),
    frq2 = \freq2.kr(300),
    trifreq = pulse * 3,
    nlevel = LinLin.kr(pulse / 120, 0, 1, 0.1, 0.001) * \noiseScale.kr(0.0);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), nlevel, \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), trifreq);
    Out.ar(31, snd * \gain.kr(0.5));
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add;
#+end_src

#+begin_src sclang :results none
  b = Bus.control(s,1).set(10);
  c = Synth.new(\p_snare, [\freq, [40, 100]]);
  c.map(\pulse, b);
  b.set(10);
  b.get.postln;
#+end_src

#+begin_src sclang :results none
~synths[0].set(\freq2, 282.52807);
#+end_src

#+begin_src sclang :results none
//  ~synths[0].set(\pulse, 10);
//  ~synths[0].set(\trifrq, 20);
  ~synths[0].set(\rel, 0.001);
  ~synths.size.postln;
#+end_src

#+name: break_snare
#+begin_src sclang :results none
  ~snare_simple = SynthDef(\breakSnare, {
    var snd;
    var env = Env([0, 1, 0], [0.000001, \length.ir(0.5)], \sine);
    var imp = Impulse.ar(\pulse.kr(1), 0.0, 0.5, 0);
    var frq1 = \freq.kr(300);
    var frq2 = \freq2.kr(200);
    snd = OGenericSnarefs.ar(imp, 0.00001, 0.001, \noiseScale.kr(0.1), \nrel.ir(0.1), frq1, frq2, \rel.ir(0.1), \trifrq.kr(111)) * EnvGen.kr(env, doneAction: Done.freeSelf);
    Out.ar(31, snd * 0.5);
    Out.ar(\out.ir(0), snd * \gain.ir(1)*1.5);
  }).add;
#+end_src

#+begin_src sclang :results none
  Synth.new(\breakSnare, [
    \pulse, 1,
    \freq, 100,
    \freq2, 200,
    \trifrq, 50,
    \noiseScale, 0.1,
    \length, 10,
    \rel, 0.1,
    \nrel, 0.04,
    \out, 0,
    \gain, 0.5]);
#+end_src
** harmonics function
Initialize the arrays for freq/amp for the first 32 harmonics and create audio busses for each item in the sel array. Loads the synth [[*simple synth][harmonic_synth]] and [[snare_phase_multi][snare_phase_multi]]. Select the synth by setting ~~synthMode~.

- ~fund~: Fundamental
- ~sel~: Array of partials to play
- ~delta~: time between notes (only init time)
- ~ampMode~: the relation between the amplitude of the notes in the array (~\default~, ~\full~, ~\linear~ or ~\reverse~)
- ~synthMode~: the synthesis model (~\sin~ or ~\snare~)

Variables:
- ~harmonics~ An array of harmonic frequencies
- ~amp~
- ~fbus~
- ~nmap~

Called by [[*generate harmonics][generate harmonics]].
#+name: harmonics
#+begin_src sclang :results none :noweb yes
  <<harmonic_synth>>
  <<snare_phase_multi>>
  <<break_snare>>

  /* Function called by generate_harmonics */
  ~harmonicsFactory = { arg fund=200,
    sel = [1,2,3],
    delta = 0.05,
    ampMode = \full,
    synthMode = ~synthMode,
    ampScale = 2;

    var harmonics, amp, index = 0, fbus, nmap;
    var bFrq1, bFrq2, bFade, bNoise, bLength, bRelease, breakSynthSettings = \default;

    "Fundamental is ".post; fund.postln;
    "Sel is ".post; sel.postln;
    /* Fill arrays for pitches */
    harmonics = Array.fill(32, { arg i; (i)*fund; });
    harmonics.postln;
    /* Fill arrays for amplitudes */
    switch(ampMode,
          \default, {amp = Array.fill(32, { arg i; 1/(i+1) * ampScale; }); },
          /* All harmonics with the same amplitude */	
          \full, {amp = Array.fill(32, { arg i; 1 * ampScale; });  },
          /* Linear amplitudes (1 / 32 * amp) */
          \linear, {amp = Array.series(32, 1 * ampScale, -0.03125)},
          /* Linear amplitudes reversed (highest pitch has max amplitude) */
          \reverse, {amp = Array.series(32, 0.03125 * ampScale, 0.3125)}
    );

    switch(breakSynthSettings,
          \default, {bFade = 10; bNoise = 0.005;
            bLength = 120; bRelease = 0.06;
            bFrq1 = 200; bFrq2 = 300; },
          \noNoise, {bFade = 1; bNoise = 0.0;
            bLength = 60; bRelease = 0.06;
            bFrq1 = 50; bFrq2 = 100; },
          \bHarmony, {bFade = 5; bNoise = 0.0;
            bLength = 10; bRelease = 0.02;
            bFrq1 = harmonics[sel[0]]/2; bFrq2 = harmonics[sel[0]] });

    " ".postln;
    "Amp array is loaded: ".postln;
    amp.postln;
    " ".postln;
    "Harmonics are loaded:".postln;
    harmonics.postln;
    "".postln;
    ~separator.value.postln;

    /* Frequency (pulse) control using a Bus */
    ~frequencyBus = Array.new(sel.size);

    /* Run the loop */
    t = Task({
          (0..31).do({ |i|
            var audioBus, synth;
            if(i == sel[index],
                  {
                    "i value is ".post; i.postln;
                    /* audio bus for output */		
                    audioBus = Bus.audio(s, 1);
                    ~audioBusses.add(audioBus);

                    /* Control bus for freq control */
                    fbus = Bus.control(s, 1);
                    fbus.value(harmonics[i]);		
                    ~frequencyBus.add(fbus);
                    ~frequencyBus[i].set(harmonics[i]);    
                    ~originalFrequencies.add(harmonics[i]);
                    "pulse: ".post; harmonics[i].postln;

                    ~separator.value.postln;    
                    "".postln;
                    "This is the synth ".post; synthMode.postln;		  
                    switch(synthMode,
                          \sin, {			
                            synth = Synth("test", [\pulse, harmonics[i], \amp, amp[i], \out, audioBus]);
                          },
                          \break, {
                            synth = Synth.new(\breakSnare, [
                                  \pulse, ~scaleIndexes[~spatPositions[0]],
                                  \freq, bFrq1,
                                  \freq2, bFrq2,
                                  \trifrq, 50,
                                  \noiseScale, bNoise,
                                  \length, bLength,
                                  \rel, bRelease,
                                  \nrel, 0.04,
                                  \out, audioBus,
                                  \gain, amp[i]]);				
                          },
                          \snare, {
                            synth = Synth.new(\p_snare, [
                                  \bus, fbus,
                                  \pulse, harmonics[i],
                                  \length, 1,
                                  \rel, 0.05,				
                                  \freq, harmonics[i]/2,
                                  \freq2, harmonics[i]/3,
                                  \trifreq, harmonics[i]/4,
                                  \noiseScale, 0.1,
                                  \out, audioBus,
                                  \gain, amp[i]]);
                            synth.map(\pulse, fbus);
                          }); //switch

                    if(~logging > 0,
                          {			
                            Post << "Harmonic " <<< i << ": " <<< harmonics[i] <<  ", " <<< amp[i] << " at Audio bus " << audioBus.index << Char.nl;
                            index = index + 1; i.postln;
                            ~separator.value.postln;    
                          },
                          { }); //if
                    ~synths.add( synth ); // synths.add
                    "synth size: ".post; ~synths.size.postln; "-----------------".postln
                  }, //if true
                  {  }); // false, end
            delta.wait;
          });
    });
    /* Return the task */
    t;
  };
#+end_src
End of harmonics.

#+begin_src sclang :results none
  ~synths.size.postln;
  ~synths[0].get(\freq2, { arg value; ("freq is now:" + value + "Hz").postln; });
#+end_src

Unused function to map frequency to noise level
#+name: noise_map
#+begin_src sclang :results none
  ~noiseMap = { arg val;
	 ~noiseMapSpec.map(val / 120).postln
  };
  ~noiseMap.value(119);
#+end_src

ControlSpec for the mapping between frequency and noise level
#+name: noise_mapping_spec
#+begin_src sclang :results none
  ~noiseMapSpec = ControlSpec(0.1, 0.0, \linear, 0.001, 0);
  ~noiseMapSpec.clipHi(0.1);
  ~noiseMapSpec.clipLo(0);
#+end_src

** reverb
Load reverb
#+name: load_reverb
#+begin_src sclang :results none :noweb yes
  <<reverb_ndef>>
  <<reverb_specs>>
  <<reverb_panning>>
  <<connect_reverb>>
#+end_src

#+name: reverb_specs
#+begin_src sclang :results none
  Spec.add(\t60, [0.1, 60, \exp]);
  Spec.add(\damp, [0, 1]);
  Spec.add(\size, [0.5, 3]);
  Spec.add(\earlydiff, [0, 1]);
  Spec.add(\mdepth, [0, 50]);
  Spec.add(\mfreq, [0, 10]);
  Spec.add(\lowx, [0, 1]);
  Spec.add(\midx, [0, 1]);
  Spec.add(\highx, [0, 1]);
  Spec.add(\lowband, [100, 6000, \exp]);
  Spec.add(\highband, [1000, 10000, \exp]);
#+end_src

Load the reverb
#+name: reverb_ndef
#+begin_src sclang :results none
  Ndef(\reverb, {
    var src = In.ar(~reverbSendBus.index) * \amp.kr(1);
    src = JPverb.ar(    
      src,
      \t60.kr(1, 0.05),
      \damp.kr(0,0.05),
      \size.kr(1,0.05),
      \earlydiff.kr(0.707, 0.05),
      \mdepth.kr(5,   0.05),
      \mfreq.kr(2,    0.05),
      \lowx.kr(1,0.05),
      \midx.kr(1,0.05),
      \highx.kr(1,    0.05),
      \lowband.kr(500,0.05),
      \highband.kr(2000,   0.05)
    );
  });
#+end_src

Reset the two example Ndefs
#+begin_src sclang :results none
  Ndef(\reverb).clear;
  Ndef(\reverbPanning).clear;
#+end_src

#+name: reverb_panning
#+begin_src sclang :results none
  Ndef(\reverbPanning, {
	 var src = \input.ar;
	 PanX.ar(16, src, \revPanPos.kr(0), \revPanAmp.kr(1), \revPanSpread.kr(64));
  }).mold(16);
#+end_src

Connect the source to the reverb.
#+name: connect_reverb
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 1;
  Ndef(\reverbPanning).play(addAction: \addToTail);
  Ndef(\reverbPanning) <<>.input Ndef(\reverb);
  Ndef(\reverb).set(\t60, 0.7);
  Ndef(\reverb).set(\size, 0.2);
  Ndef(\reverb).set(\amp, 1);
  Ndef(\reverb).set(\earlydiff, 0.1);
  Ndef(\reverb).set(\mdepth, 1);
  Ndef(\reverbPanning).set(\revPanSpread, 64);
#+end_src

#+begin_src sclang :results none
  Ndef(\reverb).set(\t60, 0.5);
  Ndef(\reverb).set(\size, 0.5);
  Ndef(\reverb).set(\amp, 1);
  Ndef(\reverb).set(\earlydiff, 0.5);
  Ndef(\reverb).set(\mdepth, 1);
#+end_src

Start the two Ndefs (and stop)
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 5;
  Ndef(\reverbPanning).play;
  Ndef(\reverbPanning).stop;
  Ndef(\reverb).play;
  Ndef(\reverb).stop;
  Ndef(\reverbBus).play;
  Ndef(\reverbBus).stop;
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).set(\revPanSpread, 67);
  Ndef(\reverbPanning).set(\revPanAmp, 0.0);
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).scope;
#+end_src

** generate harmonics                                               :export:
Initialize global variable ~~allRings~. Loads and calls the function defined in [[*harmonics function][harmonics function]] and plays it. The ~sel~ array defines the partials to be played. If this is three items long, the array of corresponding synths initatilzed in [[*harmonics function][harmonics function]] will be three.

After calling this, call [[*spatialisation][spatialisation]]: make_vbap to play the busses on the speakers.

- ~select~: The harmonics to play
- ~~spatPositions~: The angles for each audio bus (needs to be of equal length to ~sel~). These are initialized at the same time that the partials are selectd.

_1. Load this_

Function that loads [[global_variables][global_variables]] and [[harmonics][harmonics]]. It also initializes the ~~spatialisations~ array. The main settings for the are set here:
- ~selct~
- ~task~
- ~mode~ \harmony, \dual
- ~ampMode~ \default, \full, \linear, \reverse
- ~synthesis~ \synth or \sin
#+name: generate_harmonics
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  var select, task,
  mode = \single,
  ampMode = ~ampMode,
  synthesis = ~synthMode;
  <<global_variables>>
  <<harmonics>>

  "Mode is ".post; mode.postln;

  switch(mode,
    /* 15 partials */
    \harmony, {
          select = [1,2,3,4,5,6,7,8,9,11,13,14,15];
          ~spatPositions = [0,1,5,6,3,2,7,4,9,11,8,10,12];
          "Full mode".postln;		
    },
    \odd, {
          select = [0,1,3,5,7,9,11,13,15,17,19,21,23,25,27];
          ~spatPositions = [0,1,5,6,3,2,7,4,9,11,8,10,12,13,14];
          "Full mode".postln;		
    },
    \single, {
          select = [1];
          ~spatPositions = [0];
          "Single mode".postln;		
    },
    \quart, {
          select = [1,2,3,4];
          ~spatPositions = [0,4,10,12];
          "Quart mode".postln;		
    },
    \dual, {
          select = [1,3];
          ~spatPositions = [0,1];
          "Dual mode".postln;	
    },
    \rhythm, {
          select = ~scaleIndex;
          synthesis = \break;
          /* For \rhythm spatPositions refers to index in the array ~scaleSpats~ */
          ~spatPositions = [select[0]]; 
          "Rhythm mode".postln;
    }); // switch mode

  if(~logging > 1,
    {
          "Length of select array is ".post; select.size.postln;
          "Length of spat array is ".post; ~spatPositions.size.postln;
          ~separator.postln;
          " ".postln;
    },
    { }); //if clause

  /* Holds the busses */
  ~audioBusses = Array.new(select.size);
  /* Holds the synths */
  ~synths = Array.new(select.size);
  /* Holds the original frequency for each bin */
  ~originalFrequencies = Array.new(select.size);
  /* Holds the spat positions for each note, imported from ~allRings */
  ~spatializations = Array.new(~spatPositions.size);

  /* mode = thythm is a special case */
  if(mode == \rhythm,
    {
          "we are IF now".postln;
          ~spatPositions.do({ arg pos, i;	  
            ~spatializations.add(~scaleSpats[pos]);
            "Adding ".post; ~scaleSpats[pos].post; " to ~spatializations".postln;
          });	  
    },
    {
          //          "we are here now".postln;
          if(select.size == ~spatPositions.size,
            {
                  if(~allRings.size >= ~spatPositions.size,
                    {	
                          i = 0;	
                          while( {i < ~spatPositions.size},
                            { ~spatializations.add(~allRings[~spatPositions[i]]);
                                  if(~logging > 1,
                                    { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; },
                                    { }); // if clause
                                  i = i + 1;
                            }); // while clause
                    }, { }); // if clause
            },
            { "'sel' and 'spat' have unequal number of elements".postln; }); // if clause
    });

  /* Call the harmonics function and play it.*/
  task = ~harmonicsFactory.value(~fundamental, select, 0.1, ampMode, synthesis, ~baseAmplitude);
  task.play;
#+end_src
End of /generate_harmonics/

#+begin_src sclang :results none
~spatializations.postln;
#+end_src
** example synth
Generic synth wrapper to generate audio for the spatialisation. This will need to initatilze the ~~audioBusses~ and ~~synths~ arrays. A ~synth~ plays to a specific ~audioBus~. The ~~spatialisations~ array holds the azimuth/elevation pairs for a set of positions.

For the positions, these are fetched from [[file:documentation.org::generate_scale_positions][this code snippet]].
#+begin_src sclang :results none
  ~addGenericSynth = { var synth, index = 0;

    var task,
    mode = ~mode,
    maxSize = ~scaleSpats.size,
    currentSize = 0,
    bus;

   
    /* Holds the synths */
    ~synths = Array.new(maxSize);
    /* Holds the spat positions for each note, imported from ~allRings */
    ~spatializations = Array.new(~spatPositions.size);

    switch(mode,
          \linear, {
            ~spatPositions = Array.iota(~scaleSpats.size);
            "Linear mode".postln;		
          },
          /* Unused */
          \odd, {
            ~spatPositions = Array.iota(~scaleSpats.size);
            "Linear mode".postln;
            "Full mode".postln;		
          }); // switch mode

    if(currentSize < maxSize,
          {
            ~audioBusses.put(currentSize, Control.bus(s, 1));
            synth.set(\bus, ~audioBus[currentSize]);   
            ~synths.put(currentSize, synth);
            currentSize = currentSize + 1;
          },
          { "Current bus is full".postln;});
  }
//  ~addGenericSynth(0,0);
#+end_src

Function to add audio busses to the array ~~audioBusses~. Call with the array and the number of busses to add.
#+name: add_audio_bus
#+begin_src sclang :results none
  ~addAudioBusses = { arg numOfBusses = 1;
    var bus, offset = 0;
    offset = ~audioBusses.size;
    numOfBusses.do( { arg i;
          bus = Bus.audio(s, 1);
          ~audioBusses.add(bus);
    });
  };
#+end_src

Example call to the [[init_audio_bus][init_audio_bus]]. See [[file:snares.org::new_audio_bus][new_audio_bus]] for how to init the ~~audioBusses~ object.
#+begin_src sclang :results none :noweb yes
  <<add_audio_bus>>
  ~addAudioBusses.value(1);
  ~audioBusses.size.postln;
#+end_src

#+begin_src sclang :results none
~audioBusses = Array.new(10);
#+end_src
#+begin_src sclang :results none
  ~audioBusses.size.postln;
  ~audioBusses.do({ arg bus, i;
    "Freeing bus ".post; bus.index.postln;
    bus.free;
  });
#+end_src

** pulse modulation
Build an array of arguments for the interpolation of the pulse frequence of the instruments. This is always relative to the current pulse frequency. Arguments are:
- ~mult~ multiplier for each iteration in the array
- ~duration~ the duration of the interpolation
- ~end~ end value (only for mode 1)
- ~mode~ the mode of the transformation: ~\inharmonic~: modulation map using the index and multiplier, ~\change~: linear map using end value for the modulation for all  voices, ~\harmonic~: symetric transformation, ~\ratio~: a transformation by ratio.
- ~ratio~ the ratio to set the transformation to (e.g. 5/6)

#+name: pulse_interpolate_array
#+begin_src sclang :results none :noweb yes
  <<interpolate_busses>>
  <<pulse_modulation>>
  ~modulateSpeed.value(2, 50, 1, \ratio, [81,80]);
  ~setSpatPositions.value([[9, 1, 10], [3, 1, 10]], 50);
#+end_src

#+begin_src sclang :results none
  var frontDry = { |time = 20|
    ~modulateSpeed.value(0.5, time, 1, \ratio, [27,25]);
    ~setSpatPositions.value([[2, 1, 0], [4, 1, 0]], time);
  };
  frontDry.value(30);
#+end_src

#+begin_src sclang :results none
  ~modulateSpeed.value(0.5, 10, 10, \ratio, [80,54]);
  ~setSpatPositions.value([[12, 1, 0.1], [9, 1, 0.1]], 10);
#+end_src

#+begin_src sclang :results none
  ~modulateSpeed.value(0.5, 10, 10, \ratio, [15,8]);
  ~setSpatPositions.value([[4, 1, 0.1], [5, 1, 0.1]], 10);
#+end_src

#+begin_src sclang :results none
  ~modulateSpeed.value(0.5, 40, 0.5, \ratio, [7,8]);
  ~setSpatPositions.value([[1, 0.05, 50], [9, 0.5, 50]], 40);
#+end_src

#+begin_src sclang :results none
  ~modulateSpeed.value(4, 5, 1, \change, [1,2]);
  //  ~setSpatPositions.value([[1, 0.05, 50], [9, 0.5, 50]], 40);
#+end_src

Create an array of arrays, each with a start, end and dur parameter.
#+name: pulse_modulation
#+begin_src sclang :results none
  ~modulateSpeed = { arg mult = 2, dur = 2, end = 100, mode = \multi, ratio = [2,3];
    var mod_map = Array2D.new(~audioBusses.size, 3), lower = 0;
    mod_map.rowsDo({ arg obj, i;
          // Make sure there are not more rows than objects.
          if(i < ~frequencyBus.size, {
            mod_map[i,0] = ~frequencyBus[i].getSynchronous;
            switch(mode,
                  \inharmonic, { mod_map[i,1] = ~frequencyBus[i].getSynchronous * mult; },	
                  \change, { mod_map[i,1] = end; },
                  \changeHarm, { mod_map[i, 1] = mod_map[i, 0] * mult; },
                  \harmonic, { mod_map[i,1] = end * (i + 1); },
                  \ratio, { if(i % 2 == 0,
                    { mod_map[i,1] = ratio[0] * end; },
                    { mod_map[i,1] = ratio[1] * end; });
                  },
                  \altratio, {
                    lower = ~frequencyBus[0].getSynchronous;
                    if(i % 2 == 0,
                          { 
                            mod_map[i,1] = lower * ratio[0];},
                          { /*rel = ratio[1] / ratio[0]; */
                            mod_map[i,1] = lower * ratio[1];
                          });
                  };
            );
            mod_map[i,2] = dur;
          });
    });
    mod_map.postln;
    ~interpolatePulse.value(mod_map);
  };
#+end_src

#+begin_src sclang :results none
  ~interpolatePulse.value(Array2D.fromArray(2, 2, [10, 5, 9, 8]));
  //  a = Array2D.fromArray(2, 2, [1, 5, 1, 8]);
  //a.rowAt(0).size.postln;
#+end_src

Interpolate all busses. Call this from [[pulse_interpolate_array][pulse_interpolate_array]], that creates an array of values for pulse modulation and interpolation or from the [[pulse_presets][pulse_presets]]. The function takes one argument: an array with start, end and duration.
- ~map~: An array with start, end and duration values,  [ start, end, duration ]
- ~scaleTime~: Scale the time with this value.
#+name: interpolate_busses
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulse = { arg map, scaleTime = 1;
    var startFrq = 1, endFrq = 1, dur = 1;
    map.postln;
    map.rowsDo({ arg obj, i;
          if(map.rowAt(0).size == 2,
            {
                  startFrq = ~frequencyBus[i].getSynchronous;
                  endFrq = obj[0];
                  dur = obj[1] * scaleTime;
            },
            {
                  startFrq = obj[0];
                  endFrq = obj[1];
                  dur = obj[2] * scaleTime;
  
            });
          if(~logging > 1,
            { 
                  "Starting envelope for item ".post; i.post; " from ".post; startFrq.post; " to ".post; endFrq.post; " in ".post; dur.post; " seconds.".postln;						
            }, { });
          {Out.kr(~frequencyBus[i], Line.kr(startFrq, endFrq, dur, doneAction: 2))}.play(addAction: \addToHead);
    });
  };
#+end_src

#+begin_src sclang :results none
  ~frequencyBus[0].getSynchronous.postln;
//  ~synth[0].get(\noiseScale, 0);
#+end_src

#+begin_src sclang :results none
  ~frequencyBus[1].set(200);
#+end_src

#+name: frequency_bus_modulation
#+begin_src sclang :results none
  var updater = Routine({
    var delta;
    loop {
          5.do { arg i;
            0.5.wait;
            i.postln; // Post the value passed in when resumed.
          }
    }
  });
  TempoClock.default.sched(0, updater);
#+end_src

Interpolate one pulse bus.
#+name: interpolate_pulse
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulseSingle = { arg int, bus, start, end, dur;
    {Out.kr(bus, Line.kr(start, end, dur, doneAction: 2))}.play(addAction: \addToHead);
  };
  ~interpolatePulseSingle.value(0, ~frequencyBus[0], 10, 1, 10);
#+end_src

Create an array and interpolate the pulse frequence of the instruments. The arrays should be in the form of [ start_posistion, end_position, duration ] (one such array per channel). All of these are for \dual mode, i.e. two voices.
#+name: pulse_presets
#+begin_src sclang :results none :noweb yes
  <<pulse_modulation>>
  <<interpolate_busses>>
  ~pulsePresets = { arg preset = 1;
    switch(preset,	
          1, {
            ~interpolatePulse.value(Array2D.fromArray(4, 3, [10, 1, 5, 20, 1, 8, 1, 1, 13, 2, 1, 8 ]));
          },
          2, {
            ~interpolatePulse.value(Array2D.fromArray(4, 2, [1, 3, 2, 5, 3, 8, 5, 13 ]));
          },
          20, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [12, 15, 20, 20, 20, 2]));
          },
          3, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 6, 1]));
          },
          4, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 4, 1]));
          },
          5, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 5, 1, 1, 6]));
          },
          6, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [2, 32, 30, 1.5, 24, 30]));
            ~setSpatialization.value(\nther, 20);   
          },  
          7,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 20, 2, 1.5, 15]));
            ~setSpatialization.value(\sine, 15);
          },
          8,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [6, 100, 40, 2, 160, 45]));
            ~setSpatialization.value(\sine, 40);
          },
          9,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [100, 200, 40, 160, 6, 45]));
            ~setSpatialization.value(\simple, 40);
          }, 
          10,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 5, 20, 2, 2]));
            ~setSpatialization.value(\simple, 5);   
          };	
    ) // switch
  };
  ~pulsePresets.value(5);
#+end_src

#+begin_src sclang :results none
a = Array2D.fromArray(3,4, [9,8,7,6,5,4,3,2,1,2,3,4]);
a[2,2] = 1;
a.postln
#+end_src
#+begin_src sclang :results none
  Array2D.fromArray(3, 3, [100, 10, 5, 200, 20, 8, 1,2,3]).postln;
#+end_src
Set and get a bus' value:
#+begin_src sclang :results none
  ~frequencyBus[14].getSynchronous.postln;
#+end_src

Reset original pulse frequencies.
#+name: reset_freqs
#+begin_src sclang :results none
  ~reset_freqs = { arg index = 0, mode = \all;
  
	 if( (index != 0) && (mode == \all),
	  {
		 "If mode is = \all, index must be 0".postln;
		 index = 0;
	  }, { });
  
	 switch(mode,
	  \all, {
		 ~frequencyBus.do({ arg bus, i;
		  "Setting voice ".post; i.post; " to original frequency: ".post; ~originalFrequencies[i].postln;
		  ~frequencyBus[i].set(~originalFrequencies[i]);
		 });
	  },
	  \single, {
		 "Setting voice ".post; index.post; " to original frequency: ".post; ~originalFrequencies[index].postln;
		 ~frequencyBus[index].set(~originalFrequencies[index]);
	  });
  };
  ~reset_freqs.value(0, \all);
#+end_src

#+begin_src sclang :results none
  ~originalFrequencies[0].postln;
#+end_src
** synth settings

Call this function to double the impulse speed and alter the parameters of the [[snare_break][snare_break]] synth. The divisor indicates where in te scale the current note is.
#+name: double_pace
#+begin_src sclang :results none
  ~doubleSpeed = { |synth, divisor=0|
    var fractions = [1.0, 1.0125, 1.024, 1.08, 1.125, 1.25, 1.2656, 1.4815, 1.5, 1.7778, 1.875, 2.0 ],
    breakpoint = 50;
    synth.get(\pulse, {arg val;
          var newVal = val,
          newFreq,
          newFreq2,
          relDivisor = 0.9,	
          newNoise;
          if(newVal > 6, {
            synth.get(\noiseScale, {arg nse;
                  newNoise = nse * 0.6;
                  synth.set(\noiseScale, newNoise);
                  "New noise level is ".post;
                  newNoise.postln;		
            });
          });
          synth.get(\rel, {arg rel;
            synth.set(\rel, rel * relDivisor);
            "New release is ".post;
            (rel * relDivisor).postln;	  
          });	  
          if(newVal > breakpoint, { newFreq = newVal * fractions[divisor] });
          if(newVal > (breakpoint * 2), { newFreq2 = newVal * 0.5 * fractions[divisor] });
          newVal = (val*2) * fractions[divisor];
          synth.set(\pulse, newVal);
          synth.set(\freq, newFreq);
          synth.set(\freq2, newFreq2);
          "New impulse frequency is ".post;
          newVal.postln;
    });
  };
#+end_src

Run [[double_pace][double_pace]] to increase the speed of the snare pulses.
#+name: start_double
#+begin_src sclang :results none :noweb yes
  var synth, index, audioBus;
  <<double_pace>>
  synth = ~synths[0];
  ~doubleRoutine = Routine({
    var delta;
    loop {
          delta = 11;
          delta.yield;
          ~doubleSpeed.value(synth, 1);
    }
  });
  TempoClock.default.sched(0, ~doubleRoutine);
#+end_src

Gradually increase parameter in one synth. 
#+begin_src sclang :results none
  var speeder;
  speeder = { arg instance = 0, range = (3..200), delta = 0.5, param = \freq;
	 var interpolate;
	 interpolate = Task({
	  range.do({ arg index;
		 ~synths[0].set(param, index);
		 delta.wait;	
	  });
	 });
	 interpolate.play;
  };
  speeder.value(14, (200..100), 0.05, \freq);
#+end_src

Gradually increase parameter in all synths using [[set_all_synths][set_all_synths]].
#+begin_src sclang :results none
  ~setSynthsInterpol = { arg range = (3..200), delta = 0.5, param = \rel;
    var interpolate;
    interpolate = Task({
          range.do({ arg value;
            ~setAllSynths.value(param, value);
            delta.wait;	
          });
    });
    interpolate.play;
  };
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((147..294.3), 0.4, \freq);
  ~setSynthsInterpol.value((98..294.3), 0.4, \freq2);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((326..163), 0.1, \freq);
  ~setSynthsInterpol.value((164..108), 0.1, \freq2);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((260..132.45), 0.5, \freq2);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((0.01..0.1), 0.2, \rel);
#+end_src

#+begin_src sclang :results none
  ~setSynthsInterpol.value((150..10), 1, \trifrq); 
#+end_src

#+begin_src sclang :results none
  ~synths[0].get(\freq, { arg value; ("freq is now:" + value + "Hz").postln; });
  ~synths[0].get(\freq2, { arg value; ("freq2 is now:" + value + "Hz").postln; });
#+end_src
#+name: synth_frequency
#+begin_src sclang :results none
  //  ~setAllSynths.value(\freq2, 245.25018);
  //  ~setAllSynths.value(\freq, 490.500036);
  ~setAllSynths.value(\rel, 0.003);
  ~setAllSynths.value(\nattack, 0.1);
  ~setAllSynths.value(\nrel, 0.1);
#+end_src

#+name: synth_release_harmony
#+begin_src sclang :results none
  ~setAllSynths.value(\gain, 1.0);
#+end_src

#+begin_src sclang :results none
  ~setAllSynths = { arg param = \noiseScale, value = 0;
    ~synths.do({ arg obj, i;
          obj.set(param, value);
          "synth ".post; i.postln;
    });
  };
#+end_src

#+begin_src sclang :results none
  ~setSynth = { arg i = 0, param = \freq, value = 0;
    ~synths[i].set(param, value);
    "synth ".post; i.post; " set to ".post; value.postln;
  };
#+end_src

#+begin_src sclang :results none
  ~setAllSynths.value(\noiseScale, 0.2);
#+end_src

#+begin_src sclang :results none
  ~setAllSynths.value(\rel, 0.0005);
#+end_src

Set one synths parameter x.
#+begin_src sclang :results none
  ~setSynth.value(1, \rel, 0.1);
#+end_src

#+name: set_synth_freq
#+begin_src sclang :results none
  ~setSynth.value(0, \freq, 261.6);
  ~setSynth.value(0, \freq2, 264.87);
  ~setSynth.value(1, \freq, 261.6);
  ~setSynth.value(1, \freq2, 264.87);
#+end_src

** ambisonics
#+name: spat_setup_encoder
#+begin_src sclang :results none
  /* setup channels and busses */
  var revMap;
  ~proxyBusAmbi = NodeProxy.new(s, \audio, ~hoaNumChannels);
  ~reverbSendNdefs = Array.new(~audioBusses.size);
  ~reverbBus = Array.new(~audioBusses.size);
  ~controlBus = Array.new(~audioBusses.size);
  ~reverbSendBus = Bus.audio(s, 1);
  revMap = \sin.asWarp;
  
  /* for each audio bus, setup an HOAencoder */
  ~audioBusses.do({ arg bus, i;
    o = "reverbBus" ++ i.asString.asSymbol;
    m = "ch" ++ i.asString.asSymbol;
    n = Bus.control(s, 3); // azi, ele, distance
    ~controlBus.add(n);
    ~proxyBusAmbi[i] = {HOAEncoder.ar(~order, In.ar(bus, 1), In.kr(n), In.kr(n.index + 1), 1, 0, In.kr(n.index + 2)) };
  });
#+end_src

#+begin_src sclang :results none
  ~controlBus[0].setn([0.5pi, 0.1pi, 0]);
  ~controlBus[1].setn([-0.5pi, 0.1pi, 0]);
  ~controlBus[0].setn([90, 23, 1]);
  ~controlBus[0].setn([0, 23, 1]);
  ~controlBus[0].getSynchronous(0);
#+end_src

Call this to set each ~~audioBus~ to a fraction of the space.
#+name: ambi_equal_spread
#+begin_src sclang :results none
  var size, az, el, caz, cel;
  size = ~audioBusses.size;
  az = (pi*2) / (size/2);
  el = (pi / 2) / size;
  size.do({ arg i;
    caz = az * i;
    cel = (el * i) - 0.2;
    ~updatePanningAmbiSingle.value(i, caz, cel, 0, 20) 
//    ~controlBus[i].setn([caz, cel, 0]);
  });
#+end_src

#+begin_src sclang :results none
  Pn((dur: 2, freq:8000)).play;
#+end_src
#+name: spat_setup_decoder
#+begin_src sclang :results none
  ~decoder = NodeProxy.new(s, \audio, ~decoderNumChannels);
  ~decoder.source = {
    var in; in = \in.ar(0!~hoaNumChannels);
    in.add(6);
    KMHLSDome3h3pNormal6.ar(*in);
  };
  ~decoder.fadeTime = 1;
#+end_src

#+name: ambi_connect
#+begin_src sclang :results none :noweb yes
  <<spat_setup_encoder>>
  <<spat_setup_decoder>>
  (
  ~decoder.play(0, ~decoderNumChannels, vol: 1.0);
  ~proxyBusAmbi <>> ~decoder;
  )
#+end_src

#+begin_src sclang :results none
~frequencyBus[1].getn.postln
#+end_src
#+begin_src sclang :results none
  ~spaceNdefsAmbi.size.postln;
  ~audioBusses.size.postln;
#+end_src

Function for generating the lines for the panning modulation using azimuth, elevation and distance. It's being called from [[update_panning_ambi][update_panning_ambi]].
#+name: inter_pan_ambi
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  <<modulate_spat_synth>>
  ~interPanAmbi = { arg bus, astart, aend, estart, eend, dstart, dend, dur;
    var mod1, mod2, mod3, bus1, bus2, bus3;
    bus1 = bus.index;
    bus2 = bus.index + 1;
    bus3 = bus.index + 2;
    /* Mod 1 */
    ~mod1 = Synth.new(\interpolator, [\bus, bus1, \start, astart, \end, aend, \dur, dur], addAction: \addToHead);
    /* Mod 2 */
    ~mod2 = Synth.new(\interpolator, [\bus, bus2, \start, estart, \end, eend, \dur, dur], addAction: \addToHead);
    /* Mod 3 */
    ~mod3 = Synth.new(\interpolator, [\bus, bus3, \start, dstart, \end, dend, \dur, dur], addAction: \addToHead);
    if(~logging > 1,
          {
            "Values for channel ".post; bus.index.postln;
            "Azimuth from ".post; astart.post; " to ".post; aend.postln;
            "Elevation from ".post; estart.post; " to ".post; eend.postln;
            "Distance from ".post; dstart.post; " to ".post; dend.postln;
            " ".postln;   
          }, { });
  };
  //  s.queryAllNodes;
#+end_src

~update_panning_ambi_single~ is called to update panning positions of one channel in the ~spatNdefs~ array. The actual modulation happens in [[inter_pan_ambi][inter_pan_ambi]]. The function takes four arguments:
- ~duration~: The interpolation time.
- ~azimuth~: Angle
- ~elevation~
- ~distance~
#+name: update_panning_ambi_single
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  ~updatePanningAmbiSingle = { arg busIndex, aend, eend, dend, duration;
    var astart, estart, dstart;
    astart = ~controlBus[busIndex].getnSynchronous(3)[0];
    estart = ~controlBus[busIndex].getnSynchronous(3)[1];
    dstart = ~controlBus[busIndex].getnSynchronous(3)[2];
    ~interPanAmbi.value(~controlBus[busIndex], astart, aend, estart, eend, dstart, dend, duration);
  }; //end of function
#+end_src

~update_panning_ambi~ is called to update panning positions of the channels in the ~spatNdefs~ array. The actual modulation happens in [[inter_pan_ambi][inter_pan_ambi]]. The function takes four arguments:
- ~azimuth~: Angle
- ~elevation~
- ~distance~
- ~duration~: The interpolation time.
#+name: update_panning_ambi
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  ~updatePanningAmbi = { arg aend, eend, dend, duration;
    ~audioBusses.do({ arg channel, i;
          var astart, estart, dstart;
          astart = ~controlBus[i].getnSynchronous(3)[0];
          estart = ~controlBus[i].getnSynchronous(3)[1];
          dstart = ~controlBus[i].getnSynchronous(3)[2];
          if((aend-astart) > (360-aend+astart),
            {aend = (aend - 360);
            },
            { });   
          ~interPanAmbi.value(~controlBus[i], astart, aend, estart, eend, dstart, dend, duration);
    }); // end of spatNdefs.do
  }; //end of function
#+end_src

Settings for ~~updatePanningAmbi~
#+name: update_panning_ambi_ctrl
#+begin_src sclang :results none
  var atr = { |angle|
    angle * (pi/180);
  };
  ~firstRingElevation = atr.value(13);
  ~secondRingElevation = atr.value(35);
  ~thirdRingElevation = atr.value(69);
#+end_src

Set panning according to trajectories in ~~allRings~.
#+begin_src sclang :results none :noweb yes
  <<update_panning_ambi_ctrl>>
  ~allRings.do({ arg elem, i;
    atr.value(elem[0]).postln;
    ~updatePanningAmbi.value(atr.value(elem[0]), atr.value(elem[1]), atr.value(elem[2]), 30);
  });
#+end_src

** spatialization VBAP
Spatialisation angles for three rings in triangles.

_2. Load this_
Call this after running [[*generate harmonics][generate harmonics]] to start the spatialisation of the harmonics. It creates the VBAP instances (inside a Ndef) stored in ~~spatNdefs~. It also fills the ~~controlBus~ array with three channel busses for the control of azimuth, elevation and distance respectively.

The functions controlling panning are here: [[inter_pan][inter_pan]].
#+name: make_vbap
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  var revMap;

  <<vbap_speaker_array>>
  ~spatChannels = Array.new(~audioBusses.size); // Unused
  ~spatNdefs = Array.new(~audioBusses.size);
  ~reverbSendNdefs = Array.new(~audioBusses.size);
  ~reverbBus = Array.new(~audioBusses.size);
  ~controlBus = Array.new(~audioBusses.size);
  ~reverbSendBus = Bus.audio(s, 1);
  revMap = \sin.asWarp;
  ~audioBusses.do({ arg bus, i;
    o = "reverbBus" ++ i.asString.asSymbol;
    m = "ch" ++ i.asString.asSymbol;
    n = Bus.control(s, 4);
    ~controlBus.add(n);
    if(~space == 0,
          {
            ~spatNdefs.add(
                  Ndef.new(m, { arg src, azi = 0, ele = 0, spr = 0, dist = 1;
                    src = In.ar(bus.index, 1);
                    azi = In.kr(n.index);
                    ele = In.kr(n.index + 1);
                    dist = LinLin.kr( In.kr(n.index + 2).cubed, 0, 1, 0.0001, 1);
                    spr = LinLin.kr( In.kr(n.index + 3), 0, 100, 1, 100);
                    src = src * dist;
                    VBAP.ar(29, src, ~spkrBuffer.bufnum, azi, ele, spr)});
            );
          },
          {
            ~spatNdefs.add(
                  Ndef.new(m, { arg src, azi = 0, ele = 0, spr = 0, dist = 0;
                    src = In.ar(bus.index, 1);
                    azi = In.kr(n);
                    ele = In.kr(n.index + 1);
                    dist = LinLin.kr( In.kr(n.index + 2).cubed, 0, 1, 0.0001, 1);
                    spr = LinLin.kr( In.kr(n.index + 3), 0, 100, 1, 100);
                    src = src * dist;
                    VBAP.ar(14, src, ~spkrBuffer.bufnum, In.kr(n), In.kr(n.index + 1), spr)});
            );
          });  
    /* Using the same control for the reverb send level, as for the distance parameter
          in the spatialization control (which equals n.index + 2)
    ,*/
    ~reverbSendNdefs.add(
          Ndef(o, {
            var src;
            src = In.ar(bus) * In.kr(n.index + 2) * \revScaleI.kr(0.4);
            src = src * (revMap.map(In.kr(n.index + 2) + 1) * \revScaleII.kr(0.4));
            Out.ar(~reverbSendBus.index, src)
          });
    );
    Ndef(m).fadeTime(1);
    Ndef(m).play(addAction: \addToTail);
    Ndef(o).play(addAction: \addToTail);
  });
  <<inter_pan>>
  <<update_panning>>
  <<reset_freqs>>
#+end_src

#+begin_src sclang :results none
  //{ Line.ar(0, 1, 1).cubed; }.plot;
  f = { arg x=0;
    y = x*x*x;
    x.cubed.postln;
  };
  f.value(0.99);
#+end_src

#+begin_src sclang :results none
  { Line.ar(0, 1, 0.1).sqrt; }.plot(minval: nil, maxval: nil);
#+end_src

Function to start and stop individual nodes
#+name: play_control
#+begin_src sclang :results none
  var playControl = { arg index = 0, message = 0;
	 if(index < ~spatNdefs.size,
	  {
		 case
		 { message == \stop } { ~spatNdefs[index].stop; }
		 { message == \play } { ~spatNdefs[index].play; };
	  },
	  { 
		 "The index is outside of the size of thhe ~spatNdefs".postln;	
	  });
  };
  playControl.value(0, \play);
#+end_src

Set the reverb
#+begin_src sclang :results none
  var setMe = 0.8;
  ~reverbSendNdefs[0].set(\revScaleI, setMe);
  ~reverbSendNdefs[0].set(\revScaleII, setMe);
  ~reverbSendNdefs[1].set(\revScaleI, setMe);
  ~reverbSendNdefs[1].set(\revScaleII, setMe);
#+end_src

#+begin_src sclang :results none
  ~spatNdefs[1].set(\spr, 0);
#+end_src

Set individual controlbusses
#+begin_src sclang :results none
  ~controlBus[0].getnSynchronous(4)[3].postln;
  ~controlBus[0].setn([40, 23, -0.9, 1]);
#+end_src

Control individual synths pulse.
#+begin_src sclang :results none
  var pulse = 10, synth = 0;
  //  ~synths[synth].set(\pulse, 2);
  ~synths[synth].get(\pulse, {arg item; item.postln; });
  ~synths.size.postln;
#+end_src

Set all synths parameter to a value.
#+begin_src sclang :results none
  ~updateSynths = { arg parameter = \trifreq, value = 100;
	 var changeAll = ~synths.do({ arg item, i;
	  item.set(parameter, value);
	  "Setting ".post; parameter.post; " to ".post; value.postln;
	 });
  };
  ~updateSynths.value(\freq, 320);
#+end_src

Set all spatNdefs parameter to a value (Doesn't work)
#+begin_src sclang :results none
  ~updateVBAP = { arg parameter = \spr, value = 0;
	 var changeAll = ~spatNdefs.do({ arg item, i;
	  item.set(parameter, value);
	  "Setting ".post; parameter.post; " to ".post; value.postln;
	 });
  };
  ~updateVBAP.value(\spr, 0);
#+end_src

#+name: reboot
#+begin_src sclang :results none
  s.reboot;
#+end_src

#+name: scope_reverb
#+begin_src sclang :results none
  ~reverbSendBus.scope;
#+end_src

** spatialization panning
_3 Setting spatialization_

Loads necesary auxilliary functions and copies over the positions according to the ~spat_array~ argument. If provided it should be an array (length equal to the number of spat channels) of arrays, each of which is an array with [pos(azimuth, elevation), distance and spread]. It calls ~~updatePanning~ before exiting. The function takes two arguments:
- ~spat_array~: An array2d of arrays with he indexes in the ~~allRings~ array to be copied over, the distancs and the spread.
- ~duration~: The time for the transformation.
#+name: set_spatialization
#+begin_src sclang :results none :noweb yes  :tangle harmony.sc
  <<free_spat_busses>>
  ~setSpatPositions = { arg spat_array, duration = 10, elevation = 0;
    var spatPresets = ~allRings;
    "The spat array".postln;
    " ".postln;
    spat_array.postln;

    if(~mode == \rhythm,
          { spatPresets = ~scaleSpats; });
    spatPresets.postln;

    /* free current trajectories */
    freeModBus.value();
    ~spatializations.do({ arg item, i; // i is the row
          var pos;
          item.postln;
          /* Get the x/y position */	
          if(spat_array.size == 0,
            /* The call to ~setSpatPositions was done without an argument */
            {
                  pos = ~spatializations.at(i);
                  if(~spatializations.at(i).size < 4,
                    {
                          pos.extend(4, 0);
                          pos.put(2, 1.0);
                          pos.put(3, 0.0);
                    },
                    {
                    }); 
            }, 
            /* The call to ~setSpatPositions was done with an argument */
            {
                  pos = spatPresets.wrapAt(spat_array.wrapAt(i)[0]);
                  " ".postln;
                  "---------------------------".postln;
                  /* Alter in elevation if specified */		
                  if(elevation != 0, {pos[1] = elevation;});		
                  "current pos value: ".post;
                  pos.postln;  
                  pos.put(2, spat_array.wrapAt(i)[1]);
                  pos.put(3, spat_array.wrapAt(i)[2]);
            }); /* End of if(spat_array.size) */

          ~spatializations.put(i, pos);
          if(~logging > 1,
            {
                  "Set panning:".postln;
                  " ".postln;  
                  "Putting spat angles ".post;  pos[0].post; "/".post; pos[1].post; " at index ".post; i.post; " with distance ".post; pos[2].post; " and spread ".post; pos[3].postln;
            }, { }); // if logging
    }); // spatialilzation.do
    ~updatePanning.value(duration);
  };
#+end_src

Bring forward in one angle
#+begin_src sclang :results none
  ~setSpatPositions.value([ [2, 1, 1 ] ], 1, 10);
  // ~spatializations[0].postln;
  //~controlBus[1].scope;
#+end_src

Use this to re-initialize the spatialisations array. 
#+name: reinit_spatialisations
#+begin_src sclang :results none :noweb yes
  <<all_rings>>
  if(~allRings.size >= ~spatPositions.size,
    {	
          i = 0;	
          while( {i < ~spatPositions.size},
            { ~spatializations.put(i, ~allRings[~spatPositions[i]]);
                  if(~logging > 1,
                    { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; },
                    { }); // if clause
                  i = i + 1;
            }); // while clause
    },
    { }; // if clause
  );
#+end_src

#+begin_src sclang :results none :noweb yes
  <<all_rings>>
  <<reinit_spatialisations>>
  ~allRings[0].postln;
#+end_src

Call the update panning function setting the current panning to the setting of the ~~spatializations~ vector.
#+begin_src sclang :results none
  ~updatePanning.value(1);
#+end_src

#+name: modulate_spat_synth
#+begin_src sclang :results none
  SynthDef(\interpolator, {
    Out.kr(\bus.ir, Line.kr(\start.ir, \end.ir, \dur.ir, doneAction: 2););
  }).add;
#+end_src

Function for generating the lines for the panning modulation using azimuth, elevation and distance. It's being called from [[update_panning][update_panning]] that takes values from the ~~spatializations~ array.
#+name: inter_pan
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  <<modulate_spat_synth>>
  ~interPan = { arg bus, astart, aend, estart, eend, dstart, dend, sstart, send, dur;
    var mod1, mod2, mod3, mod4, bus1, bus2, bus3, bus4;
    bus1 = bus.index;
    bus2 = bus.index + 1;
    bus3 = bus.index + 2;
    bus4 = bus.index + 3;
    /* Mod 1 */
    ~mod1 = Synth.new(\interpolator, [\bus, bus1, \start, astart, \end, aend, \dur, dur], addAction: \addToHead);
    /* Mod 2 */
    ~mod2 = Synth.new(\interpolator, [\bus, bus2, \start, estart, \end, eend, \dur, dur], addAction: \addToHead);
    /* Mod 3 */
    ~mod3 = Synth.new(\interpolator, [\bus, bus3, \start, dstart, \end, dend, \dur, dur], addAction: \addToHead);
    /* Mod 4 */
    ~mod4 = Synth.new(\interpolator, [\bus, bus4, \start, sstart, \end, send, \dur, dur], addAction: \addToHead);
    if(~logging > 1,
          {
            "Values for channel ".post; bus.index.postln;
            "Azimuth from ".post; astart.post; " to ".post; aend.postln;
            "Elevation from ".post; estart.post; " to ".post; eend.postln;
            "Distance from ".post; dstart.post; " to ".post; dend.postln;
            "Spread from ".post; sstart.post; " to ".post; send.postln;
            " ".postln;   
          }, { });
  };
  //  s.queryAllNodes;
#+end_src

#+name: free_spat_busses
#+begin_src sclang :results none
  var freeModBus = {
    ~mod1.free;
    ~mod2.free;
    ~mod3.free;
    ~mod4.free;
    "Modulators are freed.".postln;
    " ".postln;
  };
  freeModBus.value();
#+end_src

~update_panning~ is called to update panning positions of the channels in the ~spatNdefs~ array. The actual modulation happens in [[inter_pan_full][inter_pan]]. The function takes one argument:
- ~duration~: The interpolation time.
#+name: update_panning
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  ~updatePanning = { arg duration;
    ~spatNdefs.do({ arg channel, i;
          var astart, aend, estart, eend, dstart, dend, sstart, send;
          astart = ~controlBus[i].getnSynchronous(3)[0];
          aend = ~spatializations[i][0];
          estart = ~controlBus[i].getnSynchronous(3)[1];
          eend = ~spatializations[i][1];
          dstart = ~controlBus[i].getnSynchronous(3)[2];
          dend =  ~spatializations[i][2];
          sstart = ~controlBus[i].getnSynchronous(4)[3];
          send = ~spatializations[i][3];
          if((aend-astart) > (360-aend+astart),
            {aend = (aend - 360);
            },
            { });   
          ~interPan.value(~controlBus[i], astart, aend, estart, eend, dstart, dend, sstart, send, duration);
    }); // end of spatNdefs.do
  }; //end of function
#+end_src

Special version for the ~~scaleSpats~ array.
~update_panning~ is called to update panning positions of the channels in the ~spatNdefs~ array. The actual modulation happens in [[inter_pan_full][inter_pan]]. The function takes one argument:
- ~duration~: The interpolation time.
#+name: update_panning_scale
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  ~updatePanningScale = { arg scaleStep=0, elev=0, duration;
    ~spatNdefs.do({ arg channel, i;
          var astart, aend, estart, eend, dstart, dend, sstart, send;
          astart = ~controlBus[i].getnSynchronous(3)[0];
          aend = ~scaleSpats[scaleStep][0];
          estart = ~controlBus[i].getnSynchronous(3)[1];
          eend = elev;
          dstart = ~controlBus[i].getnSynchronous(3)[2];
          dend =  ~scaleSpats[scaleStep][2];
          sstart = ~controlBus[i].getnSynchronous(4)[3];
          send = ~scaleSpats[scaleStep][3];
          if((aend-astart) > (360-aend+astart),
            {aend = (aend - 360);
            },
            { });   
          ~interPan.value(~controlBus[i], astart, aend, estart, eend, dstart, dend, sstart, send, duration);
    }); // end of spatNdefs.do
  }; //end of function
#+end_src

#+begin_src sclang :results none
  ~spatializations[0][2].postln;
#+end_src

*Utitlity function*
Peek into the the ~~spatializations~ vector. Each row contains the data for one channel's current setting. Each column holds Azimuth, Evelation, Distance and Spread.
#+begin_src sclang :results none
  ~spatializations[0][1].postln;
#+end_src

*Utitlity function*
Monitor the current ~~spatializations~ vector for a given data.
#+begin_src sclang :results none
  var monitorSpatSettings = { arg data=0;
    ~spatializations.do({ arg obj, i;
          obj[data].postln;
    });  
  };
  monitorSpatSettings.value(1);
#+end_src

*Utitlity function*
Call the function getIt to retrieve the current values of the three ~~controlBus~ instances.
#+begin_src sclang :results none
  var getIt = { arg instance = 0;
    " ".postln;
    "Current values for".postln;
    "Azimuth (angle): ".post;
    ~controlBus[instance].getnSynchronous(3)[0].postln;
    "Elevation (angle): ".post;
    ~controlBus[instance].getnSynchronous(3)[1].postln;
    "Distance (0-1): ".post;
    ~controlBus[instance].getnSynchronous(3)[2].postln;
    "Spread (0-100): ".post;
    ~controlBus[instance].getnSynchronous(4)[3].postln;
  };
  getIt.value(1);
#+end_src

#+begin_src sclang :results none
  ~controlBus[0].scope;
#+end_src
** spatialization data
Fade in 15 channels
#+name: spat_fade_in
#+begin_src sclang :results none
~setSpatPositions.value([ [ 5, 0.001, 0.1 ], [ 6, 0.001, 0.1 ], [ 0, 0.01, 0.1 ], [ 13, 0.70112240314484, 91 ], [ 4, 0.029506921768188, 9 ], [ 12, 0.64996898174286, 74 ], [ 6, 0.36793804168701, 15 ], [ 12, 0.62310302257538, 40 ], [ 1, 0.3138290643692, 56 ], [ 2, 0.23481667041779, 55 ], [ 8, 0.34279143810272, 72 ], [ 3, 0.21060848236084, 59 ], [ 6, 0.90231537818909, 9 ], [ 3, 0.96117198467255, 5 ], [ 4, 0.26086962223053, 64 ] ], 10);
#+end_src

Fade out.
#+begin_src sclang :results none
  ~setSpatPositions.value([ [ 0, 1, 90 ], [ 1, 1, 90 ] ], 20);
#+end_src

Bring forward in one angle
#+begin_src sclang :results none
  ~setSpatPositions.value([ [4, 1.0, 9] ], 8);
  //~controlBus[1].scope;
#+end_src

Bring up, forward.
#+begin_src sclang :results none
  ~setSpatPositions.value([ [3, 0.3, 10 ] ], 8);
#+end_src

#+begin_src sclang :results none :noweb yes
//  <<free_spat_busses>>
  ~setSpatPositions.value([ [8, 0.9, 40] ], 20);
 //  s.scope;
#+end_src

#+call: free_spat_busses

Put to distance in two angles
#+begin_src sclang :results none
~setSpatPositions.value([ [ 10, 0.0, 10 ], [ 3, 0.0, 10 ] ], 5);
#+end_src

#+call: free_spat_busses()

#+begin_src sclang :results none
  ~setSynth.value(0, \gain, 1);
  ~setSynth.value(1, \gain, 1);
  ~setSynth.value(2, \gain, 1);
  ~setSynth.value(3, \gain, 1);
#+end_src

#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 2, 0.05, 1 ],
    [ 6, 0.05, 1 ],
    [ 13, 0.05, 1 ],
    [ 0, 0.05, 1 ] ],
    10);
#+end_src

In the distance
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 0.15, 1 ],
    [ 4, 0.1, 1 ],
    [ 10, 0.15, 1 ],
    [ 12, 0.1, 1 ] ],
    10);
#+end_src

Bring forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 5, 1, 1 ],
    [ 2, 1, 1 ],
    [ 15, 1, 1 ],
    [ 14, 1, 1 ] ],
    5);
#+end_src

Mix forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 0.7, 1 ],
    [ 4, 0.8, 1 ],
    [ 10, 0.7, 1 ],
    [ 12, 0.5, 1 ] ],
    30);
#+end_src

Mix forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 1, 1 ],
    [ 4, 0.05, 1 ],
    [ 10, 1, 1 ],
    [ 12, 0.05, 1 ] ],
    30);
#+end_src

Init
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 1, 1 ] ],
    10);
#+end_src

#+begin_src sclang :results none
  var setMe = 0.9;
  ~reverbSendNdefs[0].set(\revScaleI, setMe);
  ~reverbSendNdefs[0].set(\revScaleII, setMe);
  ~reverbSendNdefs[1].set(\revScaleI, setMe);
  ~reverbSendNdefs[1].set(\revScaleII, setMe);
#+end_src

#+name: init_spatialization
#+begin_src sclang :results none :noweb yes
  <<set_spatialization>>
  <<spat_function>>
  ~setSpatPositions.value();
  ~setSpatialization.value(\sine, 10);
#+end_src

#+begin_src sclang :results none
  ~spatializations.at(0).size.postln;
  ~allRings.size.postln;
#+end_src

Change spatialization. Spat is controlled by an arbitrary length array that points to one of the 14 (0-13) speaker positions available. Use the ~spat_function~ to create new presets.
#+begin_src sclang :results none
  ~setSpatialization.value(\distanceO, 1);
  ~setSpatialization.value(\distanceI, 1);
#+end_src

#+name: set_sine
#+begin_src sclang :results none
  ~setSpatialization.value(\sine, 20);
#+end_src

#+name: set_sine
#+begin_src sclang :results none
  ~setSpatialization.value(\randa, 5);
#+end_src

#+begin_src sclang :results none
  ~setSpatPositions.value([[0, 1, 0.1], [1, 1, 0.1]], 20);
  ~setSpatPositions.value([[14, 0.1, 50], [14, 0.1, 50]], 20);
#+end_src

#+begin_src sclang :results none

#+end_src

#+begin_src sclang :results none
  var dist = 0.5, pos;
  pos = ~allRings.wrapAt([0,10].wrapAt(0));
  pos.put(2, dist);
#+end_src

Never set the spread to less then 0.1.
#+name: spat_function
#+begin_src sclang :results none
  ~setSpatialization = { arg preset, time;
    switch(preset,
          \single, { ~setSpatPositions.value([[0, 1, 0.1], [1, 1, 0.1]]); },
          \simple, { ~setSpatPositions.value([[0, 0.6, 0.1], [1, 0.6, 0 ]]); },
          \distanceI, { ~setSpatPositions.value([[0, 0.0, 0.0], [1, 0.0, 0.0]]); },
          \distanceO, { ~setSpatPositions.value([[0, 1, 50.0], [1, 1, 0.0]]); },
          \nther, { ~setSpatPositions.value([[3, 0.1, 0.0], [0, 0.6, 0.0]]); },
          \sine, { ~setSpatPositions.value([[0.0, 0.1, 0.0], [2.0, 0.2, 0.0], [4.0, 0.3, 0.0], [6.0, 0.4, 0.0], [7.0, 0.3, 0.0], [9.0, 0.3, 0.0], [10.0, 0.2, 0.0], [12.0, 0.1, 0.0], [13.0, 0.1, 0.0], [13.0 , 0.1, 0.0], [ 13.0, 0.1, 0.0], [ 13.0, 0.1, 0.0], [ 3.0, 0.1, 0.0], [13.0 , 0.1, 0.0], [12.0, 0.1, 0.0], [10.0, 0.1, 0.0], [9.0 , 0.1, 0.0], [7.0, 0.1, 0.0], [6.0, 0.1, 0.0], [4.0, 0.1, 0.0], [2.0, 0.1, 0.0]]); },
          \frontTop, { ~setSpatPositions.value([[2, 1, 0.0], [5, 1, 0.0], [9, 0.3, 0.0], [12, 0.3, 0.0],[9, 0.3, 0.0],[12, 0.3, 0.0],[9, 0.3, 0.0],[12, 0.3, 0.0],[2, 0.3, 0.0],[5, 0.3, 0.0], [9, 0.3, 0.0], [12, 0.3, 0.0], [2, 0.3, 0.0], [9, 0.3, 0.0]]); };
          \randa, { ~setSpatPositions.value([[ 10, 0.37790203094482, 92 ], [ 9, 0.47935628890991, 74 ], [ 6, 0.11242318153381, 86 ], [ 9, 0.35007119178772, 84 ], [ 11, 0.97699058055878, 97 ], [ 0, 0.43978643417358, 82 ], [ 4, 0.046381950378418, 49 ], [ 3, 0.93596339225769, 45 ], [ 11, 0.69877302646637, 97 ], [ 1, 0.57486021518707, 0 ], [ 11, 0.10488903522491, 24 ], [ 6, 0.6761668920517, 81 ], [ 12, 0.15752398967743, 95 ] ]); };
          \randb, { ~setSpatPositions.value([ [ 8, 0.65711605548859, 44 ], [ 12, 0.49157476425171, 61 ], [ 2, 0.30045628547668, 53 ], [ 6, 0.63139295578003, 10 ], [ 5, 0.57754254341125, 53 ], [ 1, 0.50569725036621, 60 ], [ 7, 0.5032913684845, 52 ], [ 9, 0.17669081687927, 72 ], [ 11, 0.83947396278381, 23 ], [ 11, 0.87903380393982, 47 ], [ 3, 0.90455305576324, 26 ], [ 12, 0.53946733474731, 2 ], [ 0, 0.99620449542999, 96 ] ]); };
    )};
#+end_src

#+begin_src sclang :results none
  ~generateRandomSpat = {
    ~spatializations.size.postln;
    b = Array.new(~spatializations.size * 3);
    ~spatializations.do({ arg item, i;
          c = Array.with(14.rand, 1.0.rand, 100.rand);
          b = b.addAll(c);
    });
    a = Array2D.fromArray(~spatializations.size, 3, b);
    a.postln;
  };
  ~generateRandomSpat.value();
#+end_src

#+begin_src sclang :results none
  //  a = Array.fill2D(2, 3, { arg r,c; r*c+c;});
  a = [ [ 0, 1, 2 ], [ 0, 2, 4 ] ];
  a[1][2].postln;
  a.size.postln;
#+end_src
#+begin_src sclang :results none
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addAll([7, 8, 9]);
z.postln;
y.postln;
)
#+end_src
_4. Free all_
Free all busses and stop execution
#+name: free_all
#+begin_src sclang :results none :noweb yes
  <<free_busses>>
  ~decoder.clear;
  Ndef(\reverbBus).clear;
  Ndef(\reverb).clear;
  CmdPeriod.run;
#+end_src

Reboot Supercollider
#+begin_src sclang :results none
  s.reboot;
#+end_src

Show meter
#+name: show_meter
#+begin_src sclang :results none
  s.meter;
#+end_src

Plot tree
#+name: plot_tree
#+begin_src sclang :results none
  s.plotTree
#+end_src
--------------------------------

#+begin_src sclang :results none
  //if(~audioBusses != nil, {"yes".postln;},{"no".postln;});
  ~audioBusses.isNil.postln;
  ~audioBusses.size.postln;
#+end_src
#+begin_src sclang :results none
  ~audioBusses[0].scope;
#+end_src
** scheme functions
*** stuff
#+begin_src scheme :results output raw
  (map (lambda (x) (modulo x 2)) (iota 10))
#+end_src

#+begin_src scheme :results output raw
  (reverse '(1 2 3))
#+end_src

*** write data file for spatialisation
:PROPERTIES:
:header-args: :results output raw :exports code :noweb yes :wrap "src sclang"
:END:

This functions creates a call to the supercollider function ~setSpatPositions~ with values for:
1. azimuth/elevation, defined as a VBAP position in the Klangkupolen dome. This poisitions are reduced to 14 centre positions in each of the triangles created by two adjacent rings of speakers.
2. The distance parameter
3. The spread paramter

Each array in the array corresponds to one note in the chord.
   
Parameters:
- ~size~: The size of the array
- ~array_size~: The size of the speaker array (if ~size~ > ~array_size~, size will wrap around this parameter).
- ~spread_mult~: The multiplier for the ~spread~ parameter (unity).
- ~dist_func~: Which function to use for the distance paramter.
- ~spread_func~: Which function to use for the spread parameter.
#+name: run_spatialization_method
#+begin_src scheme :var size=5 array_size=2 spread_mult=100 dist_func=4 spread_func=2 :noweb yes
  <<sequenced_array>>
  (use-modules (ice-9 format))
  (define azel (iota size))
  (define distance (select-seq-array 0 size '() dist_func))
  (define spread  (select-seq-array 0 size '() spread_func))
  (format #t "~a" "~setSpatPositions.value([")
  (map (lambda (ae dist spr)
         (format #t "[~d, ~f, ~f], " (modulo ae array_size) dist (* spr spread_mult)))
       azel distance spread)
  (format #t "~a" "], 5)")
#+end_src


**** spatialisation array
:PROPERTIES:
:header-args: :results output raw :var dist=1 :exports code :noweb yes :wrap "src sclang"
:END:
Evaluate this line with corresponding arguments (see [[*write data file for spatialisation][Documentation]]) and then the plot for the same functions below.
#+call: run_spatialization_method(dist_func=3, spread_func=4)

***** plot
:PROPERTIES:
:header-args: :results output
:END:
#+call: plot_array[:file output_array_dist.png](flag=0)

#+RESULTS:
[[file:output_array_dist.png]]

#+call: plot_array[:file output_array_spread.png](flag=1)

#+RESULTS:
[[file:output_array_spread.png]]

size=14
array_size = 14
spread_multi = 5
(define azel (iota size))
(define distance  (seq-array-exponential 0 size '()))
(define spread  (seq-array-cos 0 size '()))
#+name: scary_reversed
#+begin_src sclang
~setSpatPositions.value([[0, 1.0, 0.0], [1, 0.5, 1.3132476751859679], [2, 0.25, 2.0814483193289965], [3, 0.125, 2.6264953503719357], [4, 0.0625, 3.0492666725598117], [5, 0.03125, 3.394695994514964], [6, 0.015625, 3.686752324814032], [7, 0.0078125, 3.939743025557903], [8, 0.00390625, 4.162896638657993], [9, 0.001953125, 4.36251434774578], [10, 0.0009765625, 4.543090530640261], [11, 0.00048828125, 4.707943669700932], [12, 0.000244140625, 4.859593857014607], [13, 0.0001220703125, 5.0], ], 5)
#+end_src


size=14
array_size = 14
spread_multi = 5
(define azel (iota size))
(define distance  (seq-array-exponential 0 size '()))
(define spread  (seq-array-cos 0 size '()))
#+name: scary_high
#+begin_src sclang
~setSpatPositions.value([[0, 0.0001220703125, 5.0], [1, 0.000244140625, 4.968561049458011], [2, 0.00048828125, 4.874639560876518], [3, 0.0009765625, 4.719416651469258], [4, 0.001953125, 4.504844339384966], [5, 0.00390625, 4.233620995946561], [6, 0.0078125, 3.909157412066121], [7, 0.015625, 3.5355339055701624], [8, 0.03125, 3.117449008835507], [9, 0.0625, 2.6601603820184705], [10, 0.125, 2.1694186949278196], [11, 0.25, 1.651395309015289], [12, 0.5, 1.1126046689245963], [13, 1.0, 0.5598223795702612], ], 5)
#+end_src

size=14
array_size = 6
spread_multi = 20
azel is reversed
(define azel (reverse (iota size)))
(define distance  (seq-array-cos 0 size '()))
(define spread  (seq-array-sin 0 size '()))
#+name: reversed_limited
#+begin_src sclang
~setSpatPositions.value([[1, 1.0, 0.0], [0, 0.9937122098916022, 4.450418679697605], [5, 0.9749279121753036, 8.677674783407115], [4, 0.9438833302938515, 12.469796038549152], [3, 0.9009688678769932, 15.63662965082208], [2, 0.8467241991893122, 18.019377359319684], [1, 0.7818314824132242, 19.49855824441887], [0, 0.7071067811140325, 20.0], [5, 0.6234898017671014, 19.498558242593276], [4, 0.5320320764036941, 18.01937735576004], [3, 0.43388373898556387, 15.636629645706883], [2, 0.3302790618030578, 12.469796032134903], [1, 0.22252093378491927, 8.677674776015445], [0, 0.11196447591405223, 4.450418671699165], ], 5)
#+end_src

size=14
array_size = 14
spread_multi = 20
azel is reversed
(define azel (reverse (iota size)))
(define distance  (seq-array-sin 0 size '()))
(define spread  (seq-array-cos 0 size '()))
#+name: reversed_list_spread
#+begin_src sclang
~setSpatPositions.value([[13, 1.0, 0.0], [12, 0.9937122098916022, 4.450418679697605], [11, 0.9749279121753036, 8.677674783407115], [10, 0.9438833302938515, 12.469796038549152], [9, 0.9009688678769932, 15.63662965082208], [8, 0.8467241991893122, 18.019377359319684], [7, 0.7818314824132242, 19.49855824441887], [6, 0.7071067811140325, 20.0], [5, 0.6234898017671014, 19.498558242593276], [4, 0.5320320764036941, 18.01937735576004], [3, 0.43388373898556387, 15.636629645706883], [2, 0.3302790618030578, 12.469796032134903], [1, 0.22252093378491927, 8.677674776015445], [0, 0.11196447591405223, 4.450418671699165], ], 5)
#+end_src

size=14
array_size = 14
spread_multi = 1
azel is reversed
(define azel (iota size))
(define distance  (seq-array-sin 0 size '()))
(define spread  (seq-array-cos 0 size '()))
#+name: reversed_list
#+begin_src sclang
~setSpatPositions.value([[13, 0.0, 1.0], [12, 0.22252093398488024, 0.9937122098916022], [11, 0.4338837391703557, 0.9749279121753036], [10, 0.6234898019274576, 0.9438833302938515], [9, 0.781831482541104, 0.9009688678769932], [8, 0.9009688679659842, 0.8467241991893122], [7, 0.9749279122209434, 0.7818314824132242], [6, 1.0, 0.7071067811140325], [5, 0.9749279121296639, 0.6234898017671014], [4, 0.900968867788002, 0.5320320764036941], [3, 0.7818314822853442, 0.43388373898556387], [2, 0.6234898016067452, 0.3302790618030578], [1, 0.4338837388007723, 0.22252093378491927], [0, 0.22252093358495822, 0.11196447591405223], ], 5)
#+end_src

#+name: spat_four_soft
#+begin_src sclang
~setSpatPositions.value([[0, 0.0, 50.0], [1, 0.26264953503719357, 49.68561049458011], [2, 0.4162896638657993, 48.746395608765184], [3, 0.5252990700743871, 47.194166514692576], [0, 0.6098533345119623, 45.04844339384966], [1, 0.6789391989029928, 42.336209959465606], [2, 0.7373504649628064, 39.09157412066121], [3, 0.7879486051115806, 35.35533905570162], [0, 0.8325793277315986, 31.17449008835507], [1, 0.872502869549156, 26.601603820184707], [2, 0.9086181061280522, 21.694186949278194], [3, 0.9415887339401864, 16.513953090152892], [0, 0.9719187714029215, 11.126046689245964], [1, 1.0, 5.598223795702611], ], 10)
#+end_src

size=14 array_size=4
(define azel (iota size))
(define distance  (seq-array-cos 0 size '()))
(define spread  (seq-array-sin 0 size '()))
#+name: spat_minor_spread
#+begin_src sclang
~setSpatPositions.value([[0, 1.0, 0.0], [1, 0.9937122098916022, 0.22252093398488024], [2, 0.9749279121753036, 0.4338837391703557], [3, 0.9438833302938515, 0.6234898019274576], [0, 0.9009688678769932, 0.781831482541104], [1, 0.8467241991893122, 0.9009688679659842], [2, 0.7818314824132242, 0.9749279122209434], [3, 0.7071067811140325, 1.0], [0, 0.6234898017671014, 0.9749279121296639], [1, 0.5320320764036941, 0.900968867788002], [2, 0.43388373898556387, 0.7818314822853442], [3, 0.3302790618030578, 0.6234898016067452], [0, 0.22252093378491927, 0.4338837388007723], [1, 0.11196447591405223, 0.22252093358495822], ], 10)
#+end_src

size=14 array_size=4
(define azel (iota size))
(define distance  (seq-array-log 0 size '()))
(define spread  (seq-array-sin 0 size '()))
#+name: 
#+begin_src sclang
  ~setSpatPositions.value([[0, 0.0, 0.0], [1, 0.26264953503719357, 0.22252093398488024], [2, 0.4162896638657993, 0.4338837391703557], [3, 0.5252990700743871, 0.6234898019274576], [0, 0.6098533345119623, 0.781831482541104], [1, 0.6789391989029928, 0.9009688679659842], [2, 0.7373504649628064, 0.9749279122209434], [3, 0.7879486051115806, 1.0], [0, 0.8325793277315986, 0.9749279121296639], [1, 0.872502869549156, 0.900968867788002], [2, 0.9086181061280522, 0.7818314822853442], [3, 0.9415887339401864, 0.6234898016067452], [0, 0.9719187714029215, 0.4338837388007723], [1, 1.0, 0.22252093358495822], ], 10)
#+end_src

#+RESULTS:
#+begin_src sclang
#+end_src


*** list creation functions
Use ~select-seq-array~ as a utility function to be able to select function programmatically. All seg-array-* are normalized.
#+name: sequenced_array
#+begin_src scheme :results value
  (define pi 3.141592654)
  
  (define seq-array
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array (+ i 1) n
                     (append x (list (/ i (- n 1.0))))))))
  
  (define seq-array-reciprocal
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-reciprocal (+ i 1) n
                                (append x (list
                                           (/ 1 (+ 1.0 i))))))))
  
  (define seq-array-exponential
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-exponential (+ i 1) n
                                 (append x (list
                                            (/ (expt 2 i) (expt 2 (- n 1.0)))))))))
  
  (define seq-array-log
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-log (+ i 1) n
                         (append x (list (/ (log (+ i 1)) (log n))))))))
  
  (define seq-array-sin
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-sin (+ i 1) n
                         (append x (list (sin (* (/ i n) pi))))))))
  
  (define seq-array-cos
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-cos (+ i 1) n
                         (append x (list (cos (* (/ i n) (/ pi 2)))))))))
  
  (define seq-array-constant 0)
  
  (define select-seq-array
    (lambda (i n x j)
      (cond ((= j 0) (seq-array i n x))
            ((= j 1) (seq-array-reciprocal i n x))
            ((= j 2) (seq-array-exponential i n x))
            ((= j 3) (seq-array-log i n x))
            ((= j 4) (seq-array-sin i n x))
            ((= j 5) (seq-array-cos i n x)))))
  
  (select-seq-array 0 5 '() 2)
#+end_src

Plot the functions above using the index of the function called. 
#+name: plot_array
#+begin_src gnuplot :var len=20 flag=6 :file output_array.png
  set xrange [0: 20]
  if(flag==0) {
      plot x
  }
  if(flag==1) {
      plot abs(x-len)
      }
  if(flag==2) {
      plot 2**x / 2**(len-1)
  }
  if(flag==3) {
      plot (log (x+1)) / log(len)
  }
  if(flag==4) {
      plot sin((x/len)*pi/2)
  }
  if(flag==5) {
      plot cos((x/len)*pi/2)
  }
  if(flag==6) {
      plot 1
  }
#+end_src

#+RESULTS: plot-array
[[file:output_array.png]]

#+begin_src gnuplot :file integral.png
  # set terminal pngcairo  transparent enhanced font "arial,10" fontscale 1.0 size 600, 400 
set key fixed right bottom vertical Right noreverse enhanced autotitle nobox
set samples 50, 50
set style data lines
set xrange [ * : * ] noreverse writeback
set x2range [ * : * ] noreverse writeback
set yrange [ * : * ] noreverse writeback
set y2range [ * : * ] noreverse writeback
set zrange [ * : * ] noreverse writeback
set cbrange [ * : * ] noreverse writeback
set rrange [ * : * ] noreverse writeback
integral_f(x) = (x>0)?int1a(x,x/ceil(x/delta)):-int1b(x,-x/ceil(-x/delta))
int1a(x,d) = (x<=d*.1) ? 0 : (int1a(x-d,d)+(f(x-d)+4*f(x-d*.5)+f(x))*d/6.)
int1b(x,d) = (x>=-d*.1) ? 0 : (int1b(x+d,d)+(f(x+d)+4*f(x+d*.5)+f(x))*d/6.)
f(x) = exp(-x**2)
integral2_f(x,y) = (x<y)?int2(x,y,(y-x)/ceil((y-x)/delta)):                         -int2(y,x,(x-y)/ceil((x-y)/delta))
int2(x,y,d) = (x>y-d*.5) ? 0 : (int2(x+d,y,d) + (f(x)+4*f(x+d*.5)+f(x+d))*d/6.)
NO_ANIMATION = 1
delta = 0.2
plot [-5:5] f(x) title "f(x)=exp(-x**2)",   2/sqrt(pi)*integral_f(x) title "erf(x)=2/sqrt(pi)*integral_f(x)"
#+end_src

value_sequence example call for the ~seq-array~ function, creating a list of sequence arrays:
#+begin_src scheme :noweb yes :results value
  <<sequenced_array>>
  (seq-array-reciprocal 0 10 (list))
#+end_src

**** shift list
Shift items in a list and resturn a list of lists, all items shifted by one.

Functions:
  - duplicate-shift /rows list newlist/: take a list a duplicated it while shifting it one step to the right.
  - make-shift-list /rows list . flag/: utility function that calls duplicate-list. If ~flag~ is supplied with a value of 1 a non-shifted list is generated.
    #+name: shift_list
    #+begin_src scheme
      (define duplicate-shift
        (lambda (n lst newlst)
          (cond ((= 0 n) newlst)
                ((duplicate-shift (- n 1) 
                                  (append (cdr lst) (list (car lst)))
                                  (append newlst (list (append (cdr lst) (list (car lst))))))))))
      
      (define make-shift-list
        (lambda (rows lst . flag)
          (let ((flag (if (pair? flag) (car flag) 0)))
            (cond ((= flag 1) (duplicate-shift rows lst (list lst)))
                  ((= flag 0) (make-list rows lst))))))
    #+end_src

    Example use of [[*shift list][shift list]] using [[*value sequence][value sequence]]. The latter creates an array of numbers that is duplicated and shifted to the right
    #+begin_src scheme :noweb yes
      <<sequenced_array>>
      <<shift_list>>
      (make-shift-list 4 (seq-array 0 5 (list)) 1)
    #+end_src

    Example use of shift list and sine mapping, not relying on ~value_sequence~.
    #+begin_src scheme :noweb yes
      (define lst (iota 5))
      <<shift_list>>
      (duplicate-shift 3 (map (lambda (x) (sin (* 0.1 x))) lst) (list (list)))
    #+end_src

**** unused
#+begin_src scheme
  <<shift_list>>
  
  (define seq-array
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array (+ i 1) n
                     (append x (list
                                (/ 1 (+ 1.0 i))))))))
  
  (define shifted-seq (duplicate-shift 10 (seq-array 0 10 (list)) (list (seq-array 0 10 (list)))))
  
  (define repeats
    (lambda (n lgth items x)
      (if (= n items)
          x
          (repeats (+ n 1) lgth items
                   (append x (list
                              (format #f "Pseq([~{~a, ~}], inf)"
                                      (list-ref shifted-seq n))))))))
#+end_src

Generate a list of increasing values, 0-lgth
#+name: value_list
#+begin_src scheme :var lgth=10
  (define valuelist
    (lambda (i n x)
      (if (= i n)
          x
          (valuelist (+ i 1) n (append x (list (format #f "Pseq([~d], inf)" (+ i 1))))))))
  (valuelist 0 lgth (list))
#+end_src

*** pulse modulation
Function to create an array of arrays for pulse modulation using the sclang function [[interpolate_busses][interpolate_busses]]. The first three scheme functions generate the lists of frequency start value (~harmony-start~), end value (~harmony-end-reciprocal~) and interpolation time (~make-timer-log~) respectively. Alternate functions can be constructed for different effects.

The actual distribution for ~harmony-end-reciprocal~ can be plotted with:
#+begin_src gnuplot :file output.png 
  set xrange [0: 20]
      plot 100 * 1 / (x+1) * 40
#+end_src

And similarily for ~make-timer-log~:
#+begin_src gnuplot :var multi=14 :file timer-log.png
  set xrange [0: 20]
  plot (log (x+1)) / log(multi)
#+end_src

#+name: transfer_functions
#+begin_src scheme :var size=20 fundamental=50 r=0.5 multiplier=30 :results output
  (use-modules (ice-9 format))
  
  (define interpolate "~interpolatePulse.value(Array2D.fromArray(")
  (define interpolate_end "]));")
  
  (define harmony-start
    (lambda (n x)
      (if (= n size)
          x
          (harmony-start (1+ n) (append x (list (* fundamental (1+ n))))))))
  
  (define harmony-end-reciprocal
    (lambda (n x)
      (if (= n size)
          x
          (harmony-end-reciprocal (1+ n) (append x (list (* (* fundamental (/ 1 (1+ n))) 40)))))))
  
  (define make-timer-log
    (lambda (n x m)
      (if (= n size)
          x
          (make-timer-log (1+ n) (append x (list (* (/ (log (+ n 1)) (log size))) multiplier)) multiplier ))))
  
  (define combine-lists
    (lambda (one two three x)
      (if (null? one)
          x
          (combine-lists (cdr one) (cdr two) (cdr three)
                         (append x (list (car one) (car two) (car three)))))))
  #+end_src

#+begin_src scheme :results results
    (harmony-start 0 '())
#+end_src

**** full list function
#+begin_src scheme :var size=20 fundamental=50 r=0.5 multiplier=30 :results output code :wrap "src sclang" :noweb yes
  <<transfer_functions>>
  (define (format-array lst)
    (display interpolate)
    (format #t "~a, 3, [" size)
    (map (lambda (x) (format #t "~a, " x)) lst)
    (display interpolate_end))
  
  (format-array 
   (combine-lists
    (harmony-start 0 '())
    (reverse (harmony-end-reciprocal 0 '()))
    (make-timer-log 0 '() 20)
    '()))
#+end_src

**** partial list function
#+begin_src scheme :var size=14 fundamental=0.5 r=0.5 multiplier=20 :results output code :wrap "src sclang" :noweb yes
  (use-modules (ice-9 format))
  
  (define interpolate "~interpolatePulse.value(Array2D.fromArray(")
  (define interpolate_end "]));")
  
  (define harmony-start
    (lambda (n x)
      (if (= n size)
          x
          (harmony-start (1+ n) (append x (list (* fundamental (1+ n))))))))
  
  (define harmony-end-reciprocal
    (lambda (n x)
      (if (= n size)
          x
          (harmony-end-reciprocal (1+ n) (append x (list (* (* fundamental (/ 1 (1+ n))) 40)))))))
  
  (define make-timer-log
    (lambda (n x)
      (if (= n size)
          x
          (make-timer-log (1+ n) (append x (list (+ (* (/ (log (+ n 1)) (log size)) multiplier) 2)))))))
  
  (define combine-lists
    (lambda (one two x)
      (if (null? one)
          x
          (combine-lists (cdr one) (cdr two)
                         (append x (list (car one) (car two)))))))
  
  (define (format-array lst)
    (display interpolate)
    (format #t "~a, 2, [" size)
    (map (lambda (x) (format #t "~a, " x)) lst)
    (display interpolate_end))
  
  (format-array 
   (combine-lists
    (reverse (harmony-end-reciprocal 0 '()))
    (make-timer-log 0 '())
    '()))
#+end_src

**** panning function
#+begin_src scheme :var size=10 :results output code :wrap "src sclang" :noweb yes
  (use-modules (ice-9 format))
  
  (define pre "setSpatPositions.value(")
  (define paren "[")
  (define end "])")
  
  (define (format-array lst)
    (display pre)
    (display paren)
    (map (lambda (x) (map (lambda (y) (format #t "~a, " y)) x)) lst)
    (display end))
  
  (format-array '((1 2 3) (4 5 6)))
#+end_src

#+begin_src scheme :results results
(map (lambda (y) y) x)
#+end_src

#+begin_src scheme
  (format-array 
   (combine-lists
    (reverse (harmony-end-reciprocal 0 '()))
    (make-timer-log 0 '())
    '()))
#+end_src

#+begin_src scheme :results results
  (combine-lists '(1 2 3) '(4 5 6) '(7 8 9) '())
  
#+end_src

** free busses
#+name: free_busses
#+begin_src sclang :results none
  ~freeAllBusses = {
    var int = 0;
    if(~audioBusses.isNil && ~audioBusses.size == 0 ,
          { "Array is empty".postln },
          {
            while({ int < ~audioBusses.size }, {
                  if(~audioBusses[int].index == nil,
                    { "Bus cleared already".postln; },
                    {		
                          "Clearing bus ".post; ~audioBusses[int].index.postln;
                          ~audioBusses[int].free;
                          /* Fix these. Should not be cleared unless intantiated */			
                          ~frequencyBus[int].free;			
                          ~controlBus[int].free;
                          ~synths[int].free;
                          /* Fix */			
                    });		
                  int = int + 1;
            });
          })
  };
  ~freeAllBusses.value();

  ~freeNdefs = {
    Ndef.clear(0);
    ~spatNdefsAmbi.clear;
  };
  ~freeNdefs.value();
#+end_src
** alternative stuff
Interpolate over pan values by means of Task
#+name: interpolator
#+begin_src sclang :results none 
  ~interpolator = { arg instance = 0, range = (0..180), delta = 0.05, param = \azi;
	 var interpolate;
	 interpolate = Task({
	  range.do({ arg index;
		 p = index;
		 ~spatNdefs[instance].set(param, p);
		 delta.wait;	
	  });
	 });
	 interpolate;
  };
#+end_src

Set all channels' panning positions using the Task above.
#+begin_src sclang :results none
  ~spatNdefs.do({ arg channel, i;
	 var ae, as, es = 0, ee = 1;
	 as = channel.get(\azi);
	 es = channel.get(\ele);
	 ae = ~spatializations[i][0];
	 ~interpolator.value(i, (as..ae), 0.1, \azi).play;
	 ~interpolator.value(i, (es..ee), 0.1, \ele).play;
	 //"Angles are set to ".post; ae.postln;
	 channel.set(\ele, ~spatializations[i][1]);
  });
#+end_src

Example calls for the ~~interpolator~ function.
#+begin_src sclang :results none
  q = ~interpolator.value(0, (0..180), 0.1).play;
  p = ~interpolator.value(1, (180..0), 0.1).play;
#+end_src

Fill the ~~spatializations~ array with random indexes.
#+begin_src sclang :results none :noweb yes
  var delta = 0.5;
  Task({
	 (1..64).do({ arg index;
	  var ~spatPositions =  Array.rand(12, 0, 13);
	  ~spatializations.do({ arg item, i;
		 ~spatializations.put(i, ~allRings[~spatPositions[i]]);
		 "Putting ".post;  ~spatPositions[i].post; " at index ".post; i.postln;
	  });
	  ~spatChannels.do({ arg channel, i;
		 channel.set(\ele, ~spatializations[i][0], \ele, ~spatializations[i][1]);
	  });
	  delta.wait;	
	 });
  }).play;
#+end_src

#+begin_src sclang :results none
  ( // change the bounds to become vertical
  w = Window.new.front;
  c = NumberBox(w, Rect(20, 20, 150, 20));
  a = Slider(w, Rect(200, 60, 20, 150))
  .value_(0.5)
  .action_({
    c.value_(a.value)
  });
  a.value_(1);
  a.action.value;
  )
#+end_src
