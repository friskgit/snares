#+STARTUP: indent overview hidestars
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

* TODO Things to do
- [ ] Implement distance in panning with reverb
- [ ] Glue \nlevel to \pulse
* Settings comments
** Full slow texture
Starting the \harmonics mode with \full amplitude setting, ~~fundamental~ at 0.2 and default panning is very nice. Run
#+begin_src sclang :results none
~~interpolatePulse.value(~modulateSpeed.value(10, 40, 3, \linear));~ 
#+end_src
twice and then ~~pulsePresets.value(6);~ in <<pulse_resets>> 

* harmony
** harmonic spat synth
_1. Start here_
Set the parameters in [[generate_harmonics][generate_harmonics]] for the synthesis.

#+call: generate_harmonics()
#+call: make_vbap()
#+call: init_spatialization()
#+call: load_reverb()
#+call: show_meter()
#+call: free_all()
#+call: reboot()

*** boot audio
Set JackRouter to be the interface on Linux
#+name: boot_jack
#+begin_src sclang :results none
  (
  o = Server.local.options; // Get the local server's options
  o.numOutputBusChannels = 64;
  o.numWireBufs = 128;
  o.memSize  = (65536 * 4);
  //     s.makeWindow;
  s.makeGui(p);
  s.boot;
  )
#+end_src

*** list of global variables
     Global variables and semaphhores

     - ~~fundamental~  The fundamental pitch from which harmonics are built
     - ~~alllRings~  General XY positions of the centerrs of the triangles.
     - ~~spatializations~  List of the positions for each ~~audioBus~ that may be updated.
     - ~~spatChannels~ Array of Ndefs, channels of VBAP panners  (same size as ~audioBusses~
     - ~~spatNdefs~ 
     - ~~controlBus~ 
     - ~~frequencyBus~  The bus through which the frequency of the impulse is controlled (the \pulse)
     - ~~audioBusses~ The channels that outputs audio from the synth.
     - ~~spatPositions~ An array of initial spat positions, identified by a reference to the ~allRings~ array.

     #+name: global_variables
     #+begin_src sclang :results none
       /* Which space? */
       ~space = 1;
       /* Fundamental frequency */
       ~fundamental = 1;
       /* The general level of loggging */
       ~logging = 2;
       /* Spatialisation positions */
       ~allRings = [[-24.036688, 23.800417, 0.0, 0.0], [21.279257, 23.800417, 0.0, 0.0], [55.741675, 23.800417, 0.0, 0.0], [101.49442, 23.800417, 0.0, 0.0], [147.91193, 23.800417, 0.0, 0.0], [-167.82013, 23.800417, 0.0, 0.0], [ -123.784, 23.800417, 0.0, 0.0], [-79.887731, 23.800417, 0.0, 0.0], [ 0.247203, 56.476405, 0.0, 0.0], [69.013292, 56.476405, 0.0, 0.0], [158.89992, 56.476405, 0.0, 0.0], [-114.65354, 56.476405, 0.0, 0.0], [-90, 86.424489, 0.0, 0.0], [90, 86.424489, 0.0, 0.0], [0, 90, 0.0, 0.0]];
       /* Separator */
       ~separator = "-----------------------------------";
     #+end_src
     
**** spkrBuffer settings
 The argument to ~VBAPSpeakerarray~ is ~3~ for 3D and an array of arrays of angle/elevation pairs:
 #+name: vbap_speaker_array
 #+begin_src sclang :results none :tangle harmony.sc
   if(~space == 0,
     {
           /* Lilla salen */
           "Loading Lilla salen".postln;
           ~spkrArray = VBAPSpeakerArray.new(3, [[ -34.689614 , 12.910417 ], [ -13.383763 , 12.910417 ], [ 10.440725 , 12.910417 ], [ 32.117788 , 12.910417 ],
             [ 55.741675 , 12.910417 ], [ 78.207673 , 12.910417 ], [ 101.49442 , 12.910417 ], [ 124.85167 , 12.910417 ],
             [ 147.91193 , 12.910417 ], [ 169.17789 , 12.910417 ], [ -167.82013 , 12.910417 ], [ -145.63454 , 12.910417 ],
             [ -123.784 , 12.910417 ], [ -102.64182 , 12.910417 ], [ -79.887731 , 12.910417 ], [ -57.926139 , 12.910417 ],
             [ -22.349553 , 34.696822 ], [ 22.843958 , 34.696822 ], [ 69.013292 , 34.696822 ], [ 115.56544 , 34.696822 ],
             [ 158.89992 , 34.696822 ], [ -158.89763 , 34.696822 ], [ -114.65354 , 34.696822 ], [ -68.170128 , 34.696822 ],
             [ -45 , 69.185799 ], [ 45 , 69.185799 ], [ 135 , 69.185799 ], [ -135 , 69.185799 ], [ 0 , 90 ]]);
           ~spkrArray.speakers[1].dump;
           ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
     },
     {
           /* 1D114 */
           "Loading 1D114".postln;
           ~spkArray = VBAPSpeakerArray.new(3, [[24.6, 0], [ 0, 0], [-26.34, 0], [-58.7, 0], [-106, 0], [-129.35, 0], [129.35, 0], [106, 0], [58.7, 0], [45, 18], [-45, 18], [-135, 18], [135, 18], [0, 90]]);
           ~spkArray.speakers[1].dump;
           ~spkrBuffer = Buffer.loadCollection(s, ~spkrArray.getSetsAndMatrices);
     });
 #+end_src
 
*** synth
#+name: harmonic_synth
#+begin_src sclang :results none
  (
  SynthDef("test", { arg freq = 440, out = 10, amp = 0.2;
    Out.ar(out, SinOsc.ar(freq, 0, amp));
  }).add;
  );
#+end_src

Main snare synth. The pulse parameter is controlled by the ~pulse_bus~
#+name: snare_phase_multi
#+begin_src sclang :results none
  ~phased_snare = SynthDef(\p_snare, { arg pulse_bus;
    var snd,
    pulse = \pulse.kr(10),
    frq1 = \freq.kr(300),
    frq2 = \freq2.kr(300),
    trifreq = pulse * 3,
    nlevel = LinLin.kr(pulse / 120, 0, 1, 0.1, 0.001) * \noiseScale.kr(1.0);
    snd = ISnarePhase.ar(pulse, \amp.kr(0.5), \attack.ir(0.00001), \fsweep.kr(0), \nattack.kr(0.001), nlevel, \nrel.kr(0.1), frq1, frq2, \rel.kr(0.1), trifreq);
    Out.ar(\out.kr(0), snd * \gain.kr(0.5));
  }).add;
#+end_src

#+begin_src sclang :results none
  b = Bus.control(s,1).set(10);
  c = Synth.new(\p_snare, [\freq, [100, 200]]);
  c.map(\pulse, b);
  b.set(810);
  b.get.postln;
#+end_src

#+begin_src sclang :results none
~synths[0].set(\noiseScale, 0);
#+end_src

#+begin_src sclang :results none
~synths[0].set(\rel, 0.3);
#+end_src

*** harmonics function
Initialize the arrays for freq/amp for the first 32 harmonics and create audio busses for each item in the sel array. Loads the synth [[*simple synth][harmonic_synth]] and [[snare_phase_multi][snare_phase_multi]]. Select the synth by setting ~~synthMode~.

- ~fund~: Fundamental
- ~sel~: Array of partials to play
- ~delta~: time between notes (only init time)
- ~ampMode~: the relation between the amplitude of the notes in the array (~\default~, ~\full~, ~\linear~ or ~\reverse~)
- ~synthMode~: the synthesis model (~\sin~ or ~\snare~)

Variables:
- ~harmonics~ An array of harmonic frequencies
- ~amp~
- ~fbus~
- ~nmap~

Called by [[*generate harmonics][generate harmonics]].
#+name: harmonics
#+begin_src sclang :results none :noweb yes
  <<harmonic_synth>>
  <<snare_phase_multi>>
  /* Function called by generate_harmonics */
  ~harmonicsFactory = { arg fund=200, sel = [1,2,3], delta = 0.05, ampMode = \full, synthMode = \sin, ampScale = 1;
    
    var harmonics, amp, index = 0, fbus, nmap;
    
    /* Fill arrays for pitches */
    harmonics = Array.fill(32, { arg i; (i+1)*fund; });
    
    /* Fill arrays for amplitudes */
    switch(ampMode,
          \default, {amp = Array.fill(32, { arg i; 1/(i+1) * ampScale; }); },
          /* All harmonics with the same amplitude */	
          \full, {amp = Array.fill(32, { arg i; 0.3 * ampScale; });  },
          /* Linear amplitudes (1 / 32 * amp) */
          \linear, {amp = Array.series(32, 1 * ampScale, -0.03125)},
          /* Linear amplitudes reversed (highest pitch has max amplitude) */
          \reverse, {amp = Array.series(32, 0.03125 * ampScale, 0.3125)}
    );	
    
    "Amp array is loaded: ".postln;
    amp.postln;
    
    "Harmonics are loaded:".postln;
    harmonics.postln;
    "".postln;
    ~separator.value.postln;
    
    /* Frequency (pulse) control using a Bus */
    ~frequencyBus = Array.new(sel.size);
    
    /* Run the loop */
    t = Task({
          (0..31).do({ |i|
            var audioBus, synth;
            if(i == sel[index],
                  {
                    "i value is ".post; i.postln;
                    /* audio bus for output */		
                    audioBus = Bus.audio(s, 1);
                    ~audioBusses.add(audioBus);
                    
                    /* Control bus for freq control */
                    fbus = Bus.control(s, 1);
                    fbus.value(harmonics[i]);		
                    ~frequencyBus.add(fbus);
                    ~originalFrequencies.add(harmonics[i]);
                    "pulse: ".post; harmonics[i].postln;
                    ~separator.value.postln;    
                    "".postln;
                    switch(synthMode,
                          \sin, {			
                            synth = Synth("test", [\pulse, harmonics[i], \amp, amp[i], \out, audioBus]);
                          },
                          \snare, {
                            synth = Synth.new(\p_snare, [
                                  \bus, fbus,
                                  \pulse, harmonics[i],
                                  \length, 1,
                                  \freq, harmonics[i]/2,
                                  \freq2, harmonics[i]/3,
                                  \trifreq, harmonics[i]/4,
                                  \noiseScale, 0.8,
                                  \out, audioBus,
                                  \gain, amp[i]]);
                            synth.map(\pulse, fbus);
                          }); //switch
                    
                    if(~logging > 0,
                          {			
                            Post << "Harmonic " <<< i << ": " <<< harmonics[i] <<  ", " <<< amp[i] <<< " at Audio bus " <<< audioBus.index << Char.nl;
                            index = index + 1; i.postln;
                            ~separator.value.postln;    
                          },
                          { }); //if
                    ~synths.add( synth ); // synths.add
                  }, //if true
                  {  }); // false, end
            delta.wait;
          });
    });
    /* Return the task */
    t;
  };
#+end_src
End of harmonics.

#+begin_src sclang :results none
  ~synths[0].get(\freq).postln;
#+end_src

Unused function to map frequency to noise level
#+name: noise_map
#+begin_src sclang :results none
  ~noiseMap = { arg val;
	 ~noiseMapSpec.map(val / 120).postln
  };
  ~noiseMap.value(119);
#+end_src

ControlSpec for the mapping between frequency and noise level
#+name: noise_mapping_spec
#+begin_src sclang :results none
  ~noiseMapSpec = ControlSpec(0.1, 0.0, \linear, 0.001, 0);
  ~noiseMapSpec.clipHi(0.1);
  ~noiseMapSpec.clipLo(0);
#+end_src

*** reverb
Load reverb
#+name: load_reverb
#+begin_src sclang :results none :noweb yes
  <<reverb_ndef>>
  <<reverb_specs>>
  <<reverb_panning>>
  <<connect_reverb>>
#+end_src

#+name: reverb_specs
#+begin_src sclang :results none
  Spec.add(\t60, [0.1, 60, \exp]);
  Spec.add(\damp, [0, 1]);
  Spec.add(\size, [0.5, 3]);
  Spec.add(\earlydiff, [0, 1]);
  Spec.add(\mdepth, [0, 50]);
  Spec.add(\mfreq, [0, 10]);
  Spec.add(\lowx, [0, 1]);
  Spec.add(\midx, [0, 1]);
  Spec.add(\highx, [0, 1]);
  Spec.add(\lowband, [100, 6000, \exp]);
  Spec.add(\highband, [1000, 10000, \exp]);
#+end_src

Load the reverb
#+name: reverb_ndef
#+begin_src sclang :results none
  Ndef(\reverb, {
    var src = In.ar(~reverbSendBus.index) * \amp.kr(1);
    src = JPverb.ar(    
      src,
      \t60.kr(1, 0.05),
      \damp.kr(0,0.05),
      \size.kr(1,0.05),
      \earlydiff.kr(0.707, 0.05),
      \mdepth.kr(5,   0.05),
      \mfreq.kr(2,    0.05),
      \lowx.kr(1,0.05),
      \midx.kr(1,0.05),
      \highx.kr(1,    0.05),
      \lowband.kr(500,0.05),
      \highband.kr(2000,   0.05)
    );
  });
#+end_src

Reset the two example Ndefs
#+begin_src sclang :results none
  Ndef(\reverb).clear;
  Ndef(\reverbPanning).clear;
#+end_src

#+name: reverb_panning
#+begin_src sclang :results none
  Ndef(\reverbPanning, {
	 var src = \input.ar;
	 PanX.ar(16, src, \revPanPos.kr(0), \revPanAmp.kr(1), \revPanSpread.kr(64));
  }).mold(16);
#+end_src

Connect the source to the reverb.
#+name: connect_reverb
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 1;
  Ndef(\reverbPanning).play(addAction: \addToTail);
  Ndef(\reverbPanning) <<>.input Ndef(\reverb);
  Ndef(\reverb).set(\t60, 0.7);
  Ndef(\reverb).set(\size, 0.2);
  Ndef(\reverb).set(\amp, 0.5);
  Ndef(\reverb).set(\earlydiff, 0.1);
  Ndef(\reverb).set(\mdepth, 1);
  Ndef(\reverbPanning).set(\revPanSpread, 64);
#+end_src

Start the two Ndefs (and stop)
#+begin_src sclang :results none
  Ndef(\reverb).fadeTime = 5;
  Ndef(\reverbPanning).play;
  Ndef(\reverbPanning).stop;
  Ndef(\reverb).play;
  Ndef(\reverb).stop;
  Ndef(\reverbBus).play;
  Ndef(\reverbBus).stop;
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).set(\revPanSpread, 64);
  Ndef(\reverbPanning).set(\revPanAmp, 0.7);
#+end_src

#+begin_src sclang :results none
  Ndef(\reverbPanning).scope;
#+end_src

*** generate harmonics                                             :export:
Initialize global variable ~~allRings~. Loads and calls the function defined in [[*harmonics function][harmonics function]] and plays it. The ~sel~ array defines the partials to be played. If this is three items long, the array of corresponding synths initatilzed in [[*harmonics function][harmonics function]] will be three.

After calling this, call [[*spatialisation][spatialisation]]: make_vbap to play the busses on the speakers.

- ~select~: The harmonics to play
- ~~spatPositions~: The angles for each audio bus (needs to be of equal length to ~sel~). These are initialized at the same time that the partials are selectd.

_1. Load this_

Function that loads [[global_variables][global_variables]] and [[harmonics][harmonics]]. It also initializes the ~~spatialisations~ array. The main settings for the are set here:
- ~selct~
- ~task~
- ~mode~ \harmony, \dual
- ~ampMode~ \default, \full, \linear, \reverse
- ~synthesis~ \synth or \sin
#+name: generate_harmonics
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  (
  var select, task,
  mode = \dual,
  ampMode = \full,
  synthesis = \snares;
  
  <<global_variables>>
  <<harmonics>>
  
  ~fundamental = 2;
  
  switch(mode,
    \harmony, {
          select = [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31];
          ~spatPositions = [0,1,5,6,3,2,7,4,9,11,8,10,12,13,14];
          "Full mode".postln;		
    },
    \odd, {
          select = [0,1,3,5,7,9,11,13,15,17,19,21,23,25,27];
          ~spatPositions = [0,1,5,6,3,2,7,4,9,11,8,10,12,13,14];
          "Full mode".postln;		
    },
    \single, {
          select = [1];
          ~spatPositions = [0];
          "Single mode".postln;		
    },
    \quart, {
          select = [2,3,5,7];
          ~spatPositions = [0,4,10,12];
          "Quart mode".postln;		
    },
    \dual, {
          select = [2,3];
          ~spatPositions = [0,4];
          "Dual mode".postln;	
    }); // switch mode
  
  if(~logging > 1,
    {
          "Length of select array is ".post; select.size.postln;
          "Length of spat array is ".post; ~spatPositions.size.postln;
          ~separator.postln;
    },
    { }); //if clause
  
  /* Holds the busses */
  ~audioBusses = Array.new(select.size);
  /* Holds the synths */
  ~synths = Array.new(select.size);
  /* Holds the original frequency for each bin */
  ~originalFrequencies = Array.new(select.size);
  /* Holds the spat positions for each note, imported from ~allRings */
  ~spatializations = Array.new(~spatPositions.size);
  
  if(select.size == ~spatPositions.size,
    {
          if(~allRings.size >= ~spatPositions.size,
            {	
                  i = 0;	
                  while( {i < ~spatPositions.size},
                    { ~spatializations.add(~allRings[~spatPositions[i]]);
                          if(~logging > 1,
                            { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; },
                            { }); // if clause
                          i = i + 1;
                    }); // while clause
            }, { }); // if clause
    },
    { "'sel' and 'spat' have unequal number of elements".postln; }); // if clause
  
  /* Call the harmonics function and play it.*/
  task = ~harmonicsFactory.value(~fundamental, select, 0.1, \linear, \snare, 0.3);
  task.play;
  )
#+end_src
End of /generate_harmonics/

Use this to re-initialize the spatialisations array. 
#+name: reinit_spatialisations
#+begin_src sclang :results none
  if(~allRings.size >= ~spatPositions.size,
    {	
          i = 0;	
          while( {i < ~spatPositions.size},
            { ~spatializations.add(~allRings[~spatPositions[i]]);
                  if(~logging > 1,
                    { "Loading spat position ".post; i.post; ":".post; ~allRings[~spatPositions[i]].postln; },
                    { }); // if clause
                  i = i + 1;
            }); // while clause
    },
    { }; // if clause
  );
#+end_src

*** pulse modulation
Build an array of arguments for the interpolation of the pulse frequence of the instruments. This is always relative to the current pulse frequency. Arguments are:
- ~mult~ multiplier for each iteration in the array
- ~duration~ the duration of the interpolation
- ~end~ end value (only for mode 1)
- ~mode~ the mode of the transformation: ~\inharmonic~: modulation map using the index and multiplier, ~\change~: linear map using end value for the modulation for all  voices, ~\harmonic~: symetric transformation, ~\ratio~: a transformation by ratio.
- ~ratio~ the ratio to set the transformation to (e.g. 5/6)

#+name: pulse_interpolate_array
#+begin_src sclang :results none :noweb yes
  <<interpolate_busses>>
  <<pulse_modulation>>
  //  ~interpolatePulse.value(~modulateSpeed.value(0.9, 2, 300, \change, [3,5]));
  ~modulateSpeed.value(2, 0.1, 512, \harmonic, [3,5]);
#+end_src

Create an array of arrays, each with a start, end and dur parameter.
#+name: pulse_modulation
#+begin_src sclang :results none
  ~modulateSpeed = { arg mult = 2, dur = 2, end = 100, mode = \multi, ratio = [2,3];
    var mod_map = Array2D.new(~spatNdefs.size, 3), lower = 0;
    ~spatNdefs.size.postln;
    mod_map.rowsDo({ arg obj, i;
          mod_map[i,0] = ~frequencyBus[i].getSynchronous;
          switch(mode,
            \inharmonic, { mod_map[i,1] = ~frequencyBus[i].getSynchronous * mult; },	
            \change, { mod_map[i,1] = end; },
            \harmonic, { mod_map[i,1] = mod_map[i,0] * mult * (i + 1); },
            \ratio, { if(i == 0,
                  { mod_map[i,1] = ratio[0] * mult; },
                  { mod_map[i,1] = ratio[1] * mult; });
            },
            \altratio, {
                  lower = ~frequencyBus[0].getSynchronous;
                  if(i == 0,
                    { 
                          mod_map[i,1] = lower * ratio[0];},
                    { /*rel = ratio[1] / ratio[0]; */
                          mod_map[i,1] = lower * ratio[1]; });
            };
          );
          mod_map[i,2] = dur;
    });
    mod_map.postln;
    ~interpolatePulse.value(mod_map);
  };
  
#+end_src

Interpolate all busses. Call this from [[pulse_interpolate_array][pulse_interpolate_array]], that creates an array of values for pulse modulation and interpolation or from the [[pulse_presets][pulse_presets]]. The function takes one argument: an array with start, end and duration.
- ~map~: An array with start, end and duration values.
#+name: interpolate_busses
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulse = { arg map;
    map.rowsDo({ arg obj, i;
          if(~logging > 1,
            { 
                  "Starting envelope for item ".post; i.post; " from ".post; obj[0].post; " to ".post; obj[1].post; " in ".post; obj[2].post; " seconds.".postln;						
            }, { });
          {Out.kr(~frequencyBus[i], Line.kr(obj[0], obj[1], obj[2], doneAction: 2))}.play(addAction: \addToHead);
    });
    //  map;
  };
  /* Interpolate all busses by the same value */
  // ~interpolatePulse.value(10, 1, 10);
#+end_src

#+begin_src sclang :results none
  ~frequencyBus[1].getSynchronous.postln;
  ~synth[0].get(\noiseScale, 0);
#+end_src

Gradually increase parameter in one synth. 
#+begin_src sclang :results none
  var speeder;
  speeder = { arg instance = 0, range = (3..200), delta = 0.5, param = \freq;
	 var interpolate;
	 interpolate = Task({
	  range.do({ arg index;
		 ~synths[0].set(param, index);
		 delta.wait;	
	  });
	 });
	 interpolate.play;
  };
  speeder.value(0, (200..100), 0.05, \freq);
#+end_src

Set synth parameters
#+name: set_synth
#+begin_src sclang :results none
  ~setSynth = { arg instance = 0, param = \noiseScale, val = 0;
    ~synths[instance].set(param, val);
  }
#+end_src

#+begin_src sclang :results none
~setSynth.value(1, \gain, 1);
#+end_src

Interpolate one pulse bus.
#+name: interpolate_pulse
#+begin_src sclang :results none  :tangle harmony.sc
  ~interpolatePulseSingle = { arg int, bus, astart, aend, dur;
	 {Out.kr(bus, Line.kr(astart, aend, dur, doneAction: 2))}.play(addAction: \addToHead);
  };
  ~interpolatePulseSingle.value(0, ~frequencyBus[0], 10, 1, 10);
#+end_src

Create an array and interpolate the pulse frequence of the instruments. The arrays should be in the form of [ start_posistion, end_position, duration ] (one such array per channel). All of these are for \dual mode, i.e. two voices.
#+name: pulse_presets
#+begin_src sclang :results none :noweb yes
  <<pulse_modulation>>
  <<interpolate_pulse>>
  ~pulsePresets = { arg preset = 1;
    switch(preset,	
          1, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [100, 10, 5, 200, 20, 8]));
          },
          2, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [12, 15, 20, 20, 20, 2]));
          },
          3, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 6, 1]));
          },
          4, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 1, 1, 4, 1]));
          },
          5, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 5, 1, 1, 6]));
          },
          6, {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [2, 32, 30, 1.5, 24, 30]));
            ~setSpatialization.value(\nther, 20);   
          },  
          7,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 2, 20, 2, 1.5, 15]));
            ~setSpatialization.value(\sine, 15);
          },
          8,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [6, 100, 40, 2, 160, 45]));
            ~setSpatialization.value(\sine, 40);
          },
          9,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [100, 200, 40, 160, 6, 45]));
            ~setSpatialization.value(\simple, 40);
          }, 
          10,  {
            ~interpolatePulse.value(Array2D.fromArray(2, 3, [1, 5, 5, 20, 2, 2]));
            ~setSpatialization.value(\simple, 5);   
          };	
    ) // switch
  };
  ~pulsePresets.value(1);
#+end_src

Set and get a bus' value:
#+begin_src sclang :results none
  ~frequencyBus[1].getSynchronous.postln;
#+end_src

Reset original pulse frequencies.
#+name: reset_freqs
#+begin_src sclang :results none
  ~reset_freqs = { arg index = 0, mode = \all;
  
	 if( (index != 0) && (mode == \all),
	  {
		 "If mode is = \all, index must be 0".postln;
		 index = 0;
	  }, { });
  
	 switch(mode,
	  \all, {
		 ~frequencyBus.do({ arg bus, i;
		  "Setting voice ".post; i.post; " to original frequency: ".post; ~originalFrequencies[i].postln;
		  ~frequencyBus[i].set(~originalFrequencies[i]);
		 });
	  },
	  \single, {
		 "Setting voice ".post; index.post; " to original frequency: ".post; ~originalFrequencies[index].postln;
		 ~frequencyBus[index].set(~originalFrequencies[index]);
	  });
  };
  ~reset_freqs.value(0, \all);
#+end_src

#+begin_src sclang :results none
  ~originalFrequencies[0].postln;
#+end_src

*** spatialization
Spatialisation angles for three rings in triangles.

_2. Load this_
Call this after running [[*generate harmonics][generate harmonics]] to start the spatialisation of the harmonics. It creates the VBAP instances (inside a Ndef) stored in ~~spatNdefs~. It also fills the ~~controlBus~ array with three channel busses for the control of azimuth, elevation and distance respectively.

The functions controlling panning are here: [[inter_pan][inter_pan]].
#+name: make_vbap
#+begin_src sclang :results none :noweb yes :tangle harmony.sc
  var revMap;
  
  <<vbap_speaker_array>>
  ~spatChannels = Array.new(~audioBusses.size); // Unused
  ~spatNdefs = Array.new(~audioBusses.size);
  ~reverbSendNdefs = Array.new(~audioBusses.size);
  ~reverbBus = Array.new(~audioBusses.size);
  ~controlBus = Array.new(~audioBusses.size);
  ~reverbSendBus = Bus.audio(s, 1);
  revMap = \sin.asWarp;
  ~audioBusses.do({ arg bus, i;
    o = "reverbBus" ++ i.asString.asSymbol;
    m = "ch" ++ i.asString.asSymbol;
    n = Bus.control(s, 4);
    ~controlBus.add(n);
    if(~space == 0,
          {
            ~spatNdefs.add(
                  Ndef.new(m, { arg src, azi = 0, ele = 0, spr = 0, dist = 0;
                    src = In.ar(bus);
                    azi = In.kr(n);
                    ele = In.kr(n.index + 1);
                    dist = LinLin.kr( In.kr(n.index + 2).cubed, 0, 1, 0.0001, 1);
                    spr = LinLin.kr( In.kr(n.index + 3), 0, 100, 1, 100);
                    src = src * dist;
                    VBAP.ar(29, src, ~spkrBuffer.bufnum, In.kr(n), In.kr(n.index + 1), spr)});
            );
          },
          {
            ~spatNdefs.add(
                  Ndef.new(m, { arg src, azi = 0, ele = 0, spr = 0, dist = 0;
                    src = In.ar(bus);
                    azi = In.kr(n);
                    ele = In.kr(n.index + 1);
                    dist = LinLin.kr( In.kr(n.index + 2).cubed, 0, 1, 0.0001, 1);
                    spr = LinLin.kr( In.kr(n.index + 3), 0, 100, 1, 100);
                    src = src * dist;
                    VBAP.ar(14, src, ~spkrBuffer.bufnum, In.kr(n), In.kr(n.index + 1), spr)});
            );
          });  
    /* Using the same control for the reverb send level, as for the distance parameter
          in the spatialization control.
    ,*/
    ~reverbSendNdefs.add(
          Ndef(o, {
            var src;
            src = In.ar(bus) * In.kr(n.index + 2) * \revScaleI.kr(0.4);
            src = src * (revMap.map(In.kr(n.index + 2) + 1) * \revScaleii.kr(0.4));
            Out.ar(~reverbSendBus.index, src)
          });
    );
    Ndef(m).fadeTime(1);
    Ndef(m).play(addAction: \addToTail);
    Ndef(o).play(addAction: \addToTail);});
  <<inter_pan>>
  <<update_panning>>
  <<reset_freqs>>
#+end_src

#+begin_src sclang :results none
  //{ Line.ar(0, 1, 1).cubed; }.plot;
  f = { arg x=0;
    y = x*x*x;
    x.cubed.postln;
  };
  f.value(0.99);
#+end_src

#+begin_src sclang :results none
  { Line.ar(0, 1, 0.1).sqrt; }.plot(minval: nil, maxval: nil);
#+end_src

Function to start and stop individual nodes
#+name: play_control
#+begin_src sclang :results none
  var playControl = { arg index = 0, message = 0;
	 if(index < ~spatNdefs.size,
	  {
		 case
		 { message == \stop } { ~spatNdefs[index].stop; }
		 { message == \play } { ~spatNdefs[index].play; };
	  },
	  { 
		 "The index is outside of the size of thhe ~spatNdefs".postln;	
	  });
  };
  playControl.value(0, \play);
#+end_src

Set the reverb
#+begin_src sclang :results none
  var setMe = 0.62;
  ~reverbSendNdefs[0].set(\revScaleI, setMe);
  ~reverbSendNdefs[0].set(\revScaleII, setMe);
  ~reverbSendNdefs[1].set(\revScaleI, setMe);
  ~reverbSendNdefs[1].set(\revScaleII, setMe);
#+end_src

#+begin_src sclang :results none
  ~spatNdefs[1].set(\spr, 0);
#+end_src

Set individual controlbusses
#+begin_src sclang :results none
  ~controlBus[0].getnSynchronous(4)[3].postln;
  ~controlBus[0].setn([0, 23, -0.9, 50]);
#+end_src

Control individual synths pulse.
#+begin_src sclang :results none
  var pulse = 10, synth = 0;
  ~synths[synth].se(\pulse, 20);
  ~synths[synth].get(\pulse, {arg item; item.postln; });
#+end_src

Set all synths parameter to a value.
#+begin_src sclang :results none
  ~updateSynths = { arg parameter = \trifreq, value = 100;
	 var changeAll = ~synths.do({ arg item, i;
	  item.set(parameter, value);
	  "Setting ".post; parameter.post; " to ".post; value.postln;
	 });
  };
  ~updateSynths.value(\freq, 50);
#+end_src

Set all spatNdefs parameter to a value (Doesn't work)
#+begin_src sclang :results none
  ~updateVBAP = { arg parameter = \spr, value = 0;
	 var changeAll = ~spatNdefs.do({ arg item, i;
	  item.set(parameter, value);
	  "Setting ".post; parameter.post; " to ".post; value.postln;
	 });
  };
  ~updateVBAP.value(\spr, 0);
#+end_src

#+name: reboot
#+begin_src sclang :results none
  s.reboot;
#+end_src

#+name: scope_reverb
#+begin_src sclang :results none
  ~reverbSendBus.scope;
#+end_src

*** spatialization panning
#+begin_src sclang :results none
  ~updatePanning.value(5);
#+end_src

Function for generating the lines for the panning modulation using azimuth, elevation and distance.
#+name: inter_pan
#+begin_src sclang :results none  :tangle harmony.sc
  ~interPan = { arg bus, astart, aend, estart, eend, dstart, dend, sstart, send, dur;
    {Out.kr(bus.index, Line.kr(astart, aend, dur, doneAction: 2))}.play(addAction: \addToHead);
    {Out.kr(bus.index + 1, Line.kr(estart, eend, dur, doneAction: 2))}.play(addAction: \addToHead);
    {Out.kr(bus.index + 2, Line.kr(dstart, dend, dur, doneAction: 2))}.play(addAction: \addToHead);
    {Out.kr(bus.index + 3, Line.kr(sstart, send, dur, doneAction: 2))}.play(addAction: \addToHead);
    if(~logging > 1,
          {
            "Azimuth from ".post; astart.post; " to ".post; aend.postln;
            "Elevation from ".post; estart.post; " to ".post; eend.postln;
            "Distance from ".post; dstart.post; " to ".post; dend.postln;
            "Spread from ".post; sstart.post; " to ".post; send.postln;	   
          }, { });
  };
#+end_src

~update_panning~ is called to update panning positions in the ~spatNdefs~ arrays. The actual modulation happens in [[inter_pan_full][inter_pan]]. The function takes one argument:
- ~duration~: The interpolation time.
#+name: update_panning
#+begin_src sclang :results none :tangle harmony.sc :noweb yes
  ~updatePanning = { arg duration;
    ~spatNdefs.do({ arg channel, i;
          ~interPan.value(~controlBus[i],
            ~controlBus[i].getnSynchronous(3)[0], ~spatializations[i][0],
            ~controlBus[i].getnSynchronous(3)[1], ~spatializations[i][1],
            ~controlBus[i].getnSynchronous(3)[2], ~spatializations[i][2],
            ~controlBus[i].getnSynchronous(4)[3], ~spatializations[i][3], duration);
    }); // end of spatNdefs.do
  }; //end of function
#+end_src

#+begin_src sclang :results none
  ~controlBus[1].getnSynchronous(3)[0].postln;
#+end_src

#+begin_src sclang :results none
  ~spatializations[1][1].postln;
#+end_src

#+begin_src sclang :results none
  ~updatePanning.value(5);
#+end_src

#+begin_src sclang :results none
  // { Poll.kr(Impulse.kr(10), In.kr(~controlBus[0]), \test) }.play(s);
  ~controlBus[0].getnSynchronous(3)[0].postln;
  ~controlBus[0].getnSynchronous(3)[1].postln;
  ~controlBus[0].getnSynchronous(3)[2].postln;
#+end_src

_3 Setting spatialization_

Loads necesary auxilliary functions and copies over the positions according to the ~spat_array~ argument. If provided it should be an array (length equal to the number of spat channels) of arrays, each of which is an array with [pos(azimuth, elevation), distance and spread]. It calls ~~updatePanning~ before exiting. The function takes two arguments:
- ~spat_array~: An array2d of arrays with he indexes in the ~~allRings~ array to be copied over, the distancs and the spread.
- ~duration~: The time for the transformation.
#+name: set_spatialization
#+begin_src sclang :results none :noweb yes  :tangle harmony.sc
  ~setSpatPositions = { arg spat_array, duration = 10;
    "The spat array".postln;
    spat_array.postln;
    "length of spat_Array".postln;
    ~spatializations.do({ arg item, i; // i is the row
          var pos;
          /* Get the x/y position */	
          if(spat_array.size == 0,
            {
                  /* The call to ~setSpatPositions was done without an argument */
                  pos = ~spatializations.at(i);
                  if(~spatializations.at(i).size < 4,
                    {
                          pos.extend(4, 0);
                          pos.put(2, 1.0);
                          pos.put(3, 0.0);
                    },
                    {
                    }); 
            }, 
            {
                  /* The call to ~setSpatPositions was done with an argument */
                  pos = ~allRings.wrapAt(spat_array.wrapAt(i)[0]);
                  "current pos value".postln;
                  pos.postln;  
                  pos.put(2, spat_array.wrapAt(i)[1]);
                  pos.put(3, spat_array.wrapAt(i)[2]);
            }); /* End of if(spat_array.size) */
  
          ~spatializations.put(i, pos);
          if(~logging > 1,
            {
                  "Set panning:".postln;
                  "Putting spat angles ".post;  pos[0].post; "/".post; pos[1].post; " at index ".post; i.post; " with distance ".post; pos[2].post; " and spread ".post; pos[3].postln;
            }, { }); // if logging
    }); // spatialilzation.do
    ~updatePanning.value(duration);
  };
  // ~setSpatPositions.value();
#+end_src

#+begin_src sclang :results none
~setSpatPositions.value([ [ 5, 0.001, 0.1 ], [ 6, 0.001, 0.1 ], [ 0, 0.01, 0.1 ], [ 13, 0.70112240314484, 91 ], [ 4, 0.029506921768188, 9 ], [ 12, 0.64996898174286, 74 ], [ 6, 0.36793804168701, 15 ], [ 12, 0.62310302257538, 40 ], [ 1, 0.3138290643692, 56 ], [ 2, 0.23481667041779, 55 ], [ 8, 0.34279143810272, 72 ], [ 3, 0.21060848236084, 59 ], [ 6, 0.90231537818909, 9 ], [ 3, 0.96117198467255, 5 ], [ 4, 0.26086962223053, 64 ] ], 10);
#+end_src

Bring forward
#+begin_src sclang :results none
~setSpatPositions.value([ [ 0, 1, 1 ], [ 2, 1, 1 ] ], 10);
#+end_src

Put to distance
#+begin_src sclang :results none
~setSpatPositions.value([ [ 0, 0, 1 ], [ 2, 0, 1 ] ], 10);
#+end_src

#+begin_src sclang :results none
  ~setSynth.value(0, \gain, 1);
  ~setSynth.value(1, \gain, 1);
  ~setSynth.value(2, \gain, 1);
  ~setSynth.value(3, \gain, 1);
#+end_src

#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 2, 0.05, 1 ],
    [ 6, 0.05, 1 ],
    [ 13, 0.05, 1 ],
    [ 0, 0.05, 1 ] ],
    30);
#+end_src

In the distance
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 0.05, 1 ],
    [ 4, 0.05, 1 ],
    [ 10, 0.05, 1 ],
    [ 12, 0.05, 1 ] ],
    30);
#+end_src

Bring forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 1, 1 ],
    [ 4, 1, 1 ],
    [ 10, 1, 1 ],
    [ 12, 1, 1 ] ],
    30);
#+end_src

Mix forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 0.05, 1 ],
    [ 4, 1, 1 ],
    [ 10, 0.05, 1 ],
    [ 12, 1, 1 ] ],
    30);
#+end_src

Mix forward
#+begin_src sclang :results none
  ~setSpatPositions.value([
    [ 0, 1, 1 ],
    [ 4, 0.05, 1 ],
    [ 10, 1, 1 ],
    [ 12, 0.05, 1 ] ],
    30);
#+end_src

#+begin_src sclang :results none
  var setMe = 0.5;
  ~reverbSendNdefs[0].set(\revScaleI, setMe);
  ~reverbSendNdefs[0].set(\revScaleII, setMe);
  ~reverbSendNdefs[1].set(\revScaleI, setMe);
  ~reverbSendNdefs[1].set(\revScaleII, setMe);
#+end_src

#+name: init_spatialization
#+begin_src sclang :results none :noweb yes
  <<set_spatialization>>
  ~setSpatPositions.value();
#+end_src
#+begin_src sclang :results none
  ~spatializations.at(0).size.postln;
#+end_src

Change spatialization. Spat is controlled by an arbitrary length array that points to one of the 14 (0-13) speaker positions available. Use the ~spat_function~ to create new presets.
#+begin_src sclang :results none
  ~setSpatialization.value(\distanceO, 10);
  ~setSpatialization.value(\distanceI, 10);
#+end_src

#+begin_src sclang :results none
  ~setSpatialization.value(\frontTop, 20);
#+end_src

#+begin_src sclang :results none
  var dist = 0.5, pos;
  pos = ~allRings.wrapAt([0,10].wrapAt(0));
  pos.put(2, dist);
#+end_src
#+begin_src sclang :results none
  a = [[1, 0.82614958286285, 82 ][4, 0.13166451454163, 15 ]];
#+end_src

Never set the spread to less then 0.1.
#+name: spat_function
#+begin_src sclang :results none
  ~setSpatialization = { arg preset, time;
    switch(preset,
          \single, { ~setSpatPositions.value([[1, 0, 90], [8, 0, 0.1]]); },
          \simple, { ~setSpatPositions.value([[0, 0.6, 0.1], [1, 0.6, 0 ]]); },
          \distanceI, { ~setSpatPositions.value([[0, 0.0, 0.0], [1, 0.0, 0.0]]); },
          \distanceO, { ~setSpatPositions.value([[0, 1, 50.0], [1, 1, 0.0]]); },
          \nther, { ~setSpatPositions.value([[3, 0.1, 0.0], [0, 0.6, 0.0]]); },
          \sine, { ~setSpatPositions.value([[0.0, 0.1, 0.0], [2.0, 0.2, 0.0], [4.0, 0.3, 0.0], [6.0, 0.4, 0.0], [7.0, 0.3, 0.0], [9.0, 0.3, 0.0], [10.0, 0.2, 0.0], [12.0, 0.1, 0.0], [13.0, 0.1, 0.0], [13.0 , 0.1, 0.0], [ 13.0, 0.1, 0.0], [ 13.0, 0.1, 0.0], [ 3.0, 0.1, 0.0], [13.0 , 0.1, 0.0], [12.0, 0.1, 0.0], [10.0, 0.1, 0.0], [9.0 , 0.1, 0.0], [7.0, 0.1, 0.0], [6.0, 0.1, 0.0], [4.0, 0.1, 0.0], [2.0, 0.1, 0.0]]); },
          \frontTop, { ~setSpatPositions.value([[2, 1, 0.0], [5, 1, 0.0], [9, 0.3, 0.0], [12, 0.3, 0.0],[9, 0.3, 0.0],[12, 0.3, 0.0],[9, 0.3, 0.0],[12, 0.3, 0.0],[8, 0.3, 0.0],[9, 0.3, 0.0]]); };
    )};
#+end_src

#+begin_src sclang :results none
  ~generateRandomSpat = {
    ~spatializations.size.postln;
    b = Array.new(~spatializations.size * 3);
    ~spatializations.do({ arg item, i;
          c = Array.with(14.rand, 1.0.rand, 100.rand);
          b = b.addAll(c);
    });
    a = Array2D.fromArray(~spatializations.size, 3, b);
    a.postln;
  };
  ~generateRandomSpat.value();
#+end_src

#+begin_src sclang :results none
  //  a = Array.fill2D(2, 3, { arg r,c; r*c+c;});
  a = [ [ 0, 1, 2 ], [ 0, 2, 4 ] ];
  a[1][2].postln;
  a.size.postln;
#+end_src
#+begin_src sclang :results none
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addAll([7, 8, 9]);
z.postln;
y.postln;
)
#+end_src
_4. Free all_
Free all busses and stop execution
#+name: free_all
#+begin_src sclang :results none :noweb yes
  <<free_busses>>
  Ndef(\reverbBus).clear;
  Ndef(\reverb).clear;
  CmdPeriod.run;
#+end_src

Reboot Supercollider
#+begin_src sclang :results none
  s.reboot;
#+end_src

Show meter
#+name: show_meter
#+begin_src sclang :results none
  s.meter;
#+end_src

Plot tree
#+name: plot_tree
#+begin_src sclang :results none
  s.plotTree
#+end_src
--------------------------------

#+begin_src sclang :results none
  ~audioBusses[1].scope;
#+end_src
*** scheme functions
#+name: spat_list
#+begin_src scheme :var mult=0.01 :noweb yes :results value
  <<sequenced_array>>
  (map (lambda (x)
         (format #t "~a, " (truncate (* x 14))))
       (seq-array-sin 0 21 (list)))
#+end_src

#+begin_src scheme :var mult=0.01 :noweb yes :results output
  (seq-array 0 21 '())
#+end_src

#+begin_src scheme :results value
  (define hello
  (lambda (name)
    (string-append "Hello " name)))
  (hello "Steve")
#+end_src

#+begin_src scheme :results value
  ((lambda (i n x)
     (car x)) 0 9 '(1 2 3))
#+end_src

#+RESULTS:

**** list creation functions
Use ~select-seq-array~ as a utility function to be able to select function programmatically. All seg-array-* are normalized.
#+name: sequenced_array
#+begin_src scheme :results value
  (define pi 3.141592654)
  
  (define seq-array
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array (+ i 1) n
                     (append x (list (/ i (- n 1.0))))))))
  
  (define seq-array-reciprocal
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-reciprocal (+ i 1) n
                                (append x (list
                                           (/ 1 (+ 1.0 i))))))))
  
  (define seq-array-exponential
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-exponential (+ i 1) n
                                 (append x (list
                                            (/ (expt 2 i) (expt 2 (- n 1.0)))))))))
  
  (define seq-array-log
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-log (+ i 1) n
                         (append x (list (/ (log (+ i 1)) (log n))))))))
  
  (define seq-array-sin
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-sin (+ i 1) n
                         (append x (list (sin (* (/ i n) pi))))))))
  
  (define seq-array-cos
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array-cos (+ i 1) n
                         (append x (list (cos (* (/ i n) (/ pi 2)))))))))
  
  (define select-seq-array
    (lambda (i n x j)
      (cond ((= j 0) (seq-array i n x))
            ((= j 1) (seq-array-reciprocal i n x))
            ((= j 2) (seq-array-exponential i n x))
            ((= j 3) (seq-array-log i n x))
            ((= j 4) (seq-array-sin i n x))
            ((= j 5) (seq-array-cos i n x)))))
  (select-seq-array 0 9 '() 1)
#+end_src

#+RESULTS: sequenced_array

value_sequence example call for the ~seq-array~ function, creating a list of sequence arrays:
#+begin_src scheme :noweb yes :results value
  <<sequenced_array>>
  (seq-array 0 20 (list))
#+end_src

#+RESULTS:
| 0.0 | 0.05263157894736842 | 0.10526315789473684 | 0.15789473684210525 | 0.21052631578947367 | 0.2631578947368421 | 0.3157894736842105 | 0.3684210526315789 | 0.42105263157894735 | 0.47368421052631576 | 0.5263157894736842 | 0.5789473684210527 | 0.631578947368421 | 0.6842105263157895 | 0.7368421052631579 | 0.7894736842105263 | 0.8421052631578947 | 0.8947368421052632 | 0.9473684210526315 | 1.0 |

***** shift list
Shift items in a list and resturn a list of lists, all items shifted by one.

Functions:
  - duplicate-shift /rows list newlist/: take a list a duplicated it while shifting it one step to the right.
  - make-shift-list /rows list . flag/: utility function that calls duplicate-list. If ~flag~ is supplied with a value of 1 a non-shifted list is generated.
    #+name: shift_list
    #+begin_src scheme
      (define duplicate-shift
        (lambda (n lst newlst)
          (cond ((= 0 n) newlst)
                ((duplicate-shift (- n 1) 
                                  (append (cdr lst) (list (car lst)))
                                  (append newlst (list (append (cdr lst) (list (car lst))))))))))
      
      (define make-shift-list
        (lambda (rows lst . flag)
          (let ((flag (if (pair? flag) (car flag) 0)))
            (cond ((= flag 1) (duplicate-shift rows lst (list lst)))
                  ((= flag 0) (make-list rows lst))))))
    #+end_src

    Example use of [[*shift list][shift list]] using [[*value sequence][value sequence]]. The latter creates an array of numbers that is duplicated and shifted to the right
    #+begin_src scheme :noweb yes
      <<sequenced_array>>
      <<shift_list>>
      (make-shift-list 5 (seq-array 0 3 (list)) 1)
    #+end_src

    #+RESULTS:
    | 0.0 | 0.5 | 1.0 |
    | 0.5 | 1.0 | 0.0 |
    | 1.0 | 0.0 | 0.5 |
    | 0.0 | 0.5 | 1.0 |
    | 0.5 | 1.0 | 0.0 |
    | 1.0 | 0.0 | 0.5 |
    | 0.0 | 0.5 | 1.0 |
    | 0.5 | 1.0 | 0.0 |
    | 1.0 | 0.0 | 0.5 |
    | 0.0 | 0.5 | 1.0 |
    | 0.5 | 1.0 | 0.0 |

    Example use of shift list and sine mapping, not relying on ~value_sequence~.
    #+begin_src scheme :noweb yes
      (define lst (iota 5))
      <<shift_list>>
      (duplicate-shift 3 (map (lambda (x) (sin (* 0.1 x))) lst) (list (list)))
    #+end_src

    #+RESULTS:
    |---------------------+---------------------+--------------------+---------------------+---------------------|
    | 0.09983341664682815 | 0.19866933079506122 | 0.2955202066613396 |  0.3894183423086505 |                 0.0 |
    | 0.19866933079506122 |  0.2955202066613396 | 0.3894183423086505 |                 0.0 | 0.09983341664682815 |
    |  0.2955202066613396 |  0.3894183423086505 |                0.0 | 0.09983341664682815 | 0.19866933079506122 |

***** write data file for spatialisation
:PROPERTIES:
:header-args: :results output raw :exports code :noweb yes :wrap "src sclang"
:END:

#+begin_src scheme :var size=10 :results output :noweb yes
  <<sequenced_array>>
  (use-modules (ice-9 format))
  (define spread (seq-array 0 size '()))
  (define distance  (seq-array-sin 0 size '()))
  (define azel  (seq-array-exponential 0 size '()))
  (format #t "~a" "[")
  (map (lambda (ae dist spr)
         (format #t "[~d, ~f, ~f], " (round (* size ae)) dist spr))
       spread distance azel)
  (format #t "~a" "]")
#+end_src

#+RESULTS:
#+begin_SRC sclang
[[0.0, 0.0, 0.001953125], [1.0, 0.30901699441396047, 0.00390625], [2.0, 0.587785252358846, 0.0078125], [3.0, 0.8090169944472815, 0.015625], [4.0, 0.951056516345858, 0.03125], [6.0, 1.0, 0.0625], [7.0, 0.9510565162190971, 0.125], [8.0, 0.8090169942061681, 0.25], [9.0, 0.5877852520269814, 0.5], [10.0, 0.3090169940238303, 1.0], ]
#+end_SRC



***** unused
#+begin_src scheme
  <<shift_list>>
  
  (define seq-array
    (lambda (i n x)
      (if (= i n)
          x
          (seq-array (+ i 1) n
                     (append x (list
                                (/ 1 (+ 1.0 i))))))))
  
  (define shifted-seq (duplicate-shift 10 (seq-array 0 10 (list)) (list (seq-array 0 10 (list)))))
  
  (define repeats
    (lambda (n lgth items x)
      (if (= n items)
          x
          (repeats (+ n 1) lgth items
                   (append x (list
                              (format #f "Pseq([~{~a, ~}], inf)"
                                      (list-ref shifted-seq n))))))))
#+end_src

#+RESULTS:

Generate a list of increasing values, 0-lgth
#+name: value_list
#+begin_src scheme :var lgth=10
  (define valuelist
    (lambda (i n x)
      (if (= i n)
          x
          (valuelist (+ i 1) n (append x (list (format #f "Pseq([~d], inf)" (+ i 1))))))))
  (valuelist 0 lgth (list))
#+end_src

#+RESULTS: value_list
| Pseq([1], inf) | Pseq([2], inf) | Pseq([3], inf) | Pseq([4], inf) | Pseq([5], inf) | Pseq([6], inf) | Pseq([7], inf) | Pseq([8], inf) | Pseq([9], inf) | Pseq([10], inf) |

**** test with Synthdef
 #+begin_src sclang :results none
	Synth.new(\vbap_panning, [\bus, ~audioBusses[0], \spkr_buffer, ~spkrBuffer.bufnum, \azimuth, 0, \elevation, 0, \spread, 0], addAction: \addToTail);
 #+end_src

 #+begin_src sclang :results none
	SynthDef(\vbap_panning, { var input, snd, bus;
	  bus = \bus.kr;
	  input = In.ar(bus);
	  snd = VBAP.ar(29,
		input,
		\spkr_buffer.ir,
		\azimuth.kr(0),
		\elevation.kr(0),
		\spread.kr(0));
	  Out.ar(0, snd);
	}).add;
 #+end_src

*** free busses
#+name: free_busses
#+begin_src sclang :results none
  ~freeAllBusses = {
    var int = 0;
    if(~audioBusses.size == 0,
          { "Array is empty".postln },
          {
            while({ int < ~audioBusses.size }, {
                  if(~audioBusses[int].index == nil,
                    { "Bus cleared already".postln; },
                    {		
                          "Clearing bus ".post; ~audioBusses[int].index.postln;
                          ~audioBusses[int].free;
                          ~frequencyBus[int].free;			
                          ~controlBus[int].free;
                          ~synths[int].free;			
                    });		
                  int = int + 1;
            });
          })
  };
  ~freeAllBusses.value();
  
  ~freeNdefs = {
    Ndef.clear(0);
  };
  ~freeNdefs.value();
#+end_src
*** alternative stuff
Interpolate over pan values by means of Task
#+name: interpolator
#+begin_src sclang :results none 
  ~interpolator = { arg instance = 0, range = (0..180), delta = 0.05, param = \azi;
	 var interpolate;
	 interpolate = Task({
	  range.do({ arg index;
		 p = index;
		 ~spatNdefs[instance].set(param, p);
		 delta.wait;	
	  });
	 });
	 interpolate;
  };
#+end_src

Set all channels' panning positions using the Task above.
#+begin_src sclang :results none
  ~spatNdefs.do({ arg channel, i;
	 var ae, as, es = 0, ee = 1;
	 as = channel.get(\azi);
	 es = channel.get(\ele);
	 ae = ~spatializations[i][0];
	 ~interpolator.value(i, (as..ae), 0.1, \azi).play;
	 ~interpolator.value(i, (es..ee), 0.1, \ele).play;
	 //"Angles are set to ".post; ae.postln;
	 channel.set(\ele, ~spatializations[i][1]);
  });
#+end_src

Example calls for the ~~interpolator~ function.
#+begin_src sclang :results none
  q = ~interpolator.value(0, (0..180), 0.1).play;
  p = ~interpolator.value(1, (180..0), 0.1).play;
#+end_src

Fill the ~~spatializations~ array with random indexes.
#+begin_src sclang :results none :noweb yes
  var delta = 0.5;
  Task({
	 (1..64).do({ arg index;
	  var ~spatPositions =  Array.rand(12, 0, 13);
	  ~spatializations.do({ arg item, i;
		 ~spatializations.put(i, ~allRings[~spatPositions[i]]);
		 "Putting ".post;  ~spatPositions[i].post; " at index ".post; i.postln;
	  });
	  ~spatChannels.do({ arg channel, i;
		 channel.set(\ele, ~spatializations[i][0], \ele, ~spatializations[i][1]);
	  });
	  delta.wait;	
	 });
  }).play;
#+end_src

